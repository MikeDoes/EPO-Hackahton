<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE ep-patent-document PUBLIC "-//EPO//EP PATENT DOCUMENT 1.5.1//EN" "ep-patent-document-v1-5-1.dtd">
<!-- This XML data has been generated under the supervision of the European Patent Office -->
<ep-patent-document id="EP16734804B1" file="EP16734804NWB1.xml" lang="en" country="EP" doc-number="3311569" kind="B1" date-publ="20211006" status="n" dtd-version="ep-patent-document-v1-5-1">
<SDOBI lang="en"><B000><eptags><B001EP>ATBECHDEDKESFRGBGRITLILUNLSEMCPTIESILTLVFIROMKCYALTRBGCZEEHUPLSK..HRIS..MTNORS..SM..................</B001EP><B003EP>*</B003EP><B005EP>J</B005EP><B007EP>BDM Ver 2.0.12 (4th of August) -  2100000/0</B007EP></eptags></B000><B100><B110>3311569</B110><B120><B121>EUROPEAN PATENT SPECIFICATION</B121></B120><B130>B1</B130><B140><date>20211006</date></B140><B190>EP</B190></B100><B200><B210>16734804.4</B210><B220><date>20160617</date></B220><B240><B241><date>20180111</date></B241><B242><date>20181105</date></B242></B240><B250>en</B250><B251EP>en</B251EP><B260>en</B260></B200><B300><B310>201562181744 P</B310><B320><date>20150618</date></B320><B330><ctry>US</ctry></B330><B310>201562192310 P</B310><B320><date>20150714</date></B320><B330><ctry>US</ctry></B330><B310>201615184103</B310><B320><date>20160616</date></B320><B330><ctry>US</ctry></B330></B300><B400><B405><date>20211006</date><bnum>202140</bnum></B405><B430><date>20180425</date><bnum>201817</bnum></B430><B450><date>20211006</date><bnum>202140</bnum></B450><B452EP><date>20210428</date></B452EP></B400><B500><B510EP><classification-ipcr sequence="1"><text>H04N  19/176       20140101AFI20161223BHEP        </text></classification-ipcr><classification-ipcr sequence="2"><text>H04N  19/593       20140101ALI20161223BHEP        </text></classification-ipcr><classification-ipcr sequence="3"><text>H04N  19/11        20140101ALI20161223BHEP        </text></classification-ipcr><classification-ipcr sequence="4"><text>H04N  19/463       20140101ALI20161223BHEP        </text></classification-ipcr><classification-ipcr sequence="5"><text>H04N  19/136       20140101ALI20161223BHEP        </text></classification-ipcr><classification-ipcr sequence="6"><text>H04N  19/80        20140101ALI20161223BHEP        </text></classification-ipcr><classification-ipcr sequence="7"><text>H04N  19/59        20140101ALI20161223BHEP        </text></classification-ipcr></B510EP><B520EP><classifications-cpc><classification-cpc sequence="1"><text>H04N  19/463       20141101 LI20160729BHEP        </text></classification-cpc><classification-cpc sequence="2"><text>H04N  19/136       20141101 LI20160729BHEP        </text></classification-cpc><classification-cpc sequence="3"><text>H04N  19/11        20141101 LI20160729BHEP        </text></classification-cpc><classification-cpc sequence="4"><text>H04N  19/176       20141101 FI20161222BHEP        </text></classification-cpc><classification-cpc sequence="5"><text>H04N  19/59        20141101 LI20160729BHEP        </text></classification-cpc><classification-cpc sequence="6"><text>H04N  19/80        20141101 LI20160729BHEP        </text></classification-cpc><classification-cpc sequence="7"><text>H04N  19/593       20141101 LI20160729BHEP        </text></classification-cpc></classifications-cpc></B520EP><B540><B541>de</B541><B542>INTRAPRÄDIKTIONS- UND INTRAMODUSCODIERUNG</B542><B541>en</B541><B542>INTRA PREDICTION AND INTRA MODE CODING</B542><B541>fr</B541><B542>INTRAPRÉDICTION ET CODAGE À MODES INTRA</B542></B540><B560><B562><text>Jani Lainema ET AL: "Chapter 4 Intra-Picture Prediction in HEVC" In: "High Efficiency Video Coding (HEVC)", 1 August 2014 (2014-08-01), Springer International Publishing, XP055292569, ISBN: 978-3-319-06894-7 vol. 29, pages 91-112, DOI: 10.1007/978-3-319-06895-4_4, page 91, paragraph 4.1 - page 93; table 4.1 page 97, paragraph 4.3.1 - page 100 page 103, paragraph 4.4 - page 104 page 106, paragraph 4.5 - page 107</text></B562><B562><text>LIANG ZHAO ET AL: "Fast mode decision algorithm for intra prediction in HEVC", VISUAL COMMUNICATIONS AND IMAGE PROCESSING (VCIP), 2011 IEEE, IEEE, 6 November 2011 (2011-11-06), pages 1-4, XP032081373, DOI: 10.1109/VCIP.2011.6115979 ISBN: 978-1-4577-1321-7</text></B562><B562><text>JIANLE CHEN ET AL: "Further improvements to HMKTA-1.0", 52. VCEG MEETING; 19-6-2015 - 26-6-2015; WARSAW; (VIDEO CODING EXPERTS GROUP OF ITU-T SG.16),, no. VCEG-AZ07, 19 June 2015 (2015-06-19), XP030003885,</text></B562><B562><text>ANONYMOUS: "The H.264 Advanced Video Compression Standard, 2nd Edition, chapter 6, H.264 Prediction, Iain E. Richardson", NOT KNOWN,, 20 April 2010 (2010-04-20), XP030001637,</text></B562></B560></B500><B700><B720><B721><snm>ZHAO, Xin</snm><adr><str>5775 Morehouse Drive</str><city>San Diego, California 92121-1714</city><ctry>US</ctry></adr></B721><B721><snm>CHEN, Jianle</snm><adr><str>5775 Morehouse Drive</str><city>San Diego, California 92121-1714</city><ctry>US</ctry></adr></B721><B721><snm>ZHANG, Li</snm><adr><str>5775 Morehouse Drive</str><city>San Diego, California 92121-1714</city><ctry>US</ctry></adr></B721><B721><snm>KARCZEWICZ, Marta</snm><adr><str>5775 Morehouse Drive</str><city>San Diego, California 92121-1714</city><ctry>US</ctry></adr></B721></B720><B730><B731><snm>Qualcomm Incorporated</snm><iid>101503788</iid><irf>P/78081.EP01</irf><adr><str>International IP Administration 
5775 Morehouse Drive</str><city>San Diego, CA 92121-1714</city><ctry>US</ctry></adr></B731></B730><B740><B741><snm>Loveless, Ian Mark</snm><iid>101262271</iid><adr><str>Reddie &amp; Grose LLP 
The White Chapel Building 
10 Whitechapel High Street</str><city>London E1 8QS</city><ctry>GB</ctry></adr></B741></B740></B700><B800><B840><ctry>AL</ctry><ctry>AT</ctry><ctry>BE</ctry><ctry>BG</ctry><ctry>CH</ctry><ctry>CY</ctry><ctry>CZ</ctry><ctry>DE</ctry><ctry>DK</ctry><ctry>EE</ctry><ctry>ES</ctry><ctry>FI</ctry><ctry>FR</ctry><ctry>GB</ctry><ctry>GR</ctry><ctry>HR</ctry><ctry>HU</ctry><ctry>IE</ctry><ctry>IS</ctry><ctry>IT</ctry><ctry>LI</ctry><ctry>LT</ctry><ctry>LU</ctry><ctry>LV</ctry><ctry>MC</ctry><ctry>MK</ctry><ctry>MT</ctry><ctry>NL</ctry><ctry>NO</ctry><ctry>PL</ctry><ctry>PT</ctry><ctry>RO</ctry><ctry>RS</ctry><ctry>SE</ctry><ctry>SI</ctry><ctry>SK</ctry><ctry>SM</ctry><ctry>TR</ctry></B840><B860><B861><dnum><anum>US2016038182</anum></dnum><date>20160617</date></B861><B862>en</B862></B860><B870><B871><dnum><pnum>WO2016205712</pnum></dnum><date>20161222</date><bnum>201651</bnum></B871></B870></B800></SDOBI>
<description id="desc" lang="en"><!-- EPO <DP n="1"> -->
<heading id="h0001"><b>TECHNICAL FIELD</b></heading>
<p id="p0001" num="0001">This disclosure relates to video encoding and decoding.</p>
<heading id="h0002"><b>BACKGROUND</b></heading>
<p id="p0002" num="0002">Digital video capabilities can be incorporated into a wide range of devices, including digital televisions, digital direct broadcast systems, wireless broadcast systems, personal digital assistants (PDAs), laptop or desktop computers, tablet computers, e-book readers, digital cameras, digital recording devices, digital media players, video gaming devices, video game consoles, cellular or satellite radio telephones, so-called "smart phones," video teleconferencing devices, video streaming devices, and the like. Digital video devices implement video compression techniques, such as those described in the standards defined by MPEG-2, MPEG-4, ITU-T H.263, ITU-T H.264/MPEG-4, Part 10, Advanced Video Coding (AVC), the High Efficiency Video Coding (HEVC) standard, and extensions of such standards. The video devices may transmit, receive, encode, decode, and/or store digital video information more efficiently by implementing such video compression techniques.</p>
<p id="p0003" num="0003">Video compression techniques perform spatial (intra-picture) prediction and/or temporal (inter-picture) prediction to reduce or remove redundancy inherent in video sequences. For block-based video coding, a video slice (i.e., a video frame or a portion of a video frame) may be partitioned into video blocks. Video blocks in an intra-coded (I) slice of a picture are encoded using spatial prediction with respect to reference samples in neighboring blocks in the same picture. Video blocks in an inter-coded (P or B) slice of a picture may use spatial prediction with respect to reference samples in neighboring blocks in the same picture or temporal prediction with respect to reference samples in other reference pictures. Pictures may be referred to as frames, and reference pictures may be referred to as reference frames.</p>
<p id="p0004" num="0004">Spatial or temporal prediction results in a predictive block for a block to be coded. Residual data represents pixel differences between the original block to be coded and the predictive block. An inter-coded block is encoded according to a motion vector that points to<!-- EPO <DP n="2"> --> a block of reference samples forming the predictive block, and the residual data indicates the difference between the coded block and the predictive block. An intra-coded block is encoded according to an intra-coding mode and the residual data. For further compression, the residual data may be transformed from the pixel domain to a transform domain, resulting in residual coefficients, which then may be quantized. The quantized coefficients, initially arranged in a two-dimensional array, may be scanned in order to produce a one-dimensional vector of coefficients, and entropy coding may be applied to achieve even more compression.</p>
<p id="p0005" num="0005"><nplcit id="ncit0001" npl-type="b"><text>Chapter 4 of the book "High Efficiency Video Coding (HEVC), Algorithms and Architectures" by Vivienne Sze </text></nplcit>et al describes intra-picture prediction in HEVC. The <nplcit id="ncit0002" npl-type="s"><text>paper "Fast Mode Decision Algorithm for Intra Prediction in HEVC" by Zhao et al, Proceedings the IEEE Conference on Visual Communication and Image Processing (VCIP), 2011</text></nplcit>, describes techniques for speeding up the mode selection process by reducing the candidate modes tested using rate-distortion optimization.</p>
<heading id="h0003"><b>SUMMARY</b></heading>
<p id="p0006" num="0006">In general, this disclosure describes techniques for intra prediction and intra prediction mode coding, which may be used in the context of advanced video codecs, such as extensions of the High Efficiency Video Coding (HEVC) standard, or the next generation of video coding standards. The scope of protection is defined by the independent claims, to which reference should now be made. Optional features are included in the dependent claims.</p>
<p id="p0007" num="0007">According to one aspect of the claimed invention, there is provided a method of encoding block of video data that includes selecting, based on intra prediction modes used to encode one or more neighboring blocks of the block of video data, a subset of 33 angular intra prediction modes from among a plurality of intra prediction modes, wherein the plurality of intra prediction modes includes 65 angular intra prediction modes; encoding syntax information that indicates a selected intra prediction mode for a current prediction unit, PU, of the block of video data from among the subset of 33 angular intra prediction modes; and encoding the block of video data based on the selected intra prediction mode using 1/32 pel accuracy. Encoding the block of video data comprises: for each respective sample of a predictive block of the current PU: determining a fractional position between two neighboring reconstructed samples by projecting, along a prediction direction associated with the selected intra prediction mode, a coordinate of the respective sample to a row or column of neighboring reconstructed samples containing the two neighboring reconstructed samples, wherein the two neighboring reconstructed samples neighbor the current PU; and calculating a prediction value of the respective sample using an interpolation filter that uses values of the<!-- EPO <DP n="3"> --> two neighboring reconstructed samples to interpolate a value at the determined fractional position, the interpolation being in 1/32 pel interpolation accuracy.</p>
<p id="p0008" num="0008">According to another aspect of the claimed invention, there is provided a method of decoding a block of video data that includes selecting, based on intra prediction modes used to decode one or more neighboring blocks of the block of video data, a subset of 33 angular intra prediction modes from among a plurality of intra prediction modes, wherein the plurality of intra prediction modes includes 65 angular intra prediction modes; decoding syntax information that indicates a selected intra prediction mode for a current prediction unit, PU, of the block of video data from among the subset of 33 angular intra prediction modes;; and reconstructing the block of video data based on the selected intra prediction mode using 1/32 pel interpolation accuracy. Reconstructing the block of video data comprises: for each respective sample of a predictive block of the current PU: determining a fractional position between two neighboring reconstructed samples by projecting, along a prediction direction associated with the selected intra prediction mode, a coordinate of the respective sample to a row or column of neighboring reconstructed samples containing the two neighboring reconstructed samples, wherein the two neighboring reconstructed samples neighbor the current PU; and calculating a value of the respective sample using an interpolation filter that uses values of the two neighboring reconstructed samples to interpolate a value at the determined fractional position, the interpolation being in 1/32 pel accuracy.</p>
<p id="p0009" num="0009">According to another aspect of the claimed invention, there is provided a device for encoding video data that includes a memory configured to store the video data; and one or more processors configured to: select, based on intra prediction modes used to encode one or more neighboring blocks of a block of video data, a subset of 33 angular intra prediction modes from among a plurality of intra prediction modes, wherein the plurality of intra prediction modes includes 65 angular intra prediction modes; encode syntax information that indicates a selected intra prediction mode for a current prediction unit, PU, of the block of video data from among the subset of 33 angular intra prediction modes; and encode the block of video data based on the selected intra prediction mode using 1/32 pel interpolation accuracy. Encoding the block of video data comprises: for each respective sample of a predictive block of the current PU: determining a fractional position between two neighboring reconstructed samples by projecting, along a prediction direction associated with the selected intra prediction mode, a coordinate of the respective sample to a row or column of neighboring reconstructed samples containing the two neighboring reconstructed samples,<!-- EPO <DP n="4"> --> wherein the two neighboring reconstructed samples neighbor the current PU; and calculating a prediction value of the respective sample using an interpolation filter that uses values of the two neighboring reconstructed samples to interpolate a value at the determined fractional position, the interpolation being in 1/32 pel accuracy.</p>
<p id="p0010" num="0010">According to another aspect of the claimed invention, there is provided a device for decoding video data that includes a memory configured to store the video data; and one or more processors configured to: select, based on intra prediction modes used to decode one or more neighboring blocks of a block of video data in a current picture of video data, a subset of 33 angular intra prediction modes from among a plurality of intra prediction modes, wherein the plurality of intra prediction modes includes 65 angular intra prediction modes; decode syntax information that indicates a selected intra prediction mode for a current prediction unit, PU, of the block of video data from among the subset of 33 angular intra prediction modes; and reconstruct the block of video data based on the selected intra prediction mode using 1/32 pel interpolation accuracy. Reconstructing the block of video data comprises: for each respective sample of a predictive block of the current PU: determining a fractional position between two neighboring reconstructed samples by projecting, along a prediction direction associated with the selected intra prediction mode, a coordinate of the respective sample to a row or column of neighboring reconstructed samples containing the two neighboring reconstructed samples, wherein the two neighboring reconstructed samples neighbor the current PU; and calculating a value of the respective sample using an interpolation filter that uses values of the two neighboring reconstructed samples to interpolate a value at the determined fractional position, the interpolation being in 1/32 pel accuracy.</p>
<p id="p0011" num="0011">According to another aspect of the claimed invention, there is provided a computer readable medium that stores instructions that, when executed by one or more processors cause the one or more processors to perform the method of encoding or decoding.</p>
<p id="p0012" num="0012">The details of one or more examples are set forth in the accompanying drawings and the description below. Other features, objects, and advantages will be apparent from the description and drawings, and from the claims.<!-- EPO <DP n="5"> --></p>
<heading id="h0004"><b>BRIEF DESCRIPTION OF DRAWINGS</b></heading>
<p id="p0013" num="0013">
<ul id="ul0001" list-style="none" compact="compact">
<li><figref idref="f0001">FIG. 1</figref> is a block diagram illustrating an example video coding system that may utilize the techniques described in this disclosure.</li>
<li><figref idref="f0002">FIG. 2</figref> is a conceptual diagram illustrating an example of intra prediction of a block of video data.</li>
<li><figref idref="f0003">FIG. 3</figref> is a conceptual diagram illustrating an example of intra prediction modes and corresponding mode indexes.</li>
<li><figref idref="f0004">FIG. 4</figref> is a conceptual diagram illustrating an example technique for generating a prediction sample for a block of video data according to a planar intra prediction mode.</li>
<li><figref idref="f0005">FIG. 5</figref> is a conceptual diagram illustrating an example technique for generating a prediction sample for a block of video data according to an angular intra prediction mode.</li>
<li><figref idref="f0006">FIG. 6</figref> is a block diagram illustrating an example video encoder that may implement the techniques described in this disclosure.</li>
<li><figref idref="f0007">FIG. 7</figref> is a block diagram illustrating an example video decoder that may implement the techniques described in this disclosure.</li>
<li><figref idref="f0008">FIG. 8</figref> is a conceptual diagram illustrating an example of intra prediction modes and corresponding mode indexes according to the techniques of this disclosure.</li>
<li><figref idref="f0009">FIG. 9</figref> is a conceptual diagram illustrating example intra prediction angles according to the techniques of this disclosure.</li>
<li><figref idref="f0010">FIG. 10</figref> is a flowchart illustrating a method of encoding video data in accordance with techniques of this disclosure.</li>
<li><figref idref="f0011">FIG. 11</figref> is a flowchart illustrating a method of decoding video data in accordance with techniques of this disclosure.</li>
<li><figref idref="f0012">FIG. 12</figref> is a flowchart illustrating a method of encoding video data in accordance with techniques of this disclosure.</li>
<li><figref idref="f0013">FIG. 13</figref> is a flowchart illustrating a method of decoding video data in accordance with techniques of this disclosure.</li>
<li><figref idref="f0014">Fig. 14</figref> is a flowchart illustrating a method of encoding video data in accordance with techniques of this disclosure.<!-- EPO <DP n="6"> --></li>
<li><figref idref="f0015">FIG. 15</figref> is a flowchart illustrating a method of decoding video data in accordance with techniques of this disclosure.</li>
<li><figref idref="f0016">FIG. 16</figref> is a flowchart illustrating a method of encoding video data in accordance with techniques of this disclosure.</li>
<li><figref idref="f0017">FIG. 17</figref> is a flowchart illustrating a method of decoding video data in accordance with techniques of this disclosure.</li>
<li><figref idref="f0018">FIG. 18</figref> is a flowchart illustrating a method of encoding video data in accordance with techniques of this disclosure.</li>
<li><figref idref="f0018">FIG. 19</figref> is a flowchart illustrating a method of decoding video data in accordance with techniques of this disclosure.</li>
<li><figref idref="f0019">FIG. 20</figref> is a flowchart illustrating a method of encoding video data in accordance with techniques of this disclosure.</li>
<li><figref idref="f0020">FIG. 21</figref> is a flowchart illustrating a method of decoding video data in accordance with techniques of this disclosure.</li>
</ul></p>
<heading id="h0005"><b>DETAILED DESCRIPTION</b></heading>
<p id="p0014" num="0014">In general, this disclosure describes techniques for intra prediction and intra prediction mode coding, which may be used in the context of advanced video codecs, such as extensions of the HEVC standard, or the next generation of video coding standards. For example, this disclosure describes techniques for deriving, selecting and/or signaling most-probable modes (MPMs) for intra prediction. Examples described in this disclosure also include techniques for intra prediction using an increased number of angular modes. The techniques for intra prediction using an increased number of angular modes may include techniques for applying an <i>N</i>-tap Intra interpolation filter, where N is larger than 2. The disclosure also describes techniques that may allow multiple Intra prediction directions per block, e.g. respective directions for sub-blocks of the block, which may not require additional signaling of multiple intra prediction modes.</p>
<p id="p0015" num="0015">Intra prediction and intra mode coding are techniques that may be used in the context of advanced video codecs, such as extensions of the High Efficiency Video Coding (HEVC) standard, or the next generation of video coding standards.<!-- EPO <DP n="7"> --></p>
<p id="p0016" num="0016">In intra mode coding in HEVC, for each intra prediction unit (PU), a selected intra prediction mode is signaled. To select the intra prediction mode, three intra modes are first identified, which are assumed to have higher probability to be actually selected, namely the Most Probable Modes (MPMs). In HEVC, there are 35 modes for the intra prediction of a luma block, including a planar intra prediction mode, a DC intra prediction mode and 33 different prediction directions associated with respectively angular intra prediction modes.</p>
<p id="p0017" num="0017">The 35 fixed prediction angles of the existing design of Intra prediction in HEVC may be inefficient to capture very flexible edge direction distributions. However, applying more prediction angles may result in undesired encoder complexity increase. For example, a direct extension to 65 prediction angles based on the HEVC reference software may require an approximately doubled number of SATD checks. Furthermore, the efficiency of current intra mode coding, using three MPMs, in HEVC can be limited because it may not accurately correspond to the actual probability distribution of all available intra prediction modes.</p>
<p id="p0018" num="0018">This disclosure describes techniques that may remediate one or more of these deficiencies in HEVC. For example, in accordance with some techniques of this disclosure, a video coder may derive more than three MPMs. In some such examples, the video coder may use context modeling for decoding one or more bins of an MPM index indicating which of the MPMs is a selected MPM for a current PU. In some examples where the video coder derives more than three MPMs, the video coder may define, among the MPMs, a representative intra prediction mode for the left neighboring column and using the representative intra prediction mode for the left neighboring column as the MPM for the left neighboring column and/or define a representative intra prediction mode for the above neighboring row and using the representative intra prediction mode for the above neighboring row as the MPM for the above neighboring row. Furthermore, in some examples where the video coder derives more than three MPMs, the video coder may select one or more additional angular MPMs based on similarity with an angular mode already among the MPMs. In this example, the similarity is determined based on at least one of intra prediction mode index differences or intra prediction angle differences. Furthermore, in some example techniques of this disclosure, a non-MPM index may be encoded in the bitstream as a code word shorter than ┌log<sub>2</sub> <i>N</i>┐ bits if the non-MPM index satisfies a criterion and is encoded as a fixed<!-- EPO <DP n="8"> --> length code with ┌log<sub>2</sub> <i>N</i>┐ bits otherwise, wherein there is a total of N available values of the non-MPM index.</p>
<p id="p0019" num="0019">In some examples of this disclosure where the video coder may use more than 33 angular intra prediction modes, the video coder may use an interpolation filter on neighboring reconstructed samples in which the interpolation has 1/32-pel accuracy. In some examples of this disclosure, the video coder may calculate a value of a respective sample by applying an N-tap intra interpolation filter to neighboring reconstructed samples to interpolate a value at the determined fractional position, wherein N is greater than 2.</p>
<p id="p0020" num="0020"><figref idref="f0001">FIG. 1</figref> is a block diagram illustrating an example video coding system 10 that may utilize the techniques of this disclosure. As used herein, the term "video coder" refers generically to both video encoders and video decoders. In this disclosure, the terms "video coding" or "coding" may refer generically to either video encoding or video decoding.</p>
<p id="p0021" num="0021">As shown in <figref idref="f0001">FIG. 1</figref>, video coding system 10 includes a source device 12 and a destination device 14. Source device 12 generates encoded video data. Accordingly, source device 12 may be referred to as a video encoding device or a video encoding apparatus. Destination device 14 may decode the encoded video data generated by source device 12. Accordingly, destination device 14 may be referred to as a video decoding device or a video decoding apparatus. Source device 12 and destination device 14 may be examples of video coding devices or video coding apparatuses. Source device 12 and destination device 14 may comprise a wide range of devices, including desktop computers, mobile computing devices, notebook (e.g., laptop) computers, tablet computers, set-top boxes, telephone handsets such as so-called "smart" phones, televisions, cameras, display devices, digital media players, video gaming consoles, in-car computers, or the like.</p>
<p id="p0022" num="0022">Destination device 14 may receive encoded video data from source device 12 via a channel 16. Channel 16 may comprise one or more media or devices capable of moving the encoded video data from source device 12 to destination device 14. In some examples, channel 16 may comprise one or more communication media that enable source device 12 to transmit encoded video data directly to destination device 14 in real-time. In this example, source device 12 may modulate the encoded video data according to a communication standard, such as a wireless communication protocol, and<!-- EPO <DP n="9"> --> may transmit the modulated video data to destination device 14. The one or more communication media may include wireless and/or wired communication media, such as a radio frequency (RF) spectrum or one or more physical transmission lines. The one or more communication media may form part of a packet-based network, such as a local area network, a wide-area network, or a global network (e.g., the internet). The one or more communication media may include routers, switches, base stations, or other equipment that facilitate communication from source device 12 to destination device 14.</p>
<p id="p0023" num="0023">In some examples, channel 16 may include a storage medium that stores encoded video data generated by source device 12. In this example, destination device 14 may access the storage medium, e.g., via disk access or card access. The storage medium may include a variety of locally-accessed data storage media such as Blu-ray discs, DVDs, CD-ROMs, flash memory, or other suitable digital storage media for storing encoded video data.</p>
<p id="p0024" num="0024">In some examples, channel 16 may include a file server or another intermediate storage device that stores encoded video data generated by source device 12. In this example, destination device 14 may access encoded video data stored at the file server or other intermediate storage device via streaming or download. The file server may be a type of server capable of storing encoded video data and transmitting the encoded video data to destination device 14. Example file servers include web servers (e.g., for a website), file transfer protocol (FTP) servers, network attached storage (NAS) devices, and local disk drives.</p>
<p id="p0025" num="0025">Destination device 14 may access the encoded video data through a standard data connection, such as an internet connection. Example types of data connections may include wireless channels (e.g., Wi-Fi connections), wired connections (e.g., digital subscriber line (DSL), cable modem, etc.), or combinations of both that are suitable for accessing encoded video data stored on a file server. The transmission of encoded video data from the file server may be a streaming transmission, a download transmission, or a combination of both.</p>
<p id="p0026" num="0026">The techniques of this disclosure are not limited to wireless applications or settings. The techniques may be applied to video coding in support of a variety of multimedia applications, such as over-the-air television broadcasts, cable television transmissions, satellite television transmissions, streaming video transmissions, e.g., via the internet, encoding of video data for storage on a data storage medium, decoding of<!-- EPO <DP n="10"> --> video data stored on a data storage medium, or other applications. In some examples, video coding system 10 may be configured to support one-way or two-way video transmission to support applications such as video streaming, video playback, video broadcasting, and/or video telephony.</p>
<p id="p0027" num="0027"><figref idref="f0001">FIG. 1</figref> is merely an example and the techniques of this disclosure may apply to video coding settings (e.g., video encoding or video decoding) that do not necessarily include any data communication between the encoding and decoding devices. In other examples, data is retrieved from a local memory, streamed over a network, or the like. A video encoding device may encode and store data to memory, and/or a video decoding device may retrieve and decode data from memory. In many examples, the encoding and decoding is performed by devices that do not communicate with one another, but simply encode data to memory and/or retrieve and decode data from memory.</p>
<p id="p0028" num="0028">In the example of <figref idref="f0001">FIG. 1</figref>, source device 12 includes a video source 18, a video encoder 20, and an output interface 22. In some examples, output interface 22 may include a modulator/demodulator (modem) and/or a transmitter. Video source 18 may include a video capture device, e.g., a video camera, a video archive containing previously-captured video data, a video feed interface to receive video data from a video content provider, and/or a computer graphics system for generating video data, or a combination of such sources of video data.</p>
<p id="p0029" num="0029">Video encoder 20 may encode video data from video source 18. In some examples, source device 12 directly transmits the encoded video data to destination device 14 via output interface 22. In other examples, the encoded video data may also be stored onto a storage medium or a file server for later access by destination device 14 for decoding and/or playback.</p>
<p id="p0030" num="0030">In the example of <figref idref="f0001">FIG. 1</figref>, destination device 14 includes an input interface 28, a video decoder 30, and a display device 32. In some examples, input interface 28 includes a receiver and/or a modem. Input interface 28 may receive encoded video data over channel 16. Video decoder 30 may decode encoded video data. Display device 32 may display the decoded video data. Display device 32 may be integrated with or may be external to destination device 14. Display device 32 may comprise a variety of display devices, such as a liquid crystal display (LCD), a plasma display, an organic light emitting diode (OLED) display, or another type of display device.<!-- EPO <DP n="11"> --></p>
<p id="p0031" num="0031">Video encoder 20 and video decoder 30 each may be implemented as any of a variety of suitable circuitry, such as one or more microprocessors, digital signal processors (DSPs), application-specific integrated circuits (ASICs), field-programmable gate arrays (FPGAs), discrete logic, hardware, or any combinations thereof. If the techniques are implemented partially in software, a device may store instructions for the software in a suitable, non-transitory computer-readable storage medium and may execute the instructions in hardware using one or more processors to perform the techniques of this disclosure. Any of the foregoing (including hardware, software, a combination of hardware and software, etc.) may be considered to be one or more processors. Each of video encoder 20 and video decoder 30 may be included in one or more encoders or decoders, either of which may be integrated as part of a combined encoder/decoder (CODEC) in a respective device. An apparatus including video encoder 20 and/or video decoder 30 may comprise an integrated circuit, a microprocessor, and/or a wireless communication device, such as a cellular telephone.</p>
<p id="p0032" num="0032">Video source 18 of source device 12 may include a video capture device, such as a video camera, a video archive containing previously captured video, and/or a video feed interface to receive video from a video content provider. As a further alternative, video source 18 may generate computer graphics-based data as the source video, or a combination of live video, archived video, and computer-generated video. In some cases, if video source 18 is a video camera, source device 12 and destination device 14 may form so-called camera phones or video phones. As mentioned above, however, the techniques described in this disclosure may be applicable to video coding in general, and may be applied to wireless and/or wired applications. In each case, the captured, pre-captured, or computer-generated video may be encoded by video encoder 20. The encoded video information may then be output by output interface 22 onto the channel 16.</p>
<p id="p0033" num="0033">Many of the techniques described in this disclosure can be performed by both video encoder 20 and video decoder 30. Therefore, for ease of explanation, the techniques may be described with respect to a video coder, which may be a video encoder and/or a video decoder, such as video encoder 20 and video decoder 30. This disclosure may generally refer to video encoder 20 "signaling" certain information to another device, such as video decoder 30. The term "signaling" may generally refer to the communication of syntax elements and/or other data used to decode the compressed<!-- EPO <DP n="12"> --> video data. Such communication may occur in real- or near-real-time. Alternately, such communication may occur over a span of time, such as might occur when storing syntax elements to a computer-readable storage medium in an encoded bitstream at the time of encoding, which then may be retrieved by a decoding device at any time after being stored to this medium.</p>
<p id="p0034" num="0034">Video coding standards include ITU-T H.261, ISO/IEC MPEG-1 Visual, ITU-T H.262 or ISO/IEC MPEG-2 Visual, ITU-T H.263, ISO/IEC MPEG-4 Visual and ITU-T H.264 (also known as ISO/IEC MPEG-4 AVC), including its Scalable Video Coding (SVC) and Multi-View Video Coding (MVC) extensions. In addition, High Efficiency Video Coding (HEVC) has recently been developed by the Joint Collaboration Team on Video Coding (JCT-VC) of ITU-T Video Coding Experts Group (VCEG) and ISO/IEC Motion Picture Experts Group (MPEG). A draft of the HEVC specification is available from: http://phenix.int-evry.fr/jct/doc_end_user/documents/14_Vienna/wg11/JCTVC-N1003-v1.zip, hereinafter, "JCTVC-N1003."</p>
<p id="p0035" num="0035">In HEVC and other video coding specifications, a video sequence typically includes a series of pictures. Pictures may also be referred to as "frames." A picture may include three sample arrays, denoted S<sub>L</sub>, S<sub>Cb</sub>, and S<sub>Cr</sub>. S<sub>L</sub> is a two-dimensional array (i.e., a block) of luma samples. S<sub>Cb</sub> is a two-dimensional array of Cb chrominance samples. S<sub>Cr</sub> is a two-dimensional array of Cr chrominance samples. Chrominance samples may also be referred to herein as "chroma" samples. In other instances, a picture may be monochrome and may only include an array of luma samples.</p>
<p id="p0036" num="0036">To generate an encoded representation of a picture, video encoder 20 may generate a set of coding tree units (CTUs). Each of the CTUs may comprise a coding tree block of luma samples, two corresponding coding tree blocks of chroma samples, and syntax structures used to code the samples of the coding tree blocks. In monochrome pictures or pictures having three separate color planes, a CTU may comprise a single coding tree block and syntax structures used to code the samples of the coding tree block. A coding tree block may be an NxN block of samples. A CTU may also be referred to as a "tree block" or a "largest coding unit" (LCU). The CTUs of HEVC may be broadly analogous to the macroblocks of other standards, such as H.264/AVC. However, a CTU is not necessarily limited to a particular size and may include one or more coding units (CUs). A slice may include an integer number of CTUs ordered consecutively in a raster scan order. For instance, a slice may be an<!-- EPO <DP n="13"> --> integer number of CTUs contained in one independent slice segment and all subsequent dependent slice segments, if any, that precede the next independent slice segment, if any, within the same access unit.</p>
<p id="p0037" num="0037">To generate a coded CTU, video encoder 20 may recursively perform quad-tree partitioning on the coding tree blocks of a CTU to divide the coding tree blocks into coding blocks, hence the name "coding tree units." A coding block is an NxN block of samples. A CU may comprise a coding block of luma samples and two corresponding coding blocks of chroma samples of a picture that has a luma sample array, a Cb sample array, and a Cr sample array, and syntax structures used to code the samples of the coding blocks. In monochrome pictures or pictures having three separate color planes, a CU may comprise a single coding block and syntax structures used to code the samples of the coding block.</p>
<p id="p0038" num="0038">Video encoder 20 may partition a coding block of a CU into one or more prediction blocks. A prediction block is a rectangular (i.e., square or non-square) block of samples on which the same prediction is applied. A prediction unit (PU) of a CU may comprise a prediction block of luma samples, two corresponding prediction blocks of chroma samples, and syntax structures used to predict the prediction blocks. In monochrome pictures or pictures having three separate color planes, a PU may comprise a single prediction block and syntax structures used to predict the prediction block. Video encoder 20 may generate predictive luma, Cb, and Cr blocks for luma, Cb, and Cr prediction blocks of each PU of the CU.</p>
<p id="p0039" num="0039">Video encoder 20 may use intra prediction or inter prediction to generate the predictive blocks for a PU. If video encoder 20 uses intra prediction to generate the predictive blocks of a PU, video encoder 20 may generate the predictive blocks of the PU based on decoded samples of the picture associated with the PU.</p>
<p id="p0040" num="0040">If video encoder 20 uses inter prediction to generate the predictive blocks of a PU, video encoder 20 may generate the predictive blocks of the PU based on decoded samples of one or more pictures other than the picture associated with the PU. Inter prediction may be uni-directional inter prediction (i.e., uni-prediction) or bi-directional inter prediction (i.e., bi-prediction). To perform uni-prediction or bi-prediction, video encoder 20 may generate a first reference picture list (RefPicListO) and a second reference picture list (RefPicList1) for a current slice. Each of the reference picture lists may include one or more reference pictures. When using uni-prediction, video encoder<!-- EPO <DP n="14"> --> 20 may search the reference pictures in either or both RefPicListO and RefPicList1 to determine a reference location within a reference picture. Furthermore, when using uni-prediction, video encoder 20 may generate, based at least in part on samples corresponding to the reference location, the predictive sample blocks for the PU. Moreover, when using uni-prediction, video encoder 20 may generate a single motion vector that indicates a spatial displacement between a prediction block of the PU and the reference location. To indicate the spatial displacement between a prediction block of the PU and the reference location, a motion vector may include a horizontal component specifying a horizontal displacement between the prediction block of the PU and the reference location and may include a vertical component specifying a vertical displacement between the prediction block of the PU and the reference location.</p>
<p id="p0041" num="0041">When using bi-prediction to encode a PU, video encoder 20 may determine a first reference location in a reference picture in RefPicListO and a second reference location in a reference picture in RefPicList1. Video encoder 20 may then generate, based at least in part on samples corresponding to the first and second reference locations, the predictive blocks for the PU. Moreover, when using bi-prediction to encode the PU, video encoder 20 may generate a first motion vector indicating a spatial displacement between a sample block of the PU and the first reference location and a second motion vector indicating a spatial displacement between the prediction block of the PU and the second reference location.</p>
<p id="p0042" num="0042">Typically, a reference picture list construction for the first or the second reference picture list (e.g., RefPicListO or RefPicList1) of a B picture includes two steps: reference picture list initialization and reference picture list reordering (modification). The reference picture list initialization is an explicit mechanism that puts the reference pictures in the reference picture memory (also known as decoded picture buffer) into a list based on the order of POC (Picture Order Count, aligned with display order of a picture) values. The reference picture list reordering mechanism can modify the position of a picture that was put in the list during the reference picture list initialization to any new position, or put any reference picture in the reference picture memory in any position even the picture doesn't belong to the initialized list. Some pictures after the reference picture list reordering (modification) may be put in a very further position in the list. However, if a position of a picture exceeds the number of active reference pictures of the list, the picture is not considered as an entry of the final<!-- EPO <DP n="15"> --> reference picture list. The number of active reference pictures may be signaled in the slice header for each list. After reference picture lists are constructed (namely RefPicListO and RefPicList1, if available), a reference index to a reference picture list can be used to identify any reference picture included in the reference picture list.</p>
<p id="p0043" num="0043">Video encoder 20 may encode certain blocks of video data using intra prediction mode encoding, and provide information indicating a selected intra prediction mode used to encode the block. Video encoder 20 may intra prediction encode blocks of any type of frame or slice (e.g., I-frames or I-slices, in addition to P-frames or P-slices and B-frames or B-slices) using an intra prediction mode. When video encoder 20 determines that a block should be intra prediction mode encoded, video encoder 20 may perform a rate-distortion analysis to select a most appropriate intra prediction mode. Intra prediction modes may also be referred to as "intra modes." For example, video encoder 20 may calculate rate-distortion values for one or more intra prediction modes, and select one of the modes having acceptable rate-distortion characteristics.</p>
<p id="p0044" num="0044">Video encoder 20 may, in some examples, be configured to begin analysis for selection of an intra prediction mode with the most probable mode, based on the context. When the most probable mode achieves suitable rate-distortion characteristics, in some examples, video encoder 20 may select the most probable mode. In other examples, video encoder 20 need not begin the selection process with the most probable mode.</p>
<p id="p0045" num="0045">After video encoder 20 generates predictive block (e.g., a predictive luma, Cb, and Cr block) for one or more PUs of a CU, video encoder 20 may generate a luma residual block for the CU. Each sample in a residual block may indicate a difference between a sample in a predictive block and a corresponding sample in an original coding block. Each sample in the luma residual block of the CU indicates a difference between a luma sample in one of the predictive luma blocks of the CU and a corresponding sample in the original luma coding block of the CU. In addition, video encoder 20 may generate a Cb residual block for the CU. Each sample in the CU's Cb residual block may indicate a difference between a Cb sample in one of the CU's predictive Cb blocks and a corresponding sample in the CU's original Cb coding block. Video encoder 20 may also generate a Cr residual block for the CU. Each sample in the CU's Cr residual block may indicate a difference between a Cr sample in one of the<!-- EPO <DP n="16"> --> CU's predictive Cr blocks and a corresponding sample in the CU's original Cr coding block.</p>
<p id="p0046" num="0046">Furthermore, video encoder 20 may use quad-tree partitioning to decompose the luma, Cb, and Cr residual blocks of a CU into one or more luma, Cb, and Cr transform blocks. A transform block is a rectangular (e.g., square or non-square) block of samples on which the same transform is applied. A transform unit (TU) of a CU may comprise a transform block of luma samples, two corresponding transform blocks of chroma samples, and syntax structures used to transform the transform block samples. Thus, each TU of a CU may be associated with a luma transform block, a Cb transform block, and a Cr transform block. The luma transform block associated with the TU may be a sub-block of the CU's luma residual block. The Cb transform block may be a sub-block of the CU's Cb residual block. The Cr transform block may be a sub-block of the CU's Cr residual block. In monochrome pictures or pictures having three separate color planes, a TU may comprise a single transform block and syntax structures used to transform the samples of the transform block.</p>
<p id="p0047" num="0047">Video encoder 20 may apply one or more transforms to a luma transform block of a TU to generate a luma coefficient block for the TU. A coefficient block may be a two-dimensional array of transform coefficients. A transform coefficient may be a scalar quantity. Video encoder 20 may apply one or more transforms to a Cb transform block of a TU to generate a Cb coefficient block for the TU. Video encoder 20 may apply one or more transforms to a Cr transform block of a TU to generate a Cr coefficient block for the TU.</p>
<p id="p0048" num="0048">After generating a coefficient block (e.g., a luma coefficient block, a Cb coefficient block or a Cr coefficient block), video encoder 20 may quantize the coefficient block. Quantization generally refers to a process in which transform coefficients are quantized to possibly reduce the amount of data used to represent the transform coefficients, providing further compression.</p>
<p id="p0049" num="0049">Thus, following intra-predictive or inter-predictive coding to produce predictive data and residual data, and following any transforms (such as the 4x4 or 8x8 integer transform used in H.264/AVC or a discrete cosine transform DCT) to produce transform coefficients, quantization of transform coefficients may be performed. Quantization generally refers to a process in which transform coefficients are quantized to possibly reduce the amount of data used to represent the coefficients. The quantization process<!-- EPO <DP n="17"> --> may reduce the bit depth associated with some or all of the coefficients. For example, an n-bit value may be rounded down to an m-bit value during quantization, where n is greater than <i>m.</i></p>
<p id="p0050" num="0050">After video encoder 20 quantizes a coefficient block, video encoder 20 may entropy encode syntax elements indicating the quantized transform coefficients. For example, video encoder 20 may perform Context-Adaptive Binary Arithmetic Coding (CABAC) on the syntax elements indicating the quantized transform coefficients. For instance, following quantization, entropy coding of the quantized data may be performed, e.g., according to content adaptive variable length coding (CAVLC), CABAC, or another entropy coding methodology. A processing unit configured for entropy coding, or another processing unit, may perform other processing functions, such as zero run length coding of quantized coefficients and/or generation of syntax information such as coded block pattern (CBP) values, macroblock type, coding mode, maximum macroblock size for a coded unit (such as a frame, slice, macroblock, or sequence), or the like.</p>
<p id="p0051" num="0051">Video encoder 20 may also be configured to determine an encoding context for a block. The context may be determined based on various characteristics of the block such as, for example, a size of the block, which may be determined in terms of pixel dimensions, prediction unit (PU) type such as, in the example of HEVC, 2Nx2N, Nx2N, 2NxN, NxN, short-distance intra prediction (SDIP) types such as 2NxN/2, N/2x2N, 2Nx1, 1x2N, a macroblock type in the example of H.264, a coding unit (CU) depth for the block, or other measurements of size for a block of video data. In some examples, video encoder 20 may determine the context based on how any or all of intra prediction modes for an above-neighboring block, a left-neighboring block, an above-left neighboring block, an above-right neighboring block, or other neighboring blocks. In some examples, video encoder 20 determines the context based on both intra prediction modes for one or more blocks as well as size information for the current block being encoded.</p>
<p id="p0052" num="0052">Video encoder 20 may output a bitstream that includes a sequence of bits that forms a representation of coded pictures and associated data. The bitstream may comprise a sequence of network abstraction layer (NAL) units. A NAL unit is a syntax structure containing an indication of the type of data in the NAL unit and bytes containing that data in the form of a raw byte sequence payload (RBSP) interspersed as<!-- EPO <DP n="18"> --> necessary with emulation prevention bits. Each of the NAL units includes a NAL unit header and encapsulates a RBSP. The NAL unit header may include a syntax element that indicates a NAL unit type code. The NAL unit type code specified by the NAL unit header of a NAL unit indicates the type of the NAL unit. A RBSP may be a syntax structure containing an integer number of bytes that is encapsulated within a NAL unit. In some instances, an RBSP includes zero bits.</p>
<p id="p0053" num="0053">Different types of NAL units may encapsulate different types of RBSPs. For example, a first type of NAL unit may encapsulate an RBSP for a picture parameter set (PPS), a second type of NAL unit may encapsulate an RBSP for a coded slice, a third type of NAL unit may encapsulate an RBSP for SEI messages, and so on. NAL units that encapsulate RBSPs for video coding data (as opposed to RBSPs for parameter sets and SEI messages) may be referred to as video coding layer (VCL) NAL units. NAL units that contain parameter sets (e.g., video parameter sets (VPSs), sequence parameter sets (SPSs), picture parameter sets (PPSs), etc.) may be referred to as parameter set NAL units.</p>
<p id="p0054" num="0054">Video decoder 30 may receive a bitstream generated by video encoder 20. In addition, video decoder 30 may parse the bitstream to obtain syntax elements from the bitstream. Video decoder 30 may reconstruct the pictures of the video data based at least in part on the syntax elements obtained from the bitstream. The process to reconstruct the video data may be generally reciprocal to the process performed by video encoder 20. For instance, video decoder 30 may use motion vectors of PUs to determine predictive blocks for the PUs of a current CU. In addition, video decoder 30 may inverse quantize coefficient blocks associated with TUs of the current CU. Video decoder 30 may perform inverse transforms on the coefficient blocks to reconstruct transform blocks associated with the TUs of the current CU. Video decoder 30 may reconstruct the coding blocks of the current CU by adding the samples of the predictive blocks for PUs of the current CU to corresponding samples of the transform blocks of the TUs of the current CU. By reconstructing the coding blocks for each CU of a picture, video decoder 30 may reconstruct the picture.</p>
<p id="p0055" num="0055">Thus, in some examples of this disclosure, video decoder 30 may ultimately receive encoded video data, e.g., from input interface 28. In accordance with some techniques of this disclosure, video decoder 30 may receive a codeword or other syntax representative of an intra prediction mode used to encode a block of video data. Video<!-- EPO <DP n="19"> --> decoder 30 may be configured to determine a coding context for the block in a manner substantially similar to video encoder 20.</p>
<p id="p0056" num="0056">As mentioned above, particular NAL units of the bitstream may include VPSs, SPS, and PPSs. In some examples, a VPS is a syntax structure comprising syntax elements that apply to zero or more entire coded video sequences (CVSs). In some examples, an SPS is a syntax structure containing syntax elements that apply to zero or more entire CVSs. An SPS may include a syntax element that identifies a VPS that is active when the SPS is active. Thus, the syntax elements of a VPS may be more generally applicable than the syntax elements of a SPS. In some examples, a PPS is a syntax structure containing syntax elements that apply to zero or more entire coded pictures as determined by a syntax element found in each slice segment header.</p>
<p id="p0057" num="0057">A parameter set (e.g., a VPS, SPS, PPS, etc.) may contain an identification that is referenced, directly or indirectly, from a slice header of a slice. In some examples, a slice header is the slice segment header of the independent slice segment that is a current slice segment or the most recent independent slice segment that precedes a current dependent slice segment in decoding order. In such examples, a slice segment header is an integer number of coding tree units ordered consecutively in the tile scan and contained in a single NAL unit. The referencing process is known as "activation." Thus, when video decoder 30 is decoding a particular slice, a parameter set referenced, directly or indirectly, by a syntax element in a slice header of the particular slice is said to be "activated." Depending on the parameter set type, the activation may occur on a per picture basis or a per sequence basis. For example, a slice header of a slice may include a syntax element that identifies a PPS. Thus, when a video coder codes the slice, the PPS may be activated. Furthermore, the PPS may include a syntax element that identifies a SPS. Thus, when a PPS that identifies the SPS is activated, the SPS may be activated. The SPS may include a syntax element that identifies a VPS. Thus, when a SPS that identifies the VPS is activated, the VPS is activated.</p>
<p id="p0058" num="0058">As mentioned briefly above, video encoder 20 may encode syntax elements using CABAC encoding. To apply CABAC encoding to a syntax element, video encoder 20 may binarize the syntax element to form a series of one or more bits, which are referred to as "bins." In addition, video encoder 20 may identify a coding context. The coding context may identify probabilities of coding bins having particular values. For instance, a coding context may indicate a 0.7 probability of coding a 0-valued bin<!-- EPO <DP n="20"> --> and a 0.3 probability of coding a 1-valued bin. After identifying the coding context, video encoder 20 may divide an interval into a lower sub-interval and an upper sub-interval. One of the sub-intervals may be associated with the value 0 and the other sub-interval may be associated with the value 1. The widths of the sub-intervals may be proportional to the probabilities indicated for the associated values by the identified coding context. If a bin of the syntax element has the value associated with the lower sub-interval, the encoded value may be equal to the lower boundary of the lower sub-interval. If the same bin of the syntax element has the value associated with the upper sub-interval, the encoded value may be equal to the lower boundary of the upper sub-interval. To encode the next bin of the syntax element, video encoder 20 may repeat these steps with the interval being the sub-interval associated with the value of the encoded bit. When video encoder 20 repeats these steps for the next bin, video encoder 20 may use modified probabilities based on the probabilities indicated by the identified coding context and the actual values of bins encoded. In some examples, when video encoder 20 repeats these steps for the next bin, video encoder 20 may select another coding context.</p>
<p id="p0059" num="0059">When video decoder 30 performs CABAC decoding on a syntax element, video decoder 30 may identify a coding context. Video decoder 30 may then divide an interval into a lower sub-interval and an upper sub-interval. One of the sub-intervals may be associated with the value 0 and the other sub-interval may be associated with the value 1. The widths of the sub-intervals may be proportional to the probabilities indicated for the associated values by the identified coding context. If the encoded value is within the lower sub-interval, video decoder 30 may decode a bin having the value associated with the lower sub-interval. If the encoded value is within the upper sub-interval, video decoder 30 may decode a bin having the value associated with the upper sub-interval. To decode a next bin of the syntax element, video decoder 30 may repeat these steps with the interval being the sub-interval that contains the encoded value. When video decoder 30 repeats these steps for the next bin, video decoder 30 may use modified probabilities based on the probabilities indicated by the identified coding context and the decoded bins. Video decoder 30 may then de-binarize the bins to recover the syntax element.</p>
<p id="p0060" num="0060">Rather than performing regular CABAC encoding on all syntax elements, video encoder 20 may encode some bins using bypass CABAC coding. It may be<!-- EPO <DP n="21"> --> computationally less expensive to perform bypass CABAC coding on a bin than to perform regular CABAC coding on the bin. Furthermore, performing bypass CABAC coding may allow for a higher degree of parallelization and throughput. Bins encoded using bypass CABAC coding may be referred to as "bypass bins." Grouping bypass bins together may increase the throughput of video encoder 20 and video decoder 30. The bypass CABAC coding engine may be able to code several bins in a single cycle, whereas the regular CABAC coding engine may be able to code only a single bin in a cycle. The bypass CABAC coding engine may be simpler because the bypass CABAC coding engine does not select contexts and may assume a probability of ½ for both symbols (0 and 1). Consequently, in bypass CABAC coding, the intervals are split directly in half.</p>
<p id="p0061" num="0061"><figref idref="f0002">FIG. 2</figref> is a conceptual diagram illustrating an example of intra prediction of a block of video data. For intra prediction, a block of video data (e.g., a PU) is predicted using reconstructed image samples that are spatially neighboring. A typical example of the intra prediction for an image block 40, e.g., a 16x16 image block, is shown in <figref idref="f0002">FIG. 2</figref>. With intra prediction, image block 40 is predicted by the above and left neighboring reconstructed samples (reference samples) along a selected prediction direction (as indicated by arrow 42).</p>
<p id="p0062" num="0062"><figref idref="f0003">FIG. 3</figref> is a conceptual diagram illustrating an example of intra prediction modes and corresponding mode indexes. In HEVC, there are 35 modes for the intra prediction of a luma block, including a planar mode (i.e., a planar intra prediction mode), a DC mode and 33 angular modes (i.e., angular intra prediction modes), as indicated in <figref idref="f0003">FIG 3</figref>. The 35 modes of the intra prediction, as defined in HEVC, are indexed as below table
<tables id="tabl0001" num="0001">
<table frame="all">
<title><b>Table 1 - Specification of intra prediction mode and associated names</b></title>
<tgroup cols="2">
<colspec colnum="1" colname="col1" colwidth="47mm"/>
<colspec colnum="2" colname="col2" colwidth="68mm"/>
<thead>
<row>
<entry align="center" valign="top"><b>Intra prediction mode</b></entry>
<entry align="center" valign="top"><b>Associated name</b></entry></row></thead>
<tbody>
<row>
<entry align="center">0</entry>
<entry>INTRA_PLANAR</entry></row>
<row>
<entry align="center">1</entry>
<entry>INTRA_DC</entry></row>
<row>
<entry align="center">2..34</entry>
<entry>INTRA_ANGULAR2..INTRA_ANGULAR34</entry></row></tbody></tgroup>
</table>
</tables><!-- EPO <DP n="22"> --></p>
<p id="p0063" num="0063"><figref idref="f0004">FIG. 4</figref> is a conceptual diagram illustrating an example technique for generating a prediction sample for a block of video data according to a planar intra prediction mode. Planar mode is typically the most frequently used Intra prediction mode. To perform a planar prediction for an NxN block, for each sample p<sub>xy</sub> located at (x, y), as illustrated in <figref idref="f0004">FIG. 4</figref>, the prediction value is calculated using four specific neighboring reconstructed samples, i.e., reference samples, with a bilinear filter. The four reference samples include a top-right reconstructed sample TR (50), a bottom-left reconstructed sample BL (52), and the two reconstructed samples (54, 56) located at the same column (r<sub>x,-1</sub>) and row (r<sub>-1,y</sub>) of the current sample, as illustrated in <figref idref="f0004">FIG. 4</figref>. The planar mode can be formulated as: p<sub>xy</sub> = (<i>N-x-</i>1)·<i>L</i> + (<i>N-y-1</i>)·<i>T</i> + <i>x</i>·TR + <i>y</i>·BL. In this formula, <i>N</i> is the height and width of the block.</p>
<p id="p0064" num="0064">For a DC mode, the prediction block is simply filled with the average value of the neighboring reconstructed samples. For instance, to generate a predictive block for a PU using a DC intra prediction mode, the video coder may set each sample of the predictive block for the PU equal to an average value of neighboring reconstructed samples. Generally, both the planar and DC intra prediction modes are applied for modeling smoothly varying and constant image regions.</p>
<p id="p0065" num="0065">HEVC specifies 33 different prediction directions for its angular intra prediction modes. For each given angular intra prediction, the intra prediction direction can be identified, for example, according to <figref idref="f0003">FIG. 3</figref>. In the example of <figref idref="f0003">FIG. 3</figref>, intra prediction mode 10 corresponds to a pure horizontal prediction direction, and intra prediction mode 26 corresponds to a pure vertical prediction direction.</p>
<p id="p0066" num="0066">Given a specific intra prediction direction, for each sample of the prediction block, its coordinate (x, y) is first projected to the row/column of neighboring reconstructed samples along the prediction direction, as shown in an example in <figref idref="f0003">FIG. 3</figref>. Suppose, (x, y) is projected to the fractional position α between two neighboring reconstructed samples L and R, then the prediction value for (x, y) is calculated using a two-tap bi-linear interpolation filter, formulated as follows: p<sub>xy</sub> = (1- α)·L + α·R. To avoid floating point operations, in HEVC, the preceding calculation is actually approximated using integer arithmetic as: p<sub>xy</sub> = ((32-a)·L + a·R + 16)&gt;&gt;5, where a is an integer equal to 32*α.</p>
<p id="p0067" num="0067">For intra mode coding in HEVC, for each intra PU, a selected intra prediction mode is signaled. To signal the selected intra prediction mode, three intra prediction<!-- EPO <DP n="23"> --> modes are first identified which are assumed to have higher probability to be actually selected, namely the Most Probable Modes (MPM). In HEVC, the MPMs, labeled candModeList[x], x=0, 1, 2, are derived as follows.</p>
<p id="p0068" num="0068">Firstly, a left neighboring mode (candIntraPredModeA) and an above neighboring mode (candIntraPredModeB) are derived as follows according to subclause 8.4.2 of JCTVC-N1003:<br/>
Input to this process is a luma location (xPb, yPb) specifying the top-left sample of the current luma prediction block relative to the top-left luma sample of the current picture.
<ol id="ol0001" ol-style="">
<li>1. The neighbouring locations (xNbA, yNbA) and (xNbB, yNbB) are set equal to (xPb - 1, yPb) and (xPb, yPb - 1), respectively.</li>
<li>2. For X being replaced by either A or B, the variables candIntraPredModeX are derived as follows:
<ul id="ul0002" list-style="dash">
<li>The availability derivation process for a block in z-scan order as specified in subclause 6.4.1 is invoked with the location (xCurr, yCurr) set equal to (xPb, yPb) and the neighbouring location (xNbY, yNbY) set equal to (xNbX, yNbX) as inputs, and the output is assigned to availableX.</li>
<li>The candidate intra prediction mode candIntraPredModeX is derived as follows:
<ul id="ul0003" list-style="dash">
<li>If availableX is equal to FALSE, candIntraPredModeX is set equal to INTRA_DC.</li>
<li>Otherwise, if CuPredMode[xNbX][yNbX] is not equal to MODE_INTRA or pcm_flag[xNbX][yNbX] is equal to 1, candIntraPredModeX is set equal to INTRA_DC,</li>
<li>Otherwise, if X is equal to B and yPb - 1 is less than ((yPb &gt;&gt; CtbLog2SizeY) « CtbLog2SizeY), candIntraPredModeB is set equal to INTRA_DC.</li>
<li>Otherwise, candIntraPredModeX is set equal to IntraPredModeY[xNbX][yNbX].</li>
</ul></li>
</ul></li>
</ol><!-- EPO <DP n="24"> --></p>
<p id="p0069" num="0069">Thus, if the neighboring sample left of the top left sample of the luma prediction block of a current PU is not available, if the neighboring sample left of the top left sample of the luma prediction block of the current PU is not predicted using intra prediction, or if the neighboring sample left of the top left sample of the luma prediction block of the current PU is encoded using pulse code modulation (PCM), candIntraPredModeA is set to the DC intra prediction mode. Otherwise, candIntraPredModeA is set to the intra prediction mode of a PU whose prediction block contains the neighboring sample left of the top left sample of the luma prediction block of the current PU. Similarly, if the neighboring sample above the top left sample of the luma prediction block of a PU is not available, if the neighboring sample above the top left sample of the luma prediction block of the current PU is not predicted using intra prediction, if the neighboring sample above the top left sample of the luma prediction block of the current PU is encoded using PCM, or if the neighboring sample above the top left sample of the luma prediction block of the current PU is in a different coding tree block from the current PU, candIntraPredModeB is set to the DC intra prediction mode. Otherwise, candIntraPredModeB is set to the luma intra prediction mode of a PU whose prediction block contains the neighboring sample above the top left sample of the luma prediction block of the current PU (i.e., IntraPredModeY[xNbX][yNbX].</p>
<p id="p0070" num="0070">Then, in subclause 8.4.2 of JCTVC-N1003, using the derived left neighboring mode (candIntraPredModeA) and above neighboring mode (candIntraPredModeB), the three MPMs are derived as follows:<br/>
3. The candModeList[x] with x = 0..2 is derived as follows:
<ul id="ul0004" list-style="dash" compact="compact">
<li>If candIntraPredModeB is equal to candIntraPredModeA, the following applies:
<ul id="ul0005" list-style="dash" compact="compact">
<li>If candIntraPredModeA is less than 2 (i.e. equal to INTRA_PLANAR or INTRA_DC), candModeList[x] with x = 0..2 is derived as follows: <maths id="math0001" num="(8-15)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>0</mn></mfenced><mo>=</mo><mi>INTRA</mi><mo>_</mo><mi>PLANAR</mi></math><img id="ib0001" file="imgb0001.tif" wi="116" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0002" num="(8-16)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>1</mn></mfenced><mo>=</mo><mi>INTRA</mi><mo>_</mo><mi>DC</mi></math><img id="ib0002" file="imgb0002.tif" wi="116" he="5" img-content="math" img-format="tif"/></maths><!-- EPO <DP n="25"> --> <maths id="math0003" num="(8-17)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>2</mn></mfenced><mo>=</mo><mi>INTRA</mi><mo>_</mo><mi>ANGULAR</mi><mn>26</mn></math><img id="ib0003" file="imgb0003.tif" wi="116" he="5" img-content="math" img-format="tif"/></maths></li>
<li>Otherwise, candModeList[x] with x = 0..2 is derived as follows: <maths id="math0004" num="(8-18)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>0</mn></mfenced><mo>=</mo><mi>candIntraPredModeA</mi></math><img id="ib0004" file="imgb0004.tif" wi="116" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0005" num="(8-19)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>1</mn></mfenced><mo>=</mo><mn>2</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi>candIntraPredModeA</mi><mo>+</mo><mn>29</mn></mfenced><mi>%</mi><mspace width="1ex"/><mn>32</mn></mfenced></math><img id="ib0005" file="imgb0005.tif" wi="116" he="13" img-content="math" img-format="tif"/></maths> <maths id="math0006" num="(8-20)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>2</mn></mfenced><mo>=</mo><mn>2</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi>candIntraPredModeA</mi><mo>−</mo><mn>2</mn><mo>+</mo><mn>1</mn></mfenced><mi>%</mi><mspace width="1ex"/><mn>32</mn></mfenced></math><img id="ib0006" file="imgb0006.tif" wi="116" he="12" img-content="math" img-format="tif"/></maths></li>
</ul></li>
<li>Otherwise (candIntraPredModeB is not equal to candIntraPredModeA), the following applies:
<ul id="ul0006" list-style="dash">
<li>candModeList[0] and candModeList[1] are derived as follows: <maths id="math0007" num="(8-21)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>0</mn></mfenced><mo>=</mo><mi>candIntraPredModeA</mi></math><img id="ib0007" file="imgb0007.tif" wi="116" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0008" num="(8-22)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>1</mn></mfenced><mo>=</mo><mi>candIntraPredModeB</mi></math><img id="ib0008" file="imgb0008.tif" wi="116" he="5" img-content="math" img-format="tif"/></maths></li>
<li>If neither of candModeList[0] and candModeList[1] is equal to INTRA_PLANAR, candModeList[2] is set equal to INTRA_PLANAR,</li>
<li>Otherwise, if neither of candModeList[0] and candModeList[1] is equal to INTRA_DC, candModeList[2] is set equal to INTRA_DC,</li>
<li>Otherwise, candModeList[2] is set equal to INTRA_ANGULAR26.</li>
</ul></li>
</ul></p>
<p id="p0071" num="0071">After the three MPMs are decided, in subclause 8.4.2 of JCTVC-N1003, for each PU, a one-bit flag prev_intra_luma_pred_flag[xPb][yPb] is first signaled to indicate whether the selected intra mode of the current PU is same as one of the three MPMs.
<ul id="ul0007" list-style="dash" compact="compact">
<li>If prev_intra_luma_pred_flag[xPb][yPb] being signaled as 1, i.e., one of the 3 MPMs is selected for coding the current PU, a index mpm_idx (may equal to 0, 1 or 2), indicating which MPM is selected for coding the current PU, is further signaled. The mpm_idx is binarized using truncated unary code and by-pass coded using no context modeling<!-- EPO <DP n="26"> --></li>
<li>Otherwise (prev intra_luma_pred_flag[xPb][yPb] being signaled as 0), i.e., non-MPM is used for current PU, an index rem_intra_luma_pred_mode[xPb][yPb], indicating which non-MPM is selected for the current PU, is further signaled. The value of rem_intra_luma_pred_mode[xPb][yPb] could be 0, 1, ...,31, and fixed length (5 bits) binarization is used with bypass coding.</li>
</ul></p>
<p id="p0072" num="0072">As previously discussed, video encoder 20 selects the intra prediction mode for a current PU. The process of selecting the intra prediction mode for a PU may be referred to as an encoder-side intra mode decision. When selecting an intra prediction mode for a current PU, video encoder 20 may select one of the three MPMs determined for the current PU or one of the non-MPM intra prediction modes. If video encoder 20 selects one of the three MPMs for the current PU as the intra prediction mode for the current PU, video encoder 20 may signal, in the bitstream, an MPM index for the current PU. In JCTVC-N1003, the MPM index for a PU having a top left luma sample at coordinates (x, y) is denoted mpm_ind[x][y]. Otherwise, if video encoder 20 does not select one of the three MPMs for the current PU as the intra prediction mode for the current PU, video encoder 20 may signal, in the bitstream, a non-MPM index for the current PU. In JCTVC-N1003, the non-MPM index for a PU having a top left luma sample at coordinates (x, y) is denoted rem_intra_pred_mode[x][y]. Furthermore, video encoder 20 signals, in the bitstream, a syntax element indicating whether an MPM index or a non-MPM index is signaled for the current PU. In JCTVC-N1003, this syntax element for a PU having a top left luma sample at coordinates (x, y) is denoted prev_intra_luma_pred_flag[x][y].</p>
<p id="p0073" num="0073">In JCTVC-N1003, an MPM index may only have three potential different values, while a non-MPM index may have many more potential values. Consequently, fewer bits may be required to signal an MPM index than a non-MPM index.</p>
<p id="p0074" num="0074">To select an intra prediction mode for a current PU as efficiently as possible, in the design of HEVC reference software (referred to as "the HM"), several fast intra mode decision methods have been integrated. The HM reference software may be downloaded from: https://hevc.hhi.fraunhofer.de/svn/svn_HEVCSoftware/tags/HM-14.0/.<!-- EPO <DP n="27"> --></p>
<p id="p0075" num="0075">Since there are as many as 35 available intra prediction modes for a luma block, a full rate-distortion optimization based encoder mode decision may be too expensive for a practical implementation. In the latest version of the HM, the intra mode decision is performed as two stages. In the first stage, <i>N</i> Intra mode candidates list is first roughly decided using a much cheaper cost criterion commonly known as "Sum of Absolute Transform Difference" (SATD). The value of <i>N</i> depends on block size, and the default setting in the HM is: <i>N</i> equals to 8 for 4x4 and 8x8, and <i>N</i> equals to 3 for 16x16 and larger block sizes. After that, the left and above neighboring modes, i.e., either candIntraPredModeA or both candIntraPredModeA and candIntraPredModeB (if candIntraPredModeA does not equal to candIntraPredModeA), are appended to the intra mode candidate list, if not already included. In the second stage, the intra mode candidate list is fed into the expensive rate-distortion cost calculation process, and the final best intra prediction mode is decided for the current PU. With this two stage intra mode decision process, the majority of intra prediction modes are skipped for the expensive rate-distortion cost calculation, and the best intra prediction mode is still selected without much penalty of coding performance drop.</p>
<p id="p0076" num="0076">In <nplcit id="ncit0003" npl-type="b"><text>Matsuo et al., "Improved intra angular prediction by DCT-based interpolation filter," Signal Processing Conference (EUSIPCO), 2012 Proceedings of the 20th European, pp. 1568-1572. IEEE, 2012</text></nplcit>., it is proposed to apply a 4-tap DCT based interpolation filter for 4x4 and 8x8 block sizes and the Intra smoothing filter is also turned off when 4-tap filter is applied, for block sizes larger than or equal to 16x16, the 2-tap bilinear interpolation filter is applied. In <patcit id="pcit0001" dnum="US31294611" dnum-type="L"><text>Maani, Ehsan, "Interpolation filter for intra prediction of HEVC," U.S. Patent Application 13/312,946, filed December 6, 2011</text></patcit>, a 4-tap interpolation filter can be used when the intra smoothing filter is off, while the 4-tap interpolation filter could be obtained based on a CUBIC interpolation process, a DCT-based interpolation process or a Hermite interpolation process. In <nplcit id="ncit0004" npl-type="s"><text>M. Guo, X. Guo, and S. Lei, "Improved Intra Mode Coding", Joint Collaborative Team on Video Coding (JCT-VC) of ITU-T SG16 WP3 and ISO/IEC JTC1/SC29/WG11, 4th Meeting: Daegu, Korea, 20-28 January, 2011</text></nplcit>, the binarization of the intra mode is adaptively selected from a set of pre-defined coding trees according to the modes of its neighboring blocks.</p>
<p id="p0077" num="0077">There may be a number of problems associated with existing techniques for intra prediction for coding video data, e.g., according to the HEVC standard. For example,<!-- EPO <DP n="28"> --> the 35 fixed prediction angles of the existing design of intra prediction in HEVC may be inefficient to capture very flexible edge direction distributions. However, applying more prediction angles may result in undesired encoder complexity increases. For example, a direct extension to 65 prediction angles based on the HEVC reference software may require an approximately doubled number of SATD checks relative to the 35 fixed prediction angles of the existing design of intra prediction in HEVC. Additionally, the efficiency of the current intra mode coding, e.g., using three MPMs in HEVC, can be limited because it may not accurately correspond to the actual probability distribution of all available intra prediction modes. In other words, the three MPMs determined in HEVC for a particular PU may not actually be the intra prediction modes that are most likely to be used for the particular PU.</p>
<p id="p0078" num="0078">The techniques of this disclosure may resolve the above-identified problems associated with existing techniques for intra prediction for coding video data, e.g., according to the HEVC standard, as well as other problems in the technical fields of intra prediction and video coding and compression. The following itemized methods may be applied individually. Alternatively, any combination of them may be applied.</p>
<p id="p0079" num="0079">In accordance with some techniques of this disclosure, more than three MPMs can be used for signaling an intra prediction mode. For instance, a typical example of the number of MPM, denoted by <i>M</i>, can be 4, 5 or 6. The use of additional MPMs may reduce the probability of using non-MPM indexes to signal intra prediction modes of PUs. Because MPM indexes are typically represented using fewer bits than non-MPM indexes, the use of additional MPMs may increase decrease bitstream size.</p>
<p id="p0080" num="0080">In some examples where more than three MPMs are used for signaling an intra prediction mode of a PU, video encoder 20 may use an entropy encoding process, such as CABAC, to encode a MPM index and video decoder 30 may use an entropy decoding process, such as CABAC, to decode the MPM index. The MPM index for a PU may be a numerical value identifying which of the MPMs is the intra prediction mode of the PU. As part of using the entropy encoding process to encode the MPM index, video encoder 20 may binarize the MPM index. In other words, video encoder 20 may convert the MPM index into a binary code. In different examples, video encoder 20 may use various binarization methods to convert the MPM index into a binary code. For instance, a video coder may binarize the MPM index using at least one of: a fixed truncated unary code or a fixed Huffman code. Furthermore, in some examples, when<!-- EPO <DP n="29"> --> coding the MPM index, the binarization method can be a fixed truncated unary code, or a fixed Huffman code or decided based on the coded neighboring intra modes. For instance, a video coder may determine the binarization method based on intra prediction modes used to code one or more neighboring blocks. For instance, for an MPM index of a PU, the video coder may determine the binarization method based on intra prediction modes used to code one or more neighboring blocks adjacent to the PU. After binarizing the MPM index, video encoder 20 may CABAC encode the binarized MPM index and include the CABAC-encoded binarized MPM index in the bitstream. As part of decoding the MPM index, video decoder 30 may obtain the CABAC-encoded binarized MPM index from the bitstream, apply CABAC decoding to the CABAC-encoded binarized MPM index to recover the binarized MPM index, and de-binarize the MPM index to recover the MPM index. In this disclosure, the phrase "bins of an MPM index" may refer to bins of the binarized MPM index.</p>
<p id="p0081" num="0081">In some examples of this disclosure, video encoder 20 and video decoder 30 may use context modeling when coding (e.g., CABAC coding) one or more bins of an MPM index. In other words, video encoder 20 and video decoder 30 may select, for each respective bin of one or more bins of the MPM index, a respective coding context for the respective bin. Video encoder 20 and video decoder 30 may use the respective coding context for the respective bin to code the respective bin. For example, when coding the MPM index, the first or selected N coded bins can be coded using context modeling, while the context index is decided using the coded neighboring intra prediction modes. For instance, for an MPM index of a PU in a current picture, the video coder may determine the context index based on intra prediction modes used to code one or more neighboring PUs adjacent in the current picture to the PU. In this example, <i>N</i> is an integer. In some various examples, <i>N</i> may be equal to 1, 2, or 3. Thus, in some examples, the one or more context-modeled bins consists of the first bin of the MPM index. In other examples, the one or more the one or more context-modeled bins consists of a selected <i>N</i> bins of the MPM index, where <i>N</i> is set equal to <i>M - K,</i> wherein <i>K</i> is a pre-defined number.</p>
<p id="p0082" num="0082">In one example where video encoder 20 and video decoder 30 use context modeling when coding one or more bins of an MPM index of a current PU, the context index is dependent on the cases of left and above neighboring intra prediction modes. In case 0 of this example, left and above neighboring intra prediction modes are same<!-- EPO <DP n="30"> --> and neither of the intra prediction modes is DC or planar. In case 1 of this example, the left and the above neighboring intra prediction modes are same and at least one of the intra prediction modes is DC or planar. In case 2 of this example, the left and the above neighboring intra prediction modes are different and neither is planar. In case 3 of this example, left and above neighboring intra prediction modes are different and at least one of the intra prediction modes is planar. The left and above neighboring intra prediction modes may be the intra prediction modes of PUs left and above the current PU. In this example, video encoder 20 and video decoder 30 may calculate the context index based on a pre-defined mapping table which maps from the case index (e.g., case 0, case 1, case 2, or case 3) to a context index number. In other words, a video coder may use a case index to context index mapping table to determine a context index from the case index. The context index number may identify a predefined coding context in a set of predefined coding contexts.</p>
<p id="p0083" num="0083">Thus, in this example, when a video coder selects a context index for a context-modeled bin of the MPM index, the video coder may select a first context index if intra prediction modes used to decode a left neighboring block and an above neighboring block are the same and neither of the intra prediction modes used to decode the left neighboring block nor the above neighboring block is DC or planar. Furthermore, in this example, the video coder may select a second context index if intra prediction modes used to decode the left neighboring block and the above neighboring block are same and at least one of the intra prediction modes used to decode the left neighboring block and the above neighboring block is DC or planar. In this example, the video coder may select a third context index if intra prediction modes used to decode the left neighboring block and the above neighboring block are different and neither of the intra prediction modes used to decode the left neighboring block nor the above neighboring block is planar. In this example, the video coder may select a fourth context index if intra prediction modes used to decode the left neighboring block and the above neighboring block are different and at least one of the intra prediction modes used to decode the left neighboring block and the above neighboring block is DC or planar.</p>
<p id="p0084" num="0084">In some examples, different case index to context index mapping tables are used for different bins. For example, a video coder, such as video encoder 20 or video decoder 30, may use a first case index to context index mapping table for bin 0 of the MPM index, a second case index to context index mapping table for bin 1 of the MPM<!-- EPO <DP n="31"> --> index, a third case index to context index mapping table for bin 2 of the MPM index, and so on. The different case index to context index mapping tables of this example may assign different contexts to the cases (e.g., case 0, case 1, case 2, and case 3) described above. For instance, the mapping described in the previous paragraph may apply for the first bin of the MPM index, but for a second bin of the MPM index, the video coder may select the second context index if intra prediction modes used to decode a left neighboring block and an above neighboring block are the same and neither of the intra prediction modes used to decode the left neighboring block nor the above neighboring block is DC or planar; select the third context index if intra prediction modes used to decode the left neighboring block and the above neighboring block are same and at least one of the intra prediction modes used to decode the left neighboring block and the above neighboring block is DC or planar; and so on.</p>
<p id="p0085" num="0085">In some examples where video encoder 20 and video decoder 30 use context modeling when coding one or more bins of an MPM index of a current PU, only one context is applied for coding each of the first or selected N bins, and the context may not depend on the neighboring intra prediction modes. For instance, in such examples, video encoder 20 and video decoder 30 perform the coding context selection process once for the MPM index and do not repeat for the coding context selection process for subsequent bins of the MPM index. In other words, a video coder may select a common context index for each of the one or more context-modeled bins of the MPM index.</p>
<p id="p0086" num="0086">As mentioned above, in some examples, video encoder 20 and video decoder 30 may use context modeling when coding <i>N</i> coded bins of an MPM index. In one such example, <i>N</i> is set equal to (<i>M-K</i>), where <i>K</i> is a pre-defined number and <i>M</i> is the number of MPMs. For example, <i>K</i> may be equal to 1, 2 or 3.</p>
<p id="p0087" num="0087">Thus, in the examples above, video encoder 20 may derive <i>M</i> MPMs for intra prediction of the block of video data from among a plurality of intra prediction modes. In this example, <i>M</i> is greater than 3. Furthermore, encoding a syntax element that indicates whether a most probable mode index or a non-most probable mode index is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the block of video data. The MPM index indicates which of the <i>M</i> MPMs is the selected intra prediction mode the non-MPM index indicates which of the plurality of intra prediction modes other than the <i>M</i> MPMs is the selected intra prediction mode. Based on the indicated one of the MPM index or the non-MPM<!-- EPO <DP n="32"> --> index being the MPM index, video encoder 20 may select, for each of one or more context-modeled bins of the MPM index, based on intra prediction modes used to decode one or more neighboring blocks, a context index for the context-modeled bin. Video encoder 20 may encode the block of video data based on the selected intra prediction mode.</p>
<p id="p0088" num="0088">In this example, the block of video data may be a current CU in a current picture of the video data and the selected intra prediction mode for the block of video data is a selected intra prediction mode for a current PU of the current CU. In this example, to encode the syntax element that indicates whether a MPM index or a non-MPM index is used to indicate the selected intra prediction mode, video encoder 20 may encode a syntax element (e.g., prev_intra_luma_pred_flag) that indicates whether a MPM index (e.g., mpm_idx) or a non-MPM index (e.g., rem_intra_luma_pred_mode) is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the PU. Video encoder 20 may for each of the one or more context-modeled bins of the MPM index, use the selected context index for the context-modeled bin to perform CABAC encoding of the context-modeled bin. Furthermore, as part of encoding the block of video data based on the selected intra prediction mode, video encoder 20 may generate, based on the selected intra prediction mode of the current PU, a predictive block for the current PU. Video encoder 20 may generate residual data that represents pixel differences between the current CU and the predictive block. In this example, video encoder 20 may output a bitstream that includes a sequence of bits that forms a representation of coded pictures and associated data, the coded pictures including the current picture.</p>
<p id="p0089" num="0089">Similarly, in some examples, video decoder 30 may derive <i>M</i> MPMs for intra prediction of the block of video data from among a plurality of intra prediction modes. In this example, <i>M</i> is greater than 3. Furthermore, video decoder 30 may decode a syntax element that indicates whether a MPM index or a non-MPM index is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the block of video data. The MPM index indicates which of the <i>M</i> MPMs is the selected intra prediction mode and the non-MPM index indicates which of the plurality of intra prediction modes other than the <i>M</i> MPMs is the selected intra prediction mode. Based on the indicated one of the MPM index or the non-MPM index being the MPM index, video decoder 30 may select, for each of one or more context-modeled<!-- EPO <DP n="33"> --> bins of the MPM index, based on intra prediction modes used to decode one or more neighboring blocks, a context index for the context-modeled bin. Furthermore, video decoder 30 may reconstruct the block of video data based on the selected intra prediction mode.</p>
<p id="p0090" num="0090">For instance, in this example, the block of video data may be a current CU in a current picture of the video data and the selected intra prediction mode for the block of video data is a selected intra prediction mode for a current PU of the current CU. In this example, to decoded the syntax element that indicates whether the MPM index or the non-MPM index is used to indicate the selected intra prediction mode, video decoder 30 may decode, from a bitstream, a syntax element (e.g., prev_intra_luma_pred_flag) that indicates whether a MPM index (e.g., mpm_idx) or a non-MPM index (e.g., rem_intra_luma_pred_mode) is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the current PU. In this example, for each of the one or more context-modeled bins of the MPM index, video decoder 30 may use the selected context index for the context-modeled bin to perform CABAC decoding of the context-modeled bin of the MPM index. Furthermore, as part of reconstructing the block of video data based on the selected intra prediction mode, video decoder 30 may generate a predictive block for the current PU using the selected intra prediction mode. In this example, video decoder 30 may reconstruct the current CU using residual values by adding samples of the predictive blocks of PUs of the CU to corresponding samples of transform blocks of TUs of the current CU. In this example, video decoder 30 may receive a bitstream that includes a sequence of bits that forms a representation of coded pictures and associated data, the coded pictures including the current picture.</p>
<p id="p0091" num="0091">As briefly discussed above, the efficiency of intra prediction mode coding using the three MPMs specified in HEVC may be limited because the three MPMs specified in HEVC frequently do not accurately correspond to the actual probability distribution of all available intra prediction modes. For instance, the probability of the intra prediction mode of a PU being a particular non-MPM intra prediction mode may be greater than the probabilities of the intra prediction mode of the PU being any of the three MPMs specified in HEVC.</p>
<p id="p0092" num="0092">Thus, in accordance with some examples of this disclosure, when deriving the MPMs, a representative intra prediction mode is defined for left (or above) neighboring<!-- EPO <DP n="34"> --> column (or row) and the representative intra prediction mode is used as the MPM candidate from the left (or above) neighboring column. For instance, a video coder may define a representative intra prediction mode for a left neighboring column and use the representative mode for the left neighboring column as an MPM candidate. The video coder may use the representative mode for the left neighboring column as an MPM candidate in addition to the MPM defined in HEVC for the left neighboring block or in place of the MPM defined in HEVC for the left neighboring block (candIntraPredModeA). Moreover, the video coder may define a representative intra prediction mode for an above neighboring row and use the representative mode for the above neighboring row as an MPM candidate. The video coder may use the representative mode for the above neighboring row as an MPM candidate in addition to the MPM defined in HEVC for the above neighboring block or in place of the MPM defined in HEVC for the above neighboring block (candIntraPredModeB).</p>
<p id="p0093" num="0093">The left neighboring column may include a column of samples immediately left in a picture of a column of samples containing a current sample of a current PU for a CU of the picture. For instance, the left neighboring column may include (or consist of) each sample immediately left of the current PU. The above neighboring row may include a row of samples immediately above in a picture of a row of samples containing a current sample of a current PU for a CU of the picture. For instance, the above neighboring row may include (or consist of) each sample immediately above the current PU.</p>
<p id="p0094" num="0094">For example, as part of encoding video data, video encoder 20 may encode a block of video data in part by deriving <i>M</i> MPMs for intra prediction of the block of video data from among a plurality of intra prediction modes. In some examples, <i>M</i> is greater than 3. In this example, the MPMs may include an MPM for the left neighboring column and an MPM for the above neighboring row. In some examples, video encoder 20 defines a representative intra prediction mode for the left neighboring column and uses the representative intra prediction mode for the left neighboring column as the MPM for the left neighboring column. In some examples, video encoder 20 defines a representative intra prediction mode for the above neighboring row and using the representative intra prediction mode for the above neighboring row as the MPM for the above neighboring row.<!-- EPO <DP n="35"> --></p>
<p id="p0095" num="0095">Furthermore, video encoder 20 may encode a syntax element that indicates whether a MPM index or a non-MPM index is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the block of video data, and encodes the indicated one of the MPM index or the non-MPM index. For example, video encoder 20 may include, in the bitstream, data indicating a prev_intra_luma_pred_flag syntax element that indicates whether the bitstream includes data indicating an mpm_index or a rem_intra_luma_pred_mode syntax element. The MPM index indicates which of the MMPMs is the selected intra prediction mode. The non-MPM index indicates which of the intra prediction modes other than the <i>M</i> MPMs is the selected intra prediction mode. Video encoder 20 encodes the block of video data based on the selected intra prediction mode.</p>
<p id="p0096" num="0096">In this example, the block of video data is a current CU in a current picture of the video data and the selected intra prediction mode for the block of video data is a selected intra prediction mode for a current PU of the current CU. To encode the block of video data based on the selected in intra prediction mode, video encoder 20 may reconstruct the block of video data in part by generating a predictive block for the current PU using the selected intra prediction mode. Furthermore, video encoder 20 may reconstruct the current CU using residual values by adding samples of the predictive blocks of PUs of the CU to corresponding samples of transform blocks of TUs of the current CU.</p>
<p id="p0097" num="0097">In a similar example of selecting an intra prediction mode to be used for intra prediction for coding video data, video decoder 30 may decode a block of video data in part by deriving <i>M</i> MPMs for intra prediction of the block of video data from among a plurality of intra prediction modes. In this example, <i>M</i> may be greater than 3. The MPMs may include an MPM for the left neighboring column and an MPM for the above neighboring row. In some examples, video decoder 30 defines a representative intra prediction mode for the left neighboring column and uses the representative intra prediction mode for the left neighboring column as the MPM for the left neighboring column. In some examples, video decoder 30 defines a representative intra prediction mode for the above neighboring row and uses the representative intra prediction mode for the above neighboring row as the MPM for the above neighboring row.</p>
<p id="p0098" num="0098">Furthermore, video decoder 30 may decode a syntax element that indicates whether a MPM index or a non-MPM index is used to indicate a selected intra<!-- EPO <DP n="36"> --> prediction mode of the plurality of intra prediction modes for intra prediction of the block of video data, and decodes the indicated one of the most probable mode index or the non-most probable mode index. For instance, video decoder 30 may obtain a previ_ntrapred_flag from a bitstream. The MPM index indicates which of the <i>M</i> MPMs is the selected intra prediction mode. The non-MPM index indicates which of the plurality of intra prediction modes other than the <i>M</i> MPMs is the selected intra prediction mode.</p>
<p id="p0099" num="0099">Video decoder 30 may then reconstruct a video block based on the resulting selected intra prediction mode. In this example, the block of video data may be a current CU in a current picture of the video data and the selected intra prediction mode for the block of video data is a selected intra prediction mode for a current PU of the current CU. In this example, as part of reconstructing the video block based on the resulting selected intra prediction mode, video decoder 30 may use the selected intra prediction mode to generate a predictive block for the video block. For instance, the video block may be a CU and video decoder 30 may use the selected intra prediction mode to generate a predictive block for a PU of the CU. Furthermore, video decoder 30 may reconstruct at least some samples of the video block by adding samples of the predictive block to corresponding residual samples for the video block. For instance, the video block may be a CU and video decoder 30 may add samples of the predictive block to corresponding residual samples in one or more transform blocks of TUs of the CU.</p>
<p id="p0100" num="0100">In various examples, a video coder may determine a representative intra prediction mode in different ways. In one example, it is defined as a function of all the intra prediction modes used by the neighboring blocks. For example, the number of actually used intra prediction modes of the left (or above) neighboring column (or row), in unit of the smallest PU size (e.g., 4), are counted, and the most frequently used one is defined as the representative intra prediction mode. Thus, in the examples above, video encoder 20 and video decoder 30 may define the representative intra prediction mode for the left neighboring column based on a most frequent intra prediction mode of the left neighboring column, and define the representative intra prediction mode for the above neighboring column based on a most frequent intra prediction mode of the above neighboring row.<!-- EPO <DP n="37"> --></p>
<p id="p0101" num="0101">Alternatively, the counting is based on the PU size of the current block. For instance, a video coder may determine the most frequent intra prediction mode of the neighboring blocks based on at least one of: (i) a smallest prediction unit size, or (ii) a prediction unit size of the block of video data. In one example, instead of counting based on the unit of a smallest PU size (e.g., 4x4), a different unit size may be used for a different PU size of current block. For example, if the PU size of the current block is 64x64, the counting is based on an 8x8 PU size or a 16x16 PU size, instead of the smallest PU size (4x4).</p>
<p id="p0102" num="0102">In some examples, a representative intra prediction mode may be defined as one of the intra prediction modes used by a selected neighboring block in the left (or above) neighboring column (or row). For example, the intra prediction mode of the sample (or block equal to the smallest PU size) located at the middle position of the left(right) neighboring column(row), which is not the left (top)-most or the right(bottom)-most one, is defined as the representative intra prediction mode of the left (or above) neighboring mode. Furthermore, in the examples above, the most frequent intra prediction mode of the neighboring blocks may be determined based on at least one of a smallest prediction unit size, or a prediction unit size of the block of video data. In another example, video encoder 20 and video decoder 30 may define the representative intra prediction mode for the left neighboring column as an intra prediction mode used by a selected neighboring block in the left neighboring column, and may define the representative intra prediction mode for the above neighboring row as an intra prediction mode used by a selected neighboring block in the above neighboring row.</p>
<p id="p0103" num="0103">As mentioned above, particular examples of this disclosure allow for <i>M</i> MPMs, where <i>M</i> is greater than three. Thus, in accordance with such examples of this disclosure, video encoder 20 may derive <i>M</i> MPMs for intra prediction of the block of video data from among a plurality of intra prediction modes. In other words, video encoder 20 may derive, from among the plurality of intra prediction modes, <i>M</i> MPMs for intra prediction of a PU of a CU of a current picture of the video data. In this example, <i>M</i> is greater than 3. In this example, <i>M</i> is less than a total number of intra prediction modes in the plurality of intra prediction modes. Furthermore, in this example, video encoder 20 may encode a syntax element that indicates whether a MPM index or a non-MPM index is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the block of video data. In this<!-- EPO <DP n="38"> --> example, video encoder 20 may encode the indicated one of the MPM index or the non-MPM index. The MPM index indicates which of the <i>M</i> MPMs is the selected intra prediction mode and the non-MPM index indicates which of the plurality of intra prediction modes other than the <i>M</i> MPMs is the selected intra prediction mode. Video encoder 20 may encode the block of video data based on the selected intra prediction mode.</p>
<p id="p0104" num="0104">In this example, the block of video data may be a current CU in a current picture of the video data and the selected intra prediction mode for the block of video data is a selected intra prediction mode for a current PU of the current CU. In this example, video encoder 20 may encode the syntax element that indicates whether a MPM index or a non-MPM index is used to indicate the selected intra prediction mode, video encoder 20 may encode a syntax element (e.g., prev_intra_luma_pred_flag) that indicates whether a MPM index (e.g., mpm_idx) or a non-MPM index (e.g., rem_intra_luma_pred_mode) is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the PU. Furthermore, as part of encoding the block of video data based on the selected intra prediction mode, video encoder 20 may generate, based on the selected intra prediction mode of the current PU, a predictive block for the current PU. Video encoder 20 may generate residual data that represents pixel differences between the current CU and the predictive block. In this example, video encoder 20 may output a bitstream that includes a sequence of bits that forms a representation of coded pictures and associated data, the coded pictures including the current picture.</p>
<p id="p0105" num="0105">Moreover, in accordance with such examples of this disclosure, video decoder 30 may derive <i>M</i> MPMs for intra prediction of the block of video data from among a plurality of intra prediction modes. In this example <i>M</i> is greater than 3. <i>M</i> may be less than the total number of intra prediction modes in the plurality of intra prediction modes. Furthermore, in this example, video decoder 30 may decode a syntax element that indicates whether a MPM index or a non-MPM index is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the block of video data. In this example, video decoder 30 may decode the indicated one of the MPM index or the non-MPM index. Video decoder 30 may reconstruct the block of video data based on the selected intra prediction mode.<!-- EPO <DP n="39"> --></p>
<p id="p0106" num="0106">For instance, in this example, the block of video data may be a current CU in a current picture of the video data and the selected intra prediction mode for the block of video data is a selected intra prediction mode for a current PU of the current CU. In this example, to decoded the syntax element that indicates whether the MPM index or the non-MPM index is used to indicate the selected intra prediction mode, video decoder 30 may decode, from a bitstream, a syntax element (e.g., prev_intra_luma_pred_flag) that indicates whether a MPM index (e.g., mpm_idx) or a non-MPM index (e.g., rem_intra_luma_pred_mode) is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the current PU. Furthermore, as part of reconstructing the block of video data based on the selected intra prediction mode, video decoder 30 may generate a predictive block for the current PU using the selected intra prediction mode. In this example, video decoder 30 may reconstruct the current CU using residual values by adding samples of the predictive blocks of PUs of the CU to corresponding samples of transform blocks of TUs of the current CU. In this example, video decoder 30 may receive a bitstream that includes a sequence of bits that forms a representation of coded pictures and associated data, the coded pictures including the current picture.</p>
<p id="p0107" num="0107">In some examples, when deciding the <i>M</i> (<i>M &gt;</i> 3) MPMs, the original three MPMs defined in HEVC are maintained in the MMPMs, and additional (<i>M</i>-3) intra prediction modes are added. For instance, in some examples, the additional three intra prediction modes can be selected such that, planar and DC modes are always included in the MPMs. In other words, the process of deriving the <i>M</i> MPMs may comprise including a planar mode and a DC mode among the <i>M</i> MPMs.</p>
<p id="p0108" num="0108">Alternatively, in some examples, the additional (M-3) intra prediction modes can be selected such that planar, DC, VERTICAL (i.e., INTRA_ANGULAR26) and/or HORIZONTAL (i.e., INTRA_ANGULAR10), and/or DIAGONAL (i.e., INTRA_ANGULAR18) modes are always included in the MPMs. In other words, the process of deriving the <i>M</i> MPMs may comprise including a Planar mode, a DC mode, and at least one of a VERTICAL mode, a HORIZONTAL mode or a DIAGONAL mode among the <i>M</i> MPMs.</p>
<p id="p0109" num="0109">In some examples, the additional (<i>M</i>-3) intra prediction modes may be selected from angular modes which are closest to the angular mode already included in the first three MPMs. In this example, the term 'closest' is measured by the difference of intra<!-- EPO <DP n="40"> --> prediction mode indices or the absolute value of the difference of intra prediction mode indices, or the difference of intra prediction angles. For instance, in this example, as part of deriving the <i>M</i> MPMs, a video coder (e.g., video encoder 20 or video decoder 30) may derive three MPMs, wherein the three MPMs include at least one angular mode. Furthermore, in this example, the video coder may select one or more additional angular MPMs based on similarity with the at least angular mode. In this example, similarity is determined based on at least one of intra prediction mode index differences or intra prediction angle differences</p>
<p id="p0110" num="0110">In accordance with some examples of this disclosure, in order to reduce the number of bits used for coding index values, certain variations in the number of bits that are utilized to code index values may be included when coding the non-MPM index. Thus, a video coder, such as video encoder 20 and video decoder 30, may determine whether an MPM index or a non-MPM index is being used to indicate a selected intra prediction mode of a plurality of intra prediction modes and, when a non-MPM index is identified, use either a fixed length code to represent the non-MPM index or a variable length code to represent the non-MPM index, depending on whether one or more criteria are met. In various examples, a video coder may determine the various criteria in different ways. For example, the criteria may be met if the non-MPM index is one of a predetermined number of first non-MPM indices of the plurality of intra prediction modes. In some examples, the criteria are met if the non-MPM index is one of a predetermined number of last non-MPM indices. In some examples, the criteria are met if the non-MPM index is one of a predetermined number of selected non-MPM indices.</p>
<p id="p0111" num="0111">Thus, in accordance with one example of this disclosure, video encoder 20 may derive <i>M</i> most probable modes for intra prediction of a block of video data from among a plurality of intra prediction modes. In this example, <i>M</i> may be greater than 3. Furthermore, video encoder 20 may encode a syntax element that indicates whether a MPM index or a non-MPM index is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the block of video data. Furthermore, in this example, video encoder 20 may encode, based on the syntax element indicating the non-MPM index is used to indicate the selected intra prediction mode, the non-MPM index. In this example, the non-MPM index may be encoded in the bitstream as a code word shorter than ┌log<sub>2</sub> <i>N</i>┐ bits if the non-MPM index satisfies a criterion and is encoded as a fixed length code with ┌log<sub>2</sub> <i>N</i>┐ bits otherwise. In this<!-- EPO <DP n="41"> --> example, there may be a total of N available values of the non-MPM index. Furthermore, video encoder 20 may encode the block of video data based on the selected intra prediction mode. In this disclosure, ┌ ┐ represents the rounding up operation.</p>
<p id="p0112" num="0112">In this example, the block of video data may be a current CU in a current picture of the video data and the selected intra prediction mode for the block of video data may be a selected intra prediction mode for a current PU of the current CU. Furthermore, in this example, to encode a syntax element that indicates whether an MPM index or a non-MPM index is used to indicate the selected intra prediction mode, video encoder 20 may include, in a bitstream, data indicating a syntax element (e.g., prev_intra_luma_pred_flag) that indicates whether a MPM index (e.g., mpm_idx) or a non-MPM index (e.g., rem_intra_luma_pred_mode) is used to indicate, for the current PU, the selected intra prediction mode of a plurality of intra prediction modes. Furthermore, in some such examples, to encode the block of video data based on the selected intra prediction mode, video encoder 20 may generate a predictive block for the PU using the selected intra prediction mode and video encoder 20 may generate residual data that represents pixel differences between the current CU and the predictive block. In some examples, video encoder 20 may transform and quantize the residual data and include, in a bitstream, entropy encoded syntax elements representing the resulting quantized transform coefficients.</p>
<p id="p0113" num="0113">In one example, the criterion may be met if the non-MPM index is one of a predetermined number of first non-MPM indices of the plurality of intra prediction modes. For example, for non-MPM modes, both the encoder and decoder may assign an index value to each of the available non-MPM modes. With the decoded index value, the decoder will know which non-MPM mode is signaled. In one example, when a non-MPM index is one of the first M index values, the non-MPM index may be within the range of 0 ∼ (M-1). In another example, the criterion may be met if the non-MPM index is one of a predetermined number of last non-MPM indices. In another example, the criterion may be met if the non-MPM index is one of a predetermined number of selected non-MPM indices.</p>
<p id="p0114" num="0114">In a similar example, video decoder 30 may derive <i>M</i> MPMs for intra prediction of the block of video data from among a plurality of intra prediction modes. In this example, <i>M</i> may be greater than 3. Furthermore, in this example, video decoder 30 may<!-- EPO <DP n="42"> --> decode a syntax element that indicates whether a MPM index or a non-MPM index is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the block of video data. As before, the MPM index indicates which of the <i>M</i> most probable modes is the selected intra prediction mode, and the non-MPM index indicates which of the plurality of intra prediction modes other than the <i>M</i> MPMs is the selected intra prediction mode. Furthermore, in this example, based on the MPM index indicating the selected intra prediction mode, video decoder 30 may decode the non-MPM index. In this example, the non-MPM index is encoded in the bitstream as a code word shorter than ┌log<sub>2</sub> <i>N</i>┐ bits if the non-MPM index satisfies a criterion and is encoded in the bitstream as a fixed length code with ┌log<sub>2</sub> <i>N</i>┐ bits otherwise. In this example, there is a total of <i>N</i> available values of the non-MPM index. Video decoder 30 may reconstruct the block of video data based on the selected intra prediction mode.</p>
<p id="p0115" num="0115">In this example, the block of video data may be a current CU in a current picture of the video data and the selected intra prediction mode for the block of video data may be a selected intra prediction mode for a current PU of the current CU. Furthermore, in this example, to decode the syntax element that indicates whether a MPM index or a non-MPM index is used to indicate the selected intra prediction mode for intra prediction of the current PU, video decoder 30 may decode or otherwise obtain, from a bitstream, a syntax element (e.g., prev_intra_luma_pred_flag) that indicates whether a MPM index (e.g., mpm_idx) or a non-MPM index (e.g., rem_intra_luma_pred_mode) is used to indicate a selected intra prediction mode for the current PU. Furthermore, in some examples, as part of reconstructing the block of video data based on the selected intra prediction mode, video decoder 30 may generate a predictive block for the current PU using the selected intra prediction mode. In such examples, video decoder 30 may reconstruct the current CU using residual values by adding samples of the predictive blocks of PUs of the CU to corresponding samples of transform blocks of TUs of the current CU</p>
<p id="p0116" num="0116">In one example, the criterion may be met if the non-MPM index is one of a predetermined number of first non-MPM indices of the plurality of intra prediction modes. For instance, the criterion may be that the non-MPM index is one of the first <i>X</i> non-MPM indices of the plurality of intra prediction modes, <i>X</i> being an integer. In another example, the criterion may be met if the non-MPM index is one of a<!-- EPO <DP n="43"> --> predetermined number of last non-MPM indices. For instance, the criterion may be that the non-MPM index is one of the last <i>X</i> non-MPM indices of the plurality of intra prediction modes, <i>X</i> being an integer. In another example, the criterion may be met if the non-MPM index is one of a predetermined number of selected non-MPM indices. For instance, the criterion may be that the non-MPM index is one of <i>X</i> selected non-MPM indices of the plurality of intra prediction modes, <i>X</i> being an integer.</p>
<p id="p0117" num="0117">Thus, when coding the non-MPM index, all the available <i>N</i> non-MPM indexes, except for the first <i>M</i> or the last <i>M</i> or selected <i>M,</i> index values may be coded using fixed length code with ┌log<sub>2</sub> <i>N</i>┐ bits, while the M index values is signaled using code word shorter than ┌log<sub>2</sub> <i>N</i>┐ bits. In this example, <i>M</i> may or may not be equal to the number of MPMs. Alternatively, all the available <i>N</i> non-MPM indexes are coded using fixed length code with ┌log<sub>2</sub> <i>N</i>┐ bits.</p>
<p id="p0118" num="0118">Alternatively, in some examples, a one-bit flag, indicating whether the non-MPM index refers to a horizontal or vertical mode, is first signaled with context modeling, then an index further specifying which non-MPM is selected is further signaled. Thus, in this example, video encoder 20 may encode, based on a syntax element (e.g., prev_intra_luma_pred_flag) indicating the non-MPM index (e.g., rem_intra_luma_pred_mode) is used to indicate the selected intra prediction mode for the block of video data, a second syntax element indicating whether the non-MPM index refers to one of a horizontal mode or a vertical mode. Similarly, video decoder 30 may decode, from the bitstream, based on a syntax element (e.g., prev_intra_luma_pred_flag) indicating a non-MPM index is used, a second syntax element indicating whether the non-MPM index refers to one of a horizontal mode or a vertical mode.</p>
<p id="p0119" num="0119">In some examples, when more than three MPMs are used for signaling the intra prediction mode, during the encoder mode decision, for each PU, the first <i>K</i> (<i>K</i>&gt;=2) MPMs are inserted into the candidate intra prediction mode list which is to be checked by rate-distortion optimization. The value of <i>K</i> may depend on whether the left neighboring intra prediction mode <i>IntraModeL</i> and above neighboring intra prediction mode <i>IntraModeA</i> are the same. For example, <i>K =</i> (<i>IntraModeL</i>== <i>IntraModeA</i>)? 2 : 3. In other words, in this example, <i>K</i> is set equal to 2 if <i>IntraModeL</i> is equal to <i>IntraModeA</i> and set equal to 3 otherwise.<!-- EPO <DP n="44"> --></p>
<p id="p0120" num="0120">In some examples, the number of MPMs may depend on CU or PU sizes. For example, the number of MPMs may be greater for larger CU or PU sizes. Alternatively, in some examples, the number of MPMs may be signaled in a sequence parameter set, a picture parameter set, or a slice header.</p>
<p id="p0121" num="0121">In accordance with some examples of this disclosure, a video coder, such as video encoder 20 and video decoder 30, may use more than 33 angular intra prediction modes. For example, the video coder may use 65 angular modes. In this example, the 65 prediction angles (directions) may be defined such that the interpolation is performed in 1/32 pel (pixel) accuracy. As discussed above, when a PU is encoded using an angular intra prediction mode, a video coder may determine a fractional position between two reconstructed neighboring samples by projecting, along a prediction direction associated with the angular intra prediction mode, the coordinates of a sample of the predictive block of the PU. When the interpolation is performed in 1/32 pel accuracy, 31 equidistant positions are defined between the two adjacent reconstructed neighboring pixels and the video coder sets the determined fractional position as to the closest one of the reconstructed neighboring pixels or the 31 positions. Using a limited number of positions instead of a real number line may simplify the processing involved in performing the interpolation calculations. As briefly described above, performing interpolation using 1/32 pel accuracy despite more than 33 angular intra prediction modes being available may increase accuracy while keeping the level of complexity the same. In particular, in order to perform interpolations with increased accuracy, an increased number of different interpolation filters would need to be designed and stored at both the encoder and the decoder. Therefore, for example, by avoiding the need for increased interpolation accuracy, the complexity (only 32 different interpolation filters still being utilized) of the video coder may remain the same using 1/32 pel interpolations.</p>
<p id="p0122" num="0122">Thus, in the examples above where more than 33 angular intra prediction modes are used (e.g., 65 angular intra prediction modules are used) and interpolation is performed in 1/32 pel accuracy, as part of encoding a block of the video data, video encoder 20 may encode syntax information (e.g., mpm_idx or rem_intra_luma_pred_mode) that indicates a selected intra prediction mode for the block of video data from among a plurality of intra prediction modes that includes more than 33 angular intra prediction modes. In this example, the angular intra prediction<!-- EPO <DP n="45"> --> modes are defined such that interpolation is performed in 1/32 pel accuracy. Furthermore, in this example, video encoder 20 may encode the block of video data based on the selected intra prediction mode.</p>
<p id="p0123" num="0123">In this example, the block of video data may be a current CU in a current picture of the video data and the selected intra prediction mode for the block of video data is a selected intra prediction mode for a current PU of the current CU. Furthermore, in this example, as part of encoding the block of video data, video encoder 20 may, for each respective sample of a predictive block of the current PU, video encoder 20 may determine a fractional position between two neighboring reconstructed samples of the current picture. <figref idref="f0005">FIG. 5</figref> is a conceptual diagram illustrating an example technique for generating a prediction sample for a block of video data according to an angular intra prediction mode. For instance, in the example of <figref idref="f0005">FIG. 5</figref>, video encoder 20 may determine a fractional position α between neighboring samples L and R. The two neighboring reconstructed samples neighbor the current PU. Video encoder 20 may determine the fractional position by projecting, along a prediction direction associated with the selected intra prediction mode, a coordinate of the respective sample to a row or column of neighboring reconstructed samples containing the two neighboring reconstructed samples. For instance, in the example of <figref idref="f0005">FIG. 5</figref>, line 60 shows the prediction direction associated with the selected intra prediction mode and (x,y) is the coordinate of the respective sample 62. In this example, video encoder 20 may calculate a prediction value of the respective sample using an interpolation filter that uses values of the two neighboring reconstructed samples to interpolate a value at the determined fractional position. This interpolation is in 1/32 pel accuracy. Additionally, in this example, as part of encoding the block of video data, video encoder 20 may generate residual data that represents pixel differences between the current block and the predictive block. Video encoder 20 may transform and quantize the residual data and include, in a bitstream, entropy encoded syntax elements representing the resulting quantized transform coefficients.</p>
<p id="p0124" num="0124">Similarly, in one example, video decoder 30 may decode syntax information (e.g., mpm_idx or rem_intra_luma_pred_mode) that indicates a selected intra prediction mode for a block of video data from among a plurality of intra prediction modes. In this example, the plurality of intra prediction modes includes greater than 33 angular intra prediction modes. The angular intra prediction modes may be defined such that<!-- EPO <DP n="46"> --> interpolation is performed in 1/32 pel accuracy. Video decoder 30 may reconstruct the block of video data based on the selected intra prediction mode.</p>
<p id="p0125" num="0125">Thus, in this example, the block of video data may be a current CU in a current picture of the video data and the selected intra prediction mode for the block of video data may be a selected intra prediction mode for a current PU of the current CU. As part of reconstructing the block of video data, for each respective sample of a predictive block of the current PU, video decoder 30 may determine a fractional position between two neighboring reconstructed samples of the current picture by projecting, along a prediction direction associated with the selected intra prediction mode, a coordinate of the respective sample to a row or column of neighboring reconstructed samples containing the two neighboring reconstructed samples. Additionally, video decoder 30 may calculate a prediction value of the respective sample using an interpolation filter that uses values of the two neighboring reconstructed samples to interpolate a value at the determined fractional position. In this example, this interpolation is in 1/32 pel accuracy. Video decoder 30 may reconstruct a coding block of the current CU using residual values by adding samples of the predictive blocks of PUs of the CU to corresponding samples of transform blocks of TUs of the current CU.</p>
<p id="p0126" num="0126">In the examples above, video encoder 20 and video decoder 30 may use more than 33 angular intra prediction modes, according to the invention. For instance, the plurality of angular intra prediction modes may include 65 angular intra prediction modes. Furthermore, in the examples above, the interpolation filter may be a two-tap bi-linear interpolation filter. In some such examples, the interpolation filter is formulated as: <maths id="math0009" num=""><math display="block"><msub><mi mathvariant="normal">p</mi><mi>xy</mi></msub><mo>=</mo><mfenced separators=""><mn>1</mn><mo>−</mo><mi mathvariant="normal">α</mi></mfenced><mo>⋅</mo><mi mathvariant="normal">L</mi><mo>+</mo><mi mathvariant="normal">α</mi><mo>⋅</mo><mi mathvariant="normal">R</mi></math><img id="ib0009" file="imgb0009.tif" wi="36" he="5" img-content="math" img-format="tif"/></maths> where p<sub>xy</sub> is the calculated value of the respective sample, L and R are values of the two reconstructed neighboring samples, and α is the determined fractional position.</p>
<p id="p0127" num="0127">As indicated above, in accordance with some examples of this disclosure, a video coder may use more than 33 angular intra prediction modes, according to the invention. In one such example, for each PU, it is restricted that only N angular modes are available to be used, which are adaptively selected from all the available angular modes using the coded information of the left and above neighboring blocks. For instance, in this example, video encoder 20 is prohibited from (i.e., restricted from) selecting particular angular intra prediction modes when encoding a block (e.g., PU) of a picture. In this example, video encoder 20 may be prohibited from selecting the particular angular intra<!-- EPO <DP n="47"> --> prediction modes despite the particular angular intra prediction modes being available to video encoder 20 for use in encoding other blocks of the same picture, and despite the fact that the particular angular intra prediction modes may offer better compression performance than angular intra prediction modes that video encoder 20 is allowed to use for encoding the block.</p>
<p id="p0128" num="0128">Thus, in an example according to the invention where only N angular intra prediction modes are available to be used, video encoder 20 and video decoder 30 may select, based on intra prediction modes used to decode one or more neighboring blocks, a subset of N angular intra prediction modes from among the plurality of angular intra prediction modes. In this example, the syntax information that indicates the selected intra prediction mode for the current PU may comprise an index that indicates the selected intra prediction mode. In this example, the index is a fixed length code consisting of ┌log<sub>2</sub> <i>N</i>┐ bits. In this example, <i>N</i> may be various integers, such as 33.</p>
<p id="p0129" num="0129">In some examples, the number of total intra prediction modes depends on CU or PU sizes. For instance, a video coder (e.g., video encoder 20 or video decoder 30) may determine, based on at least one of a CU size or a PU size, a total number of intra prediction modes in the plurality of intra prediction modes. For example, if a CU size or a PU size is below a particular threshold only angular intra prediction modes with index values less than a particular number are available. In some examples, a total number of intra prediction modes may be signaled in an SPS, a PPS, or a slice header.</p>
<p id="p0130" num="0130">As discussed above, video encoder 20 and video decoder 30 may apply an interpolation filter to reconstructed neighboring samples to determine values of samples in a predictive block. In accordance with some techniques of this disclosure, an <i>N</i>-tap intra interpolation filter can be applied, where <i>N</i> is larger than 2. For instance, <i>N</i> may be 3 and 4. When a video coder, such as video encoder 20 or video decoder 30, uses an <i>N</i>-tap intra interpolation filter to determine the value of a sample in a predictive block, the video coder may calculate the value based on the values of <i>N</i> reconstructed neighboring samples. Using N-tap (N&gt;2) interpolation may be advantageous over existing 2-tap interpolation since it may provide more accurate interpolation results by including more reference samples (N reference samples) during the interpolation. Statistically, using more reference samples will introduce better interpolation accuracy with higher complexity. The <i>N</i>-tap intra interpolation filter may include a sinc interpolation filter, a Gaussian interpolation filter and an interpolation filter derived<!-- EPO <DP n="48"> --> using an image correlation model. A sinc filter removes all frequency components above a given cutoff frequency, without affecting lower frequencies, and has linear phase response. Thus, the <i>N</i>-tap interpolation filter may comprise at least one of a sinc interpolation filter, a Gaussian interpolation filter and an interpolation filter derived using an image correlation model.</p>
<p id="p0131" num="0131">In this way, video encoder 20 may encode syntax information that indicates a selected intra prediction mode for the block of video data from among a plurality of intra prediction modes. For example, video encoder 20 may signal, in a bitstream, a mpm_idx or a rem_intra_luma_pred_mode syntax element for the current PU. Furthermore, video encoder 20 may apply an <i>N</i>-tap intra interpolation filter to neighboring reconstructed samples of the block of video data according to the selected intra prediction mode, where <i>N</i> is greater than 2. Video encoder 20 may apply the <i>N</i>-tap intra interpolation filter to determine filtered neighboring reconstructed samples that may correspond to positions between full-pel neighboring reconstructed samples. Video encoder 20 may encode the block of video data based on the filtered neighboring reconstructed samples according to the selected intra prediction mode. For instance, video encoder 20 may use the filtered neighboring reconstructed samples to generate a predictive block and generate residual data for the block of video data based on the predictive block.</p>
<p id="p0132" num="0132">In this example, the block of video data may be a current CU in a current picture of the video data and the selected intra prediction mode for the block of video data is a selected intra prediction mode for a current PU of the current CU. Furthermore, in this example, for each respective sample of a prediction block of the current PU, video encoder 20 may determine a fractional position between two neighboring reconstructed samples of a set of neighboring reconstructed samples by projecting, along a prediction direction associated with the selected intra prediction mode, a coordinate of the respective sample to a row or column of neighboring reconstructed samples containing the two neighboring reconstructed samples. The set of neighboring reconstructed samples including reconstructed samples above and left of the current PU in the current picture. Furthermore, video encoder 20 may calculate a value of the respective sample by applying an <i>N</i>-tap intra interpolation filter to neighboring reconstructed samples to interpolate a value at the determined fractional position, wherein N is greater than 2. As part of encoding the block of video data based on the filtered neighboring reconstructed<!-- EPO <DP n="49"> --> samples, video encoder 20 may generate residual data that represents pixel differences between the current CU and the predictive block. Video encoder 20 may transform and quantize the residual data and include, in a bitstream, entropy encoded syntax elements representing the resulting quantized transform coefficients.</p>
<p id="p0133" num="0133">Similarly, video decoder 30 may decode syntax information that indicates a selected intra prediction mode for the block of video data from among a plurality of intra prediction modes. For example, video decoder 30 may obtain, from a bitstream, a mpm idx or a rem_intra_luma_pred_mode syntax element. Furthermore, video decoder 30 may apply an <i>N</i>-tap intra interpolation filter to neighboring reconstructed samples of the block of video data according to the selected intra prediction mode, wherein N is greater than 2. Furthermore, video decoder 30 may reconstruct the block of video data based on the filtered neighboring reconstructed samples according to the selected intra prediction mode.</p>
<p id="p0134" num="0134">In this example, the block of video data may be a current CU in a current picture of the video data and the selected intra prediction mode for the block of video data is a selected intra prediction mode for a current PU of the current CU. In this example, for each respective sample of a predictive block of the current PU, video decoder 30 may determine a fractional position between two neighboring reconstructed samples of a set of neighboring reconstructed samples by projecting, along a prediction direction associated with the selected intra prediction mode, a coordinate of the respective sample to a row or column of neighboring reconstructed samples containing the two neighboring reconstructed samples. The set of neighboring reconstructed samples including reconstructed samples above and left of the current PU in the current picture. Video decoder 30 may calculate a prediction value of the respective sample by applying an N-tap intra interpolation filter to neighboring reconstructed samples to interpolate a value at the determined fractional position, wherein N is greater than 2. In this example, as part of reconstructing the block of video data (e.g., the current CU), video decoder 30 may reconstruct a coding block of the current CU using residual values by adding samples of the predictive blocks of PUs of the CU to corresponding samples of transform blocks of TUs of the current CU.</p>
<p id="p0135" num="0135">When the interpolation filter is derived using an image correlation model, an image correlation function based on Generalized Gaussian function may be applied, and the interpolation function for each fractional position is further derived using the least<!-- EPO <DP n="50"> --> mean square estimate. For example, when deriving the interpolation filter using an image correlation model, assuming the image correlation model is R(i,i) = ρ<sub>x</sub><sup>|i|</sup>·ρ<sub>y</sub><sup>|j|</sup>, where i and j indicates the distance between two image samples in the horizontal and vertical axis, ρ<sub>x</sub> is the image correlation factor in horizontal direction, ρ<sub>y</sub> is the image correlation factor in vertical direction, both ρ<sub>x</sub> and ρ<sub>y</sub> may be within the range of [0, 1], meaning that a larger image distance outputs a smaller correlation. In another example, assuming there are four samples, a, b, c and d, and the fractional sample e is to be interpolated. To derive a desirable interpolation filter [f0, f1, f2, f3], the interpolation process [a, b, c, d] * [f0 f1, f2, f3]<sup>T</sup> = [e] may be rewritten as A * F = E, where A = [a, b, c, d], F = [f0 f1, f2, f3]<sup>T</sup>, and E = [e]. According to a least mean square estimate, the optimal filter F is F* = (A<sup>T</sup>*A)<sup>-1</sup>*A<sup>T</sup>E, and "(A<sup>T</sup>*A)<sup>-1</sup>*A<sup>T</sup>E" may be determined by the assumed image correlation model. Therefore, using the image correlation model, the interpolation filter for each fractional sample may be derived using a least mean square estimate.</p>
<p id="p0136" num="0136">Thus, in some examples where a video coder derives the intra interpolation filter using an image correlation model, the video coder may apply an image correlation function based on Generalized Gaussian function. Additionally, the video coder may derive an interpolation function for each fractional position using a least mean square estimate.</p>
<p id="p0137" num="0137">In some examples, when a video coder applies a Gaussian interpolation filter, the parameter controlling the smoothing strength of the filter may vary depending on block size. Therefore, in such examples, the intra interpolation filter may comprise a Gaussian interpolation filter and a parameter controlling a smoothing strength of the Gaussian interpolation filter varies based on block sizes. For example, the Gaussian interpolation filter may be formulated as: <maths id="math0010" num=""><math display="block"><mi>G</mi><mfenced><mi>x</mi><mi>σ</mi></mfenced><mo>=</mo><mfrac><mn>1</mn><mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><mi>σ</mi></mrow></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mn>1</mn><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac></mrow></msup><mo>,</mo></math><img id="ib0010" file="imgb0010.tif" wi="41" he="9" img-content="math" img-format="tif"/></maths> <i>G</i>(<i>x, σ</i>)<i>,</i> x indicates the fractional position, and <i>σ</i> controls the smoothing strength. Therefore, a larger value of <i>σ</i> generates a Gaussian interpolation filter with increased smoothing strength.</p>
<p id="p0138" num="0138">Furthermore, in some examples, a video coder may select the interpolation filter to apply. In such examples, the selection of the filter may depend on the block sizes and or relative sample position inside the block. Therefore, in such examples, the video<!-- EPO <DP n="51"> --> coder may select the intra interpolation filter based on at least on of block size or relative sample position inside the block. For example, assuming a set of different interpolation filters have been designed, namely f1, f2, ... fy, different interpolation filters may be used for different pixel positions inside the current block. For example, interpolation filter f1 may be utilized for the first two rows of pixels inside the current block, and interpolation filter f2 may be utilized for the remaining rows of pixels.</p>
<p id="p0139" num="0139">Different interpolation filters may be available for intra prediction of a single block, and the selection of the interpolation filter may be explicitly signaled or derived from neighboring decoded information, including the reconstructed sample values and intra prediction modes. Thus, in such examples, the video coder may select the intra interpolation filter based on at least one of reconstructed sample values or intra prediction modes of neighboring blocks. For example, assuming a set of different interpolation filters have been designed, namely f1, f2, ... fy, different interpolation filters may be used for different intra prediction modes. For example, interpolation filter f1 may be utilized for the diagonal Intra prediction mode, and interpolation filter f2 may be utilized for the vertical Intra prediction mode.</p>
<p id="p0140" num="0140">In accordance with some examples of this disclosure, multiple intra prediction directions can be allowed for one PU without additional signaling of multiple intra prediction modes. For example, video decoder 30 may decode syntax information that indicates a selected intra prediction mode for a block of video data (e.g., a PU) from among a plurality of intra prediction modes. Furthermore, video decoder 30 may determine one or more additional intra prediction modes for the block without decoding additional syntax information indicting additional intra prediction modes. In this example, video decoder 30 may reconstruct the block of video data according to the selected intra prediction mode and the one or more additional intra prediction modes. For instance, video decoder 30 may reconstruct a CU containing the block based on residual data for the CU and a predictive block for the block generated based on the selected intra prediction mode and the one or more additional intra prediction modes.</p>
<p id="p0141" num="0141">In some examples where multiple intra prediction directions are allowed for one PU without additional signaling of multiple intra prediction modes, the PU comprises a plurality of sub-blocks and each sub-block within the PU may have its own intra prediction mode. In this example, a sub-block within a PU is a 4x4 block. In this way, in one example, as part of determining the one or more additional intra prediction modes<!-- EPO <DP n="52"> --> for the block of video data mentioned above, video decoder 30 may determine respective intra prediction modes for each of a plurality of sub-blocks of the block of video data without decoding additional syntax information indicating additional intra prediction modes. Furthermore, in this example, as part of reconstructing the block of video data, video decoder 30 may reconstruct the sub-blocks according to the respective determined intra prediction modes.</p>
<p id="p0142" num="0142">Furthermore, in some examples, the intra prediction direction for one sub-block can be derived as the intra prediction mode of the closest above or left reference block. In this way, as part of determining respective intra prediction modes for each of a plurality of sub-blocks of the block of video data, video decoder 30 may derive a respective intra prediction mode for at least one of the sub-blocks as an intra prediction mode of a closest above or left reference block. In some examples, for each sub-block of the current PU, the prediction is a weighted sum of two prediction directions, which come from the closest block in the above reference row and the left reference column. In this way, as part of determining respective intra prediction modes for each of a plurality of sub-blocks of the block of video data, video decoder 30 may derive a respective intra prediction mode for at least one of the sub-blocks based on one or both of an above reference block and a left reference block.</p>
<p id="p0143" num="0143">Similarly, as part of a process of encoding video data, video encoder 20 may encode syntax information that indicates a selected intra prediction mode for a block of video data (e.g., a PU) from among a plurality of intra prediction modes. Video encoder 20 may determine one or more additional intra prediction modes for the block of video data without encoding additional syntax information indicting additional intra prediction modes. Video encoder 20 may encode the block of video data according to the selected intra prediction mode and the one or more additional intra prediction modes. In some examples, as part of determining one or more additional intra prediction modes for the block of video data, video encoder 20 may determine respective intra prediction modes for each of a plurality of sub-blocks of the block of video data without encoding additional syntax information indicting additional intra prediction modes, and, as part of encoding the block of video data, video encoder 20 may encode the sub-blocks according to the respective determined intra prediction modes. In some examples, as part of determining respective intra prediction modes for each of a plurality of sub-blocks of the block of video data, video encoder 20 may derive a respective intra<!-- EPO <DP n="53"> --> prediction mode for at least one of the sub-blocks as an intra prediction mode of a closest above or left reference block. In some examples, as part of determining respective intra prediction modes for each of a plurality of sub-blocks of the block of video data, video encoder 20 may derive a respective intra prediction mode for at least one of the sub-blocks based on one or both of an above reference block and a left reference block.</p>
<p id="p0144" num="0144">As mentioned above, video encoder 20 may perform a process to decide which intra prediction mode to select for a PU. Because performing a full rate-distortion optimization process for all 35 available intra prediction modes in HEVC may be impractical in some instances, video encoder 20 may determine a list of <i>N</i> intra prediction mode candidates by checking intra prediction modes using a "Sum of Absolute Transform Difference" (SATD) criterion. When more than 35 intra prediction modes are available, as is the case in some examples of this disclosure, even checking the intra prediction modes using the SATD criterion may become excessively time consuming or resource intensive.</p>
<p id="p0145" num="0145">Hence, in accordance with an example of this disclosure, to reduce, e.g., largely reduce, the number of SATD checks for intra angular prediction at video encoder 20, a <i>K</i> stage SATD check scheme is proposed. In this example, <i>K</i> is greater than 2. In this example, for each stage of SATD check, only a selected number of intra prediction modes, which come from a pre-defined subset of intra prediction angles, may be checked with SATD cost. For instance, in a first stage of SATD check, video encoder 20 may check each of the intra prediction angles from the pre-defined subset of intra prediction modes with SATD cost, and may decide the best <i>N</i> intra prediction modes. In this example, <i>N</i> is a pre-defined constant value depending on the block size. After that, for each remaining stage of the SATD check, video encoder 20 only checks the intra prediction angles which are close, in terms of prediction angle difference, to the best <i>N</i> intra prediction modes decided in the previous stage with SATD cost, and video encoder 20 decides the best <i>N</i> intra prediction modes for the next stage.</p>
<p id="p0146" num="0146">In one example, when the proposed 65 angular modes are applied, video encoder 20 applies a two stage SATD check scheme to decide which of the intra prediction modes will be further examined with more efficient cost criterion (e.g., rate-distortion (R-D) cost) at the encoder side. In the first stage, video encoder 20 checks only the original 35 intra prediction modes as defined in HEVC, including Planar, DC and 33<!-- EPO <DP n="54"> --> angular modes, with SATD cost, then the best <i>N</i> (<i>N</i> can be the same as used in HEVC reference software) intra prediction modes are decided. In the second stage, video encoder 20 further checks only the intra angular modes which are the direct neighbors (angular mode index ±1) of, i.e., adjacent to, the best N angular modes with SATD cost. Video encoder 20 may decide to further check the final best <i>N</i> intra prediction modes with R-D cost.</p>
<p id="p0147" num="0147">Thus, in some examples, video encoder 20 may determine a respective SATD cost for encoding the block of video data according to each of a first subset of intra prediction modes. Additionally, video encoder 20 may determine a second subset of the intra prediction modes based on the determined SATD costs of the first subset of intra prediction modes. Video encoder 20 may determine a respective SATD cost for encoding the block of video data according to each of the second subset of intra prediction modes. Furthermore, video encoder 20 may select one of the intra prediction modes based on the determined SATD costs of the first and second subsets of intra prediction modes. Video encoder 20 may encode the block of video data according to the selected one of the intra prediction modes.</p>
<p id="p0148" num="0148">In this example, as part of determining the second subset of the intra prediction modes based on the determined SATD costs of the first subset of intra prediction modes comprises, video encoder 20 may identify <i>N</i> intra prediction modes of the first subset of intra prediction modes having a lowest <i>N</i> of the determined SATD costs. Video encoder 20 may include intra prediction modes having intra prediction angles proximate to intra prediction angles of the identified <i>N</i> intra prediction modes in the second subset of intra prediction modes. As part of including intra prediction modes having intra prediction angles proximate to intra prediction angles of the identified N intra prediction modes in the second subset of intra prediction modes, video encoder 20 may include intra prediction modes having intra prediction angles adjacent to intra prediction angles of the identified N intra prediction modes in the second subset of intra prediction modes.</p>
<p id="p0149" num="0149">Furthermore, in some examples, as part of selecting one of the intra prediction modes based on the determined SATD costs of the first and second subsets of intra prediction modes, video encoder 20 may identify <i>N</i> intra prediction modes of the first and second subsets of intra prediction modes having a lowest <i>N</i> of the determined SATD costs. In this example, video encoder 20 may determine a respective rate-distortion cost for each of the identified N intra prediction modes. Moreover, in this<!-- EPO <DP n="55"> --> example, video encoder 20 may select one of the identified N intra prediction modes based on the determined rate-distortion costs.</p>
<p id="p0150" num="0150">In the examples of this disclosure related to the SATD checks, the value of <i>N</i> depends on a block size of the block of video data. Furthermore, in some such examples, the first subset of intra prediction modes may include a Planar intra prediction mode, a DC intra prediction mode, and 33 angular prediction modes.</p>
<p id="p0151" num="0151">In some examples of this disclosure related to the SATD checks, the first and second subsets of intra prediction modes comprise first and second ones <i>of K</i> subsets of intra prediction modes and <i>K</i> is greater than or equal to 2. In such examples, for each current subset of the <i>K</i> subsets of intra prediction modes, video encoder 20 may determine a respective SATD cost for encoding the block of video data according to each intra prediction mode of the current subset of intra prediction modes. Additionally, video encoder 20 may determine a next subset of the <i>K</i> subsets of intra prediction modes based on the determined SATD costs of the current subset of intra prediction modes.</p>
<p id="p0152" num="0152"><figref idref="f0006">FIG. 6</figref> is a block diagram illustrating an example video encoder 20 that may implement the techniques of this disclosure. <figref idref="f0006">FIG. 6</figref> is provided for purposes of explanation and should not be considered limiting of the techniques as broadly exemplified and described in this disclosure. The techniques of this disclosure may be applicable to any of a variety of coding standards or methods.</p>
<p id="p0153" num="0153">In the example of <figref idref="f0006">FIG. 6</figref>, video encoder 20 includes a prediction processing unit 100, video data memory 101, a residual generation unit 102, a transform processing unit 104, a quantization unit 106, an inverse quantization unit 108, an inverse transform processing unit 110, a reconstruction unit 112, a filter unit 114, a decoded picture buffer 116, and an entropy encoding unit 118. Prediction processing unit 100 includes an inter-prediction processing unit 120 and an intra prediction processing unit 126. Inter-prediction processing unit 120 includes a motion estimation (ME) unit 122 and a motion compensation (MC) unit 124. In other examples, video encoder 20 may include more, fewer, or different functional components.</p>
<p id="p0154" num="0154">Video data memory 101 may store video data to be encoded by the components of video encoder 20. The video data stored in video data memory 101 may be obtained, for example, from video source 18. Decoded picture buffer 116 may be a reference picture memory that stores reference video data for use in encoding video data by video<!-- EPO <DP n="56"> --> encoder 20, e.g., in intra- or inter-coding modes. Video data memory 101 and decoded picture buffer 116 may be formed by any of a variety of memory devices, such as dynamic random access memory (DRAM), including synchronous DRAM (SDRAM), magnetoresistive RAM (MRAM), resistive RAM (RRAM), or other types of memory devices. Video data memory 101 and decoded picture buffer 116 may be provided by the same memory device or separate memory devices.</p>
<p id="p0155" num="0155">Video encoder 20 may receive video data. Video encoder 20 may encode each CTU in a slice of a picture of the video data. Each of the CTUs may be associated with equally-sized luma coding tree blocks (CTBs) and corresponding CTBs of the picture. As part of encoding a CTU, prediction processing unit 100 may perform quad-tree partitioning to divide the CTBs of the CTU into progressively-smaller blocks. The smaller blocks may be coding blocks of CUs. For example, prediction processing unit 100 may partition a CTB associated with a CTU into four equally-sized sub-blocks, partition one or more of the sub-blocks into four equally-sized sub-sub-blocks, and so on.</p>
<p id="p0156" num="0156">Video encoder 20 may encode CUs of a CTU to generate encoded representations of the CUs (i.e., coded CUs). As part of encoding a CU, prediction processing unit 100 may partition the coding blocks associated with the CU among one or more PUs of the CU. Thus, each PU may be associated with a luma prediction block and corresponding chroma prediction blocks. Video encoder 20 and video decoder 30 may support PUs having various sizes. As indicated above, the size of a CU may refer to the size of the luma coding block of the CU and the size of a PU may refer to the size of a luma prediction block of the PU. Assuming that the size of a particular CU is 2Nx2N, video encoder 20 and video decoder 30 may support PU sizes of 2Nx2N or NxN for intra prediction, and symmetric PU sizes of 2Nx2N, 2NxN, Nx2N, NxN, or similar for inter prediction. Video encoder 20 and video decoder 30 may also support asymmetric partitioning for PU sizes of 2NxnU, 2NxnD, nLx2N, and nRx2N for inter prediction.</p>
<p id="p0157" num="0157">Inter-prediction processing unit 120 may generate predictive data for a PU by performing inter prediction on each PU of a CU. The predictive data for the PU may include predictive blocks of the PU and motion information for the PU. Intra prediction processing unit 126 may generate predictive data for a PU by performing intra prediction on the PU. The predictive data for the PU may include predictive blocks for<!-- EPO <DP n="57"> --> the PU and various syntax elements. Intra prediction processing unit 126 may perform intra prediction on PUs in I slices, P slices, and B slices.</p>
<p id="p0158" num="0158">To perform intra prediction on a PU, intra prediction processing unit 126 may use multiple intra prediction modes to generate multiple sets of predictive blocks for the PU. When performing intra prediction using a particular intra prediction mode, intra prediction processing unit 126 may generate predictive blocks for the PU using a particular set of samples from neighboring blocks. The neighboring blocks may be above, above and to the right, above and to the left, or to the left of the prediction blocks of the PU, assuming a left-to-right, top-to-bottom encoding order for PUs, CUs, and CTUs. Intra prediction processing unit 126 may use various numbers of intra prediction modes, e.g., DC, planar, or directional/angular prediction modes, as described herein. In some examples, the number of intra prediction modes may depend on the size of the prediction blocks of the PU.</p>
<p id="p0159" num="0159">Prediction processing unit 100 may select the predictive data for PUs of a CU from among the predictive data generated by inter-prediction processing unit 120 for the PUs or the predictive data generated by intra prediction processing unit 126 for the PUs. In some examples, prediction processing unit 100 selects the predictive data for the PUs of the CU based on rate/distortion metrics of the sets of predictive data. The predictive blocks of the selected predictive data may be referred to herein as the selected predictive blocks.</p>
<p id="p0160" num="0160">Residual generation unit 102 may generate, based on the luma, Cb and Cr coding block of a CU and the selected predictive luma, Cb and Cr blocks of the PUs of the CU, luma, Cb and Cr residual blocks of the CU. For instance, residual generation unit 102 may generate the residual blocks of the CU such that each sample in the residual blocks has a value equal to a difference between a sample in a coding block of the CU and a corresponding sample in a corresponding selected predictive block of a PU of the CU.</p>
<p id="p0161" num="0161">Transform processing unit 104 may perform quad-tree partitioning to partition the residual blocks of a CU into transform blocks associated with TUs of the CU. Thus, a TU may be associated with a luma transform block and two corresponding chroma transform blocks. The sizes and positions of the luma and chroma transform blocks of TUs of a CU may or may not be based on the sizes and positions of prediction blocks of the PUs of the CU.<!-- EPO <DP n="58"> --></p>
<p id="p0162" num="0162">Transform processing unit 104 may generate transform coefficient blocks for each TU of a CU by applying one or more transforms to the transform blocks of the TU. Transform processing unit 104 may apply various transforms to a transform block associated with a TU. For example, transform processing unit 104 may apply a discrete cosine transform (DCT), a directional transform, or a conceptually-similar transform to a transform block. In some examples, transform processing unit 104 does not apply transforms to a transform block. In such examples, the transform block may be treated as a transform coefficient block.</p>
<p id="p0163" num="0163">Quantization unit 106 may quantize the transform coefficients in a coefficient block. The quantization process may reduce the bit depth associated with some or all of the transform coefficients. For example, an <i>n</i>-bit transform coefficient may be rounded down to an <i>m</i>-bit transform coefficient during quantization, where <i>n</i> is greater than <i>m.</i> Quantization unit 106 may quantize a coefficient block associated with a TU of a CU based on a quantization parameter (QP) value associated with the CU. Video encoder 20 may adjust the degree of quantization applied to the coefficient blocks associated with a CU by adjusting the QP value associated with the CU. Quantization may introduce loss of information, thus quantized transform coefficients may have lower precision than the original ones.</p>
<p id="p0164" num="0164">Inverse quantization unit 108 and inverse transform processing unit 110 may apply inverse quantization and inverse transforms to a coefficient block, respectively, to reconstruct a residual block from the coefficient block. Reconstruction unit 112 may add the reconstructed residual block to corresponding samples from one or more predictive blocks generated by prediction processing unit 100 to produce a reconstructed transform block associated with a TU. By reconstructing transform blocks for each TU of a CU in this way, video encoder 20 may reconstruct the coding blocks of the CU.</p>
<p id="p0165" num="0165">Filter unit 114 may perform one or more deblocking operations to reduce blocking artifacts in the coding blocks associated with a CU. Decoded picture buffer 116 may store the reconstructed coding blocks after filter unit 114 performs the one or more deblocking operations on the reconstructed coding blocks. Inter-prediction processing unit 120 may use a reference picture that contains the reconstructed coding blocks to perform inter prediction on PUs of other pictures. In addition, intra prediction processing unit 126 may use reconstructed coding blocks in decoded picture buffer 116 to perform intra prediction on other PUs in the same picture as the CU.<!-- EPO <DP n="59"> --></p>
<p id="p0166" num="0166">Entropy encoding unit 118 may receive data from other functional components of video encoder 20. For example, entropy encoding unit 118 may receive coefficient blocks from quantization unit 106 and may receive syntax elements from prediction processing unit 100. Entropy encoding unit 118 may perform one or more entropy encoding operations on the data to generate entropy-encoded data. For example, entropy encoding unit 118 may perform a context-adaptive variable length coding (CAVLC) operation, a CABAC operation, a variable-to-variable (V2V) length coding operation, a syntax-based context-adaptive binary arithmetic coding (SBAC) operation, a Probability interval Partitioning Entropy (PIPE) coding operation, an Exponential-Golomb encoding operation, or another type of entropy encoding operation on the data. Video encoder 20 may output a bitstream that includes entropy-encoded data generated by entropy encoding unit 118.</p>
<p id="p0167" num="0167">Video encoder 20 is an example of a video encoder configured to perform any of the techniques described in this disclosure. In accordance with one or more techniques of this disclosure, one or more units within video encoder 20 may perform the techniques described herein as part of a video encoding process. For example, intra prediction processing unit 126 and/or entropy encoding unit 118, may be configured to perform the techniques described herein as part of a video encoding process. In some examples, intra prediction processing unit 126 may be configured to perform the techniques described herein for deriving or selecting intra prediction modes and/or MPMs for intra prediction, the techniques using an increased number of MPMs and/or angular modes, and the techniques for applying an N-tap intra interpolation filter, where N is larger than 2. Intra prediction processing unit 126 may be configured to perform the techniques described herein for allowing multiple Intra prediction directions per block, e.g. respective directions for sub-blocks of the block, which may not require additional signaling of multiple intra prediction modes.</p>
<p id="p0168" num="0168">Intra prediction processing unit 126 may provide syntax information to entropy encoding unit 118, such as a selected intra prediction mode and/or MPM index for intra prediction. Intra prediction processing unit 126 and/or entropy encoding unit 118 may be configured to implement the techniques described herein for encoding or signaling the syntax information related to intra prediction, e.g., the selected intra prediction mode and/or MPM index for intra prediction, in an encoded video bitstream, which may be decoded by video decoder 30.<!-- EPO <DP n="60"> --></p>
<p id="p0169" num="0169"><figref idref="f0007">FIG. 7</figref> is a block diagram illustrating an example video decoder 30 that is configured to implement the techniques of this disclosure. <figref idref="f0007">FIG. 7</figref> is provided for purposes of explanation and is not limiting on the techniques as broadly exemplified and described in this disclosure. The techniques of this disclosure may be applicable to a variety of coding standards or methods.</p>
<p id="p0170" num="0170">In the example of <figref idref="f0007">FIG. 7</figref>, video decoder 30 includes an entropy decoding unit 150, video data memory 151, a prediction processing unit 152, an inverse quantization unit 154, an inverse transform processing unit 156, a reconstruction unit 158, a filter unit 160, and a decoded picture buffer 162. Prediction processing unit 152 includes a motion compensation unit 164 and an intra prediction processing unit 166. In other examples, video decoder 30 may include more, fewer, or different functional components.</p>
<p id="p0171" num="0171">Video data memory 151 may store video data, such as an encoded video bitstream, to be decoded by the components of video decoder 30. The video data stored in video data memory 151 may be obtained, for example, from computer-readable medium 16, e.g., from a local video source, such as a camera, via wired or wireless network communication of video data, or by accessing physical data storage media. Video data memory 151 may form a coded picture buffer (CPB) that stores encoded video data from an encoded video bitstream. Decoded picture buffer 162 may be a reference picture memory that stores reference video data for use in decoding video data by video decoder 30, e.g., in intra- or inter-coding modes. Video data memory 151 and decoded picture buffer 162 may be formed by any of a variety of memory devices, such as dynamic random access memory (DRAM), including synchronous DRAM (SDRAM), magnetoresistive RAM (MRAM), resistive RAM (RRAM), or other types of memory devices. Video data memory 151 and decoded picture buffer 162 may be provided by the same memory device or separate memory devices.</p>
<p id="p0172" num="0172">A coded picture buffer (CPB) formed by video data memory 151 may receive and store encoded video data (e.g., NAL units) of a bitstream. Entropy decoding unit 150 may receive NAL units from CPB formed by video data memory 151 and parse the NAL units to obtain syntax elements from the bitstream. Entropy decoding unit 150 may entropy decode entropy-encoded syntax elements in the NAL units. Prediction processing unit 152, inverse quantization unit 154, inverse transform processing unit<!-- EPO <DP n="61"> --> 156, reconstruction unit 158, and filter unit 160 may generate decoded video data based on the syntax elements extracted from the bitstream.</p>
<p id="p0173" num="0173">The NAL units of the bitstream may include coded slice NAL units. As part of decoding the bitstream, entropy decoding unit 150 may extract and entropy decode syntax elements from the coded slice NAL units. Each of the coded slices may include a slice header and slice data. The slice header may contain syntax elements pertaining to a slice.</p>
<p id="p0174" num="0174">In addition to decoding syntax elements from the bitstream, video decoder 30 may perform a decoding operation on a CU. By performing the decoding operation on a CU, video decoder 30 may reconstruct coding blocks of the CU.</p>
<p id="p0175" num="0175">As part of performing a decoding operation on a CU, inverse quantization unit 154 may inverse quantize, i.e., de-quantize, coefficient blocks associated with TUs of the CU. Inverse quantization unit 154 may use a QP value associated with the CU of the TU to determine a degree of quantization and, likewise, a degree of inverse quantization for inverse quantization unit 154 to apply. That is, the compression ratio, i.e., the ratio of the number of bits used to represent original sequence and the compressed one, may be controlled by adjusting the value of the QP used when quantizing transform coefficients. The compression ratio may also depend on the method of entropy coding employed.</p>
<p id="p0176" num="0176">After inverse quantization unit 154 inverse quantizes a coefficient block, inverse transform processing unit 156 may apply one or more inverse transforms to the coefficient block in order to generate a residual block associated with the TU. For example, inverse transform processing unit 156 may apply an inverse DCT, an inverse integer transform, an inverse Karhunen-Loeve transform (KLT), an inverse rotational transform, an inverse directional transform, or another inverse transform to the coefficient block.</p>
<p id="p0177" num="0177">If a PU is encoded using intra prediction, intra prediction processing unit 166 may perform intra prediction to generate predictive blocks for the PU. Intra prediction processing unit 166 may use an intra prediction mode to generate the predictive luma, Cb, and Cr blocks for the PU based on reconstructed sample values of spatially-neighboring blocks. Intra prediction processing unit 166 may determine the intra prediction mode for the PU based on one or more syntax elements decoded from the bitstream.<!-- EPO <DP n="62"> --></p>
<p id="p0178" num="0178">Prediction processing unit 152 may construct a first reference picture list (RefPicListO) and a second reference picture list (RefPicList1) based on syntax elements extracted from the bitstream. Furthermore, if a PU is encoded using inter prediction, entropy decoding unit 150 may obtain motion information for the PU. Motion compensation unit 164 may determine, based on the motion information of the PU, one or more reference regions for the PU. Motion compensation unit 164 may generate, based on samples at the one or more reference blocks for the PU, predictive luma, Cb, and Cr blocks for the PU.</p>
<p id="p0179" num="0179">Reconstruction unit 158 may use the residual values from the luma, Cb, and Cr transform blocks associated with TUs of a CU and the predictive luma, Cb, and Cr blocks of the PUs of the CU, i.e., either intra prediction data or inter-prediction data, as applicable, to reconstruct the luma, Cb, and Cr coding blocks of the CU. For example, reconstruction unit 158 may add samples of the luma, Cb, and Cr transform blocks to corresponding samples of the predictive luma, Cb, and Cr blocks to reconstruct the luma, Cb, and Cr coding blocks of the CU.</p>
<p id="p0180" num="0180">Filter unit 160 may perform a deblocking operation to reduce blocking artifacts associated with the luma, Cb, and Cr coding blocks of the CU. Video decoder 30 may store the luma, Cb, and Cr coding blocks of the CU in decoded picture buffer 162. Decoded picture buffer 162 may provide reference pictures for subsequent motion compensation, intra prediction, and presentation on a display device, such as display device 32 of <figref idref="f0001">FIG. 1</figref>. For instance, video decoder 30 may perform, based on the luma, Cb, and Cr blocks in decoded picture buffer 162, intra prediction or inter prediction operations on PUs of other CUs. In this way, video decoder 30 may extract, from the bitstream, transform coefficient levels of the significant luma coefficient block, inverse quantize the transform coefficient levels, apply a transform to the transform coefficient levels to generate a transform block, generate, based at least in part on the transform block, a coding block, and output the coding block for display.</p>
<p id="p0181" num="0181">Video decoder 30 is an example of a video decoder configured to perform any of the techniques described in this disclosure. In accordance with one or more techniques of this disclosure, one or more units within video decoder 30 may perform the techniques described herein as part of a video decoding process. For example, intra prediction processing unit 166 and/or entropy decoding unit 150 may be configured to perform the techniques described herein as part of a video decoding process. In some<!-- EPO <DP n="63"> --> examples, intra prediction processing unit 166 may be configured to perform the techniques described herein for deriving or selecting intra prediction modes and/or MPMs for intra prediction, the techniques using an increased number of MPMs and/or angular modes, and the techniques for applying an N-tap Intra interpolation filter, where N is larger than 2. Intra prediction processing unit 166 may be configured to perform the techniques described herein for allowing multiple intra prediction directions per block, e.g. respective directions for sub-blocks of the block, which may not require additional signaling of multiple intra prediction modes.</p>
<p id="p0182" num="0182">Intra prediction processing unit 166 may receive syntax information from entropy decoding unit 150, such as a selected intra prediction mode and/or MPM index for intra prediction. Intra prediction processing unit 166 and/or entropy decoding unit 150 may be configured to implement the techniques described herein for decoding the syntax information related to intra prediction, e.g., the selected intra prediction mode and/or MPM index for intra prediction, from an encoded video bitstream.</p>
<p id="p0183" num="0183">In following subsections, examples implementations of particular techniques of this disclosure are be provided. In practice, any combination of any part of the examples may be used as a new example. The example implementations are shown in the form of edits to the JCTVC-N1003. In the following, text added to JCTVC-N1003 is shown between tags &lt;ins&gt; and &lt;/ins&gt;, "ins" being short for "insert". Text deleted from JCTVC-N1003 is shown between tags &lt;dlt&gt; and &lt;/dlt&gt;, "dlt" being short for "delete."</p>
<p id="p0184" num="0184">Several examples were described above in which video encoder 20 and video decoder 30 use more than three MPMs for signaling an intra prediction mode of a PU. In some such examples, video encoder 20 and video decoder 30 use CABAC coding to encode and decode MPM indexes. As part of CABAC encoding, video encoder 20 applies a binarization process to an MPM index to convert the MPM index into a binary code and video decoder 30 de-binarizes the binary code to recover the MPM index. In accordance with a technique of this disclosure, as shown in Table 9-32 below, the MPM index (mpm_idx) is binarized using a truncated Rice binarization process (TR) and the input parameter cMax is changed from 2 to 5 to accommodate larger values of the MPM index. Section 9.3.3.2 of JCTVC-N1003 describes an implementation of the Truncated Rice binarization process.<!-- EPO <DP n="64"> -->
<tables id="tabl0002" num="0002">
<table frame="all">
<title><b>Table 9-32 - Syntax elements and associated binarizations</b></title>
<tgroup cols="3">
<colspec colnum="1" colname="col1" colwidth="51mm"/>
<colspec colnum="2" colname="col2" colwidth="27mm"/>
<colspec colnum="3" colname="col3" colwidth="74mm"/>
<thead>
<row>
<entry morerows="1" align="center" valign="top"><b>Syntax element</b></entry>
<entry namest="col2" nameend="col3" align="center" valign="top"><b>Binarization</b></entry></row>
<row>
<entry align="center" valign="top"><b>Process</b></entry>
<entry align="center" valign="top"><b>Input parameters</b></entry></row></thead>
<tbody>
<row>
<entry>...</entry>
<entry>...</entry>
<entry>...</entry></row>
<row>
<entry>cu_transquant_bypass_flag</entry>
<entry>FL</entry>
<entry valign="middle">cMax = 1</entry></row>
<row>
<entry>cu_skip_flag</entry>
<entry>FL</entry>
<entry valign="middle">cMax = 1</entry></row>
<row>
<entry>pred_mode_flag</entry>
<entry>FL</entry>
<entry valign="middle">cMax = 1</entry></row>
<row>
<entry>part_mode</entry>
<entry>9.3.3.5</entry>
<entry valign="middle">(xCb, yCb) = (x0, y0), log2CbSize</entry></row>
<row>
<entry>pcm_flag[ ][ ]</entry>
<entry>FL</entry>
<entry valign="middle">cMax = 1</entry></row>
<row>
<entry>prev_intra_luma_pred _flag[ ][ ]</entry>
<entry>FL</entry>
<entry valign="middle">cMax = 1</entry></row>
<row>
<entry>mpm_idx[ ][ ]</entry>
<entry>TR</entry>
<entry valign="middle">cMax = &lt;dlt&gt;2&lt;/dlt&gt;&lt;ins&gt;5&lt;/ins&gt;, cRiceParam = 0</entry></row>
<row>
<entry>rem_intra_luma_pred _mode[ ][ ]</entry>
<entry>FL</entry>
<entry valign="middle">cMax = 31</entry></row>
<row>
<entry>intra_chroma_pred_m ode[ ][ ]</entry>
<entry>9.3.3.6</entry>
<entry valign="middle">-</entry></row>
<row>
<entry>rqt_root_cbf</entry>
<entry>FL</entry>
<entry valign="middle">cMax = 1</entry></row></tbody></tgroup>
</table>
</tables></p>
<p id="p0185" num="0185">Furthermore, as described above, video encoder 20 and video decoder 30 may use context modeling when coding (e.g., CABAC coding) one or more bins of an MPM index. In JCTVC-N1003, a binarized MPM index (i.e., mpm_idx) consists of three bins. However, in this disclosure, with larger numbers of MPMs, the binarized MPM index may include five or more bins. As specified in subclause 9.3.4.2.1 of JCTVC-N1003, a variable ctxlnc is specified by the corresponding entry in Table 9-37 and when more than one value is listed in Table 9-37 for a binldx, the assignment process for ctxlnc for that binldx is further specified in the subclauses given in parenthesis. As further described in subclause 9.3.4.2.1. of JCTVC-N1003, ctxlnc is used to determine a value of ctxldx, which is an index of a coding context. As shown in the edited version of Table 9-37 below, the first three bins of the MPM index may be coded using coding contexts selected using the context modeling methods of the added subclause 9.3.4.x.x below and remaining bins of the MPM index may be coded using bypass coding.<!-- EPO <DP n="65"> -->
<tables id="tabl0003" num="0003">
<table frame="all">
<title><b>Table 9-37 - Assignment of ctxInc to syntax elements with context coded bins</b></title>
<tgroup cols="7">
<colspec colnum="1" colname="col1" colwidth="20mm"/>
<colspec colnum="2" colname="col2" colwidth="30mm"/>
<colspec colnum="3" colname="col3" colwidth="30mm"/>
<colspec colnum="4" colname="col4" colwidth="30mm"/>
<colspec colnum="5" colname="col5" colwidth="20mm"/>
<colspec colnum="6" colname="col6" colwidth="20mm"/>
<colspec colnum="7" colname="col7" colwidth="20mm"/>
<thead>
<row>
<entry morerows="1" align="center" valign="middle"><b>Syntax element</b></entry>
<entry namest="col2" nameend="col7" align="center" valign="middle"><b>binIdx</b></entry></row>
<row>
<entry align="center" valign="middle"><b>0</b></entry>
<entry align="center" valign="middle"><b>1</b></entry>
<entry align="center" valign="middle"><b>2</b></entry>
<entry align="center" valign="middle"><b>3</b></entry>
<entry align="center" valign="middle"><b>4</b></entry>
<entry align="center" valign="middle"><b>&gt;= 5</b></entry></row></thead>
<tbody>
<row>
<entry>...</entry>
<entry align="center">...</entry>
<entry align="center">...</entry>
<entry align="center">...</entry>
<entry align="center">...</entry>
<entry align="center">...</entry>
<entry align="center">...</entry></row>
<row>
<entry>pcm_flag[ ][ ]</entry>
<entry align="center">terminate</entry>
<entry align="center">na</entry>
<entry align="center">na</entry>
<entry align="center">na</entry>
<entry align="center">na</entry>
<entry align="center">na</entry></row>
<row>
<entry valign="middle">prev_intra_luma_pr ed_flag[ ][ ]</entry>
<entry align="center" valign="middle">0</entry>
<entry align="center" valign="middle">na</entry>
<entry align="center" valign="middle">Na</entry>
<entry align="center" valign="middle">na</entry>
<entry align="center" valign="middle">na</entry>
<entry align="center" valign="middle">na</entry></row>
<row>
<entry>mpm_idx[ ][ ]</entry>
<entry align="center">&lt;dlt&gt; bypass &lt;/dlt&gt; &lt;ins&gt;0,1,2 (subclause 9. 3.4.x.x) &lt;/ins&gt;</entry>
<entry align="center">&lt;del&gt; bypass &lt;/del&gt; &lt;ins&gt;3,4,5 (subclause 9.3.4.x.x) &lt;/ins&gt;</entry>
<entry align="center">&lt;del&gt; bypass &lt;/del&gt; &lt;ins&gt;7,8 (subclause 9.3.4.x.x) &lt;/ins&gt;</entry>
<entry align="center">&lt;dlt&gt; na &lt;/dlt&gt; &lt;ins&gt; bypass &lt;/ins&gt;</entry>
<entry align="center">&lt;dlt&gt; na &lt;/dlt&gt; &lt;ins&gt; bypass &lt;/ins&gt;</entry>
<entry align="center">&lt;dlt&gt; na &lt;/dlt&gt; &lt;ins&gt; bypass &lt;/ins&gt;</entry></row>
<row>
<entry valign="middle">rem_intra_luma_pr ed_mode[ ][ ]</entry>
<entry align="center" valign="middle">bypass</entry>
<entry align="center" valign="middle">bypass</entry>
<entry align="center" valign="middle">bypass</entry>
<entry align="center" valign="middle">bypass</entry>
<entry align="center" valign="middle">bypass</entry>
<entry align="center" valign="middle">bypass</entry></row>
<row>
<entry valign="middle">intra_chroma_pred _mode[ ][ ]</entry>
<entry align="center" valign="middle">0</entry>
<entry align="center" valign="middle">bypass</entry>
<entry align="center" valign="middle">bypass</entry>
<entry align="center" valign="middle">na</entry>
<entry align="center" valign="middle">na</entry>
<entry align="center" valign="middle">na</entry></row>
<row>
<entry valign="middle">...</entry>
<entry align="center" valign="middle">...</entry>
<entry align="center" valign="middle">...</entry>
<entry align="center" valign="middle">...</entry>
<entry align="center" valign="middle">...</entry>
<entry align="center" valign="middle">...</entry>
<entry align="center" valign="middle">...</entry></row></tbody></tgroup>
</table>
</tables></p>
<p id="p0186" num="0186">&lt;ins&gt;<b>9.3.3.x Binarization process for rem_intra_luma_pred_mode</b> Input to this process is a request for a binarization for the syntax element rem_intra_luma_pred_mode.</p>
<p id="p0187" num="0187">Output of this process is the binarization of the syntax element.
<ul id="ul0008" list-style="dash">
<li>If rem_intra_luma_pred_mode equals to 28, the binarization string is "111";</li>
<li>Otherwise, the binarization is fixed-length code with 5 bins.</li>
</ul><!-- EPO <DP n="66"> --></p>
<heading id="h0006"><b>9.3.4.x.x Derivation process of ctxInc for the syntax element mpm_idx</b></heading>
<p id="p0188" num="0188">Inputs to this process are the intra modes of the left neighboring block candIntraPredModeA, and the above neighboring block candIntraPredModeB.</p>
<p id="p0189" num="0189">Output of this process is the variable ctxlnc.</p>
<p id="p0190" num="0190">The variable csbfCtx is derived using the current location (xS, yS), two previously decoded bins of the syntax element coded_sub_block_flag in scan order, and the transform block size log2TrafoSize, as follows:
<ul id="ul0009" list-style="dash">
<li>When candIntraPredModeA equals to candIntraPredModeB, ctxlnc is derived as follows<br/>
ctxlnc = candIntraPredModeA &gt; 1 ? 0 : 1</li>
<li>Otherwise<br/>
ctxlnc = (candIntraPredModeA &amp;&amp; candIntraPredModeB)? 2 : 3&lt;/ins&gt;</li>
</ul></p>
<p id="p0191" num="0191">In accordance with some examples of this disclosure, more than three MPMs are defined. The following text describes example changes to JCTVC-N1003 to implement six MPMs.</p>
<heading id="h0007"><b>8.4.2 Derivation process for luma intra prediction mode</b></heading>
<p id="p0192" num="0192">Input to this process is a luma location (xPb, yPb) specifying the top-left sample of the current luma prediction block relative to the top-left luma sample of the current picture&lt;ins&gt;, a prediction block size nPbS&lt;/ins&gt;.</p>
<p id="p0193" num="0193">In this process, the luma intra prediction mode IntraPredModeY[xPb][yPb] is derived. Table 8-1 specifies the value for the intra prediction mode and the associated names.<!-- EPO <DP n="67"> -->
<tables id="tabl0004" num="0004">
<table frame="all">
<title><b>Table 8-1 - Specification of intra prediction mode and associated names</b></title>
<tgroup cols="2">
<colspec colnum="1" colname="col1" colwidth="48mm"/>
<colspec colnum="2" colname="col2" colwidth="66mm"/>
<thead>
<row>
<entry align="center" valign="top"><b>Intra prediction mode</b></entry>
<entry align="center" valign="top"><b>Associated name</b></entry></row></thead>
<tbody>
<row>
<entry align="center">0</entry>
<entry>INTRA_PLANAR</entry></row>
<row>
<entry align="center">1</entry>
<entry>INTRA_DC</entry></row>
<row>
<entry align="center">2..34</entry>
<entry>INTRA_ANGULAR2..INTRA_ANGULAR34</entry></row></tbody></tgroup>
</table>
</tables></p>
<p id="p0194" num="0194">IntraPredModeY[xPb][yPb] labelled 0..34 represents directions of predictions as illustrated in <figref idref="f0008">Figure 8-1</figref>, which is <figref idref="f0008">FIG. 8</figref> of this disclosure.<br/>
IntraPredModeY[xPb][yPb] is derived by the following ordered steps:
<ul id="ul0010" list-style="none" compact="compact">
<li>4. The neighbouring locations (xNbA, yNbA) and (xNbB, yNbB) are set equal to (xPb - 1, yPb) and (xPb, yPb - 1), respectively.</li>
<li>5. For X being replaced by either A or B, the variables candIntraPredModeX are derived as follows:<br/>
&lt;ins&gt;
<ul id="ul0011" list-style="dash" compact="compact">
<li><u>candIntraPredModeX is initialized as INTRA_DC.</u></li>
<li><u>Initialize the counts of intra mode usage as 0: cntIntraPredModeX[i]=0, i=0, 1, ...,34</u></li>
<li><u>Initalize the maximum count of intra mode usage as 0:</u><br/>
<u>cntMaxIntraPredModeX = 0;</u></li>
<li><u>For x = 0..nPbS</u> - <u>1, the following applies</u>
<ul id="ul0012" list-style="dash" compact="compact">
<li><u>(xCurr, yCurr) = (X==A) ? (xNbA+x, yNbA) ? (xNbA, yNbA +x)</u></li>
<li><u>The availability derivation process for a block in z-scan order as specified in subclause 6.4.1 is invoked with the location (xCurr, yCurr</u>) <u>set equal to (xPb, yPb) and the neighbouring location (xNbY, yNbY) set equal to (xNbX, yNbX) as inputs, and the output is assigned to availableX.</u></li>
<li><u>If availableX is equal to TRUE and CuPredMode[xNbX][yNbX] 1 is equal to MODE INTRA, the following applies.</u>
<ul id="ul0013" list-style="dash" compact="compact">
<li><u>cntIntraPredModeX[CuPredMode[xCurr][yCurr]] ++</u><!-- EPO <DP n="68"> --></li>
<li><u>if cntIntraPredModeX[CuPredMode[xCurr][yCurr]] &gt; cntMaxIntraPredModeX, the following applies:</u>
<ul id="ul0014" list-style="dash" compact="compact">
<li><u>cntMaxIntraPredModeX = cntIntraPredModeX[CuPredMode[xCurr][yCurr]];</u></li>
<li><u>candIntraPredModeX = CuPredMode[xCurr][yCurr]</u><br/>
<u>&lt;/ins&gt;</u></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
&lt;dlt&gt;
<ul id="ul0015" list-style="dash" compact="compact">
<li>The availability derivation process for a block in z-scan order as specified in subclause 6.4.1 is invoked with the location (xCurr, yCurr) set equal to (xPb, yPb) and the neighbouring location (xNbY, yNbY) set equal to (xNbX, yNbX) as inputs, and the output is assigned to availableX.</li>
<li>The candidate intra prediction mode candIntraPredModeX is derived as follows:
<ul id="ul0016" list-style="dash" compact="compact">
<li>If availableX is equal to FALSE, candIntraPredModeX is set equal to INTRA_DC.</li>
<li>Otherwise, if CuPredMode[xNbX][yNbX] is not equal to MODE_INTRA or pcm_flag[xNbX][yNbX] is equal to 1, candIntraPredModeX is set equal to INTRA_DC,</li>
<li>Otherwise, if X is equal to B and yPb - 1 is less than ((yPb &gt;&gt; CtbLog2SizeY) &lt;&lt; CtbLog2SizeY), candIntraPredModeB is set equal to INTRA_DC.</li>
<li>Otherwise, candIntraPredModeX is set equal to IntraPredModeY[xNbX][yNbX].&lt;/dlt&gt;</li>
</ul></li>
</ul></li>
<li>6. The candModeList[x] with x = 0..&lt;dlt&gt; 2&lt;/dlt&gt;&lt;ins&gt;5&lt;/ins&gt; is derived as follows:
<ul id="ul0017" list-style="dash" compact="compact">
<li><u>&lt;ins&gt; idxPlanar is set as 0, idxDC is set as 1;&lt;/ins&gt;</u></li>
<li>If candIntraPredModeB is equal to candIntraPredModeA, the following applies:
<ul id="ul0018" list-style="dash" compact="compact">
<li>If candIntraPredModeA is less than 2 (i.e. equal to INTRA_PLANAR or INTRA DC), candModeList[x] with x = 0..&lt;dlt&gt;2&lt;/dlt&gt;&lt;ins&gt;5&lt;/ins&gt; is derived as follows: <maths id="math0011" num="(8-15)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>0</mn></mfenced><mo>=</mo><mi>INTRA_PLANAR</mi></math><img id="ib0011" file="imgb0011.tif" wi="122" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0012" num="(8-16)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>1</mn></mfenced><mo>=</mo><mi>INTRA_DC</mi></math><img id="ib0012" file="imgb0012.tif" wi="122" he="5" img-content="math" img-format="tif"/></maths><!-- EPO <DP n="69"> --> <maths id="math0013" num="(8-17)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>2</mn></mfenced><mo>=</mo><mi>INTRA</mi><mo>_</mo><mi>ANGULAR</mi><mn>26</mn></math><img id="ib0013" file="imgb0013.tif" wi="124" he="7" img-content="math" img-format="tif"/></maths> <maths id="math0014" num="(8-17)"><math display="block"><mo>&lt;</mo><mi>ins</mi><mo>&gt;</mo><mi>candModeList</mi><mfenced open="[" close="]"><mn>3</mn></mfenced><mo>=</mo><mi>INTRA</mi><mo>_</mo><mi>ANGULAR</mi><mn>10</mn></math><img id="ib0014" file="imgb0014.tif" wi="123" he="6" img-content="math" img-format="tif"/></maths> <maths id="math0015" num="(8-17)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>4</mn></mfenced><mo>=</mo><mi>INTRA</mi><mo>_</mo><mi>ANGULAR</mi><mn>2</mn></math><img id="ib0015" file="imgb0015.tif" wi="123" he="6" img-content="math" img-format="tif"/></maths> <maths id="math0016" num="(8-17)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>5</mn></mfenced><mo>=</mo><mi>INTRA</mi><mo>_</mo><mi>ANGULAR</mi><mn>18</mn></math><img id="ib0016" file="imgb0016.tif" wi="123" he="6" img-content="math" img-format="tif"/></maths>&lt;/ins&gt;</li>
<li>Otherwise, candModeList[x] with x = 0..5 is derived as follows: <maths id="math0017" num="(8-18)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>0</mn></mfenced><mo>=</mo><mi>candIntraPredModeA</mi></math><img id="ib0017" file="imgb0017.tif" wi="123" he="7" img-content="math" img-format="tif"/></maths> <maths id="math0018" num="(8-19)"><math display="block"><mo>&lt;</mo><mi>dlt</mi><mo>&gt;</mo><mi>candModeList</mi><mfenced open="[" close="]"><mn>2</mn></mfenced><mo>=</mo><mn>2</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi>candIntraPredModeA</mi><mo>+</mo><mn>29</mn></mfenced><mi>%</mi><mspace width="1ex"/><mn>32</mn></mfenced></math><img id="ib0018" file="imgb0018.tif" wi="123" he="13" img-content="math" img-format="tif"/></maths> <maths id="math0019" num="(8-20)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>2</mn></mfenced><mo>=</mo><mn>2</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi>candIntraPredModeA</mi><mo>−</mo><mn>2</mn><mo>+</mo><mn>1</mn></mfenced><mi>%</mi><mspace width="1ex"/><mn>32</mn></mfenced></math><img id="ib0019" file="imgb0019.tif" wi="123" he="13" img-content="math" img-format="tif"/></maths>&lt;/dlt&gt; <maths id="math0020" num="(8-20)"><math display="block"><mo>&lt;</mo><mi>ins</mi><mo>&gt;</mo><mi>candModeList</mi><mfenced open="[" close="]"><mn>1</mn></mfenced><mo>=</mo><mi>INTRA</mi><mo>_</mo><mi>PLANAR</mi></math><img id="ib0020" file="imgb0020.tif" wi="122" he="6" img-content="math" img-format="tif"/></maths> <maths id="math0021" num="(8-19)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>1</mn></mfenced><mo>=</mo><mn>2</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi>candIntraPredModeA</mi><mo>−</mo><mn>1</mn></mfenced><mi>%</mi><mspace width="1ex"/><mn>32</mn></mfenced></math><img id="ib0021" file="imgb0021.tif" wi="123" he="6" img-content="math" img-format="tif"/></maths> <maths id="math0022" num="(8-20)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>3</mn></mfenced><mo>=</mo><mn>2</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi>candIntraPredModeA</mi><mo>+</mo><mn>29</mn></mfenced><mi>%</mi><mspace width="1ex"/><mn>32</mn></mfenced></math><img id="ib0022" file="imgb0022.tif" wi="122" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0023" num="(8-20)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>4</mn></mfenced><mo>=</mo><mn>2</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi>candModeList</mi><mfenced open="[" close="]"><mn>2</mn></mfenced><mo>−</mo><mn>1</mn></mfenced><mi>%</mi><mspace width="1ex"/><mn>32</mn></mfenced></math><img id="ib0023" file="imgb0023.tif" wi="123" he="6" img-content="math" img-format="tif"/></maths> <maths id="math0024" num="(8-20)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>5</mn></mfenced><mo>=</mo><mi>INTRA</mi><mo>_</mo><mi>DC</mi></math><img id="ib0024" file="imgb0024.tif" wi="123" he="6" img-content="math" img-format="tif"/></maths> idxPlanar = 1<br/>
idxDC = 5&lt;/ins&gt;</li>
</ul></li>
<li>Otherwise (candIntraPredModeB is not equal to candIntraPredModeA), the following applies:
<ul id="ul0019" list-style="dash" compact="compact">
<li>candModeList[0] and candModeList[1] are derived as follows: <maths id="math0025" num="(8-21)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>0</mn></mfenced><mo>=</mo><mi>candIntraPredModeA</mi></math><img id="ib0025" file="imgb0025.tif" wi="122" he="7" img-content="math" img-format="tif"/></maths> <maths id="math0026" num="(8-22)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>1</mn></mfenced><mo>=</mo><mi>candIntraPredModeB</mi></math><img id="ib0026" file="imgb0026.tif" wi="123" he="6" img-content="math" img-format="tif"/></maths></li>
<li>If neither of candModeList[0] and candModeList[1] is equal to INTRA_PLANAR, candModeList[2] is set equal to INTRA_PLANAR, &lt;ins&gt;and the following applies:
<ul id="ul0020" list-style="dash" compact="compact">
<li>maxDir = max(candModeList[0], candModeList[1])</li>
<li>minDir = min(candModeList[0], candModeList[1])</li>
<li>idxPlanar = 2</li>
<li>If either of candModeList[0] and candModeList[1] is equal to INTRA_DC, the following applies: <maths id="math0027" num="(8-21)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>3</mn></mfenced><mo>=</mo><mn>2</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi>maxDir</mi><mo>+</mo><mn>29</mn></mfenced><mi>%</mi><mspace width="1ex"/><mn>32</mn></mfenced></math><img id="ib0027" file="imgb0027.tif" wi="107" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0028" num="(8-22)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>4</mn></mfenced><mo>=</mo><mn>2</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi>maxDir</mi><mo>−</mo><mn>1</mn></mfenced><mi>%</mi><mspace width="1ex"/><mn>32</mn></mfenced></math><img id="ib0028" file="imgb0028.tif" wi="107" he="5" img-content="math" img-format="tif"/></maths><!-- EPO <DP n="70"> --> <maths id="math0029" num="(8-22)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>5</mn></mfenced><mo>=</mo><mn>2</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi>candModeList</mi><mfenced open="[" close="]"><mn>4</mn></mfenced><mo>−</mo><mn>1</mn></mfenced><mi>%</mi><mspace width="1ex"/><mn>32</mn></mfenced></math><img id="ib0029" file="imgb0029.tif" wi="81" he="13" img-content="math" img-format="tif"/></maths> idxDC = (candModeList[0]== INTRA_DC) ? 0 : 1</li>
<li>Otherwise, <maths id="math0030" num="(8-21)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>3</mn></mfenced><mo>=</mo><mi>INTRA</mi><mo>_</mo><mi>DC</mi></math><img id="ib0030" file="imgb0030.tif" wi="107" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0031" num="(8-22)"><math display="block"><mi>candModeList</mi><mfenced open="[" close="]"><mn>4</mn></mfenced><mo>=</mo><mn>2</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi>maxDir</mi><mo>−</mo><mn>1</mn></mfenced><mi>%</mi><mspace width="1ex"/><mn>32</mn></mfenced></math><img id="ib0031" file="imgb0031.tif" wi="107" he="5" img-content="math" img-format="tif"/></maths>
<ul id="ul0021" list-style="dash" compact="compact">
<li>If candModeList[4] equals to minDir, candModeList[4]++ candModeList[5] = 2 + ((candModeList[4] + 29) % 32) (8-22)</li>
<li>If candModeList[5] equals to maxDir, candModeList[5]--</li>
<li>If candModeList[5] equals to candModeList[4], candModeList[5]= minDir+1<br/>
idxDC = 3&lt;/ins&gt;</li>
</ul></li>
</ul></li>
<li>Otherwise, if neither of candModeList[0] and candModeList[1] is equal to INTRA DC, candModeList[2] is set equal to INTRA_DC, &lt;ins&gt;the following applies:
<ul id="ul0022" list-style="none" compact="compact">
<li>candModeList[3] = 2 + ((candIntraPredModeA + 29) % 32) candModeList[4] = 2 + ((candIntraPredModeA - 1) % 32) candModeList[5] = 2 + ((candModeList[4] - 1) % 32) idxPlanar = (candModeList[0]== INTRA_PLANAR) ? 0 : 1 idxDC = 2&lt;/ins&gt;</li>
</ul></li>
<li>Otherwise, candModeList[2] is set equal to INTRA_ANGULAR26, the following applies:<br/>
&lt;ins&gt;candModeList[3] = INTRA_ANGULAR10 candModeList[4] = INTRA_ANGULAR2 candModeList[5] = INTRA_ANGULAR18 idxPlanar = (candModeList[0]== INTRA_PLANAR) ? 0 : 1 idxDC = 1- idxPlanar&lt;/ins&gt;</li>
</ul></li>
</ul></li>
<li>7. IntraPredModeY[xPb][yPb] is derived by applying the following procedure:<!-- EPO <DP n="71"> -->
<ul id="ul0023" list-style="dash" compact="compact">
<li>If prev_intra_luma_pred_flag[xPb][yPb] is equal to 1, the IntraPredModeY[xPb][yPb] is set equal to candModeList[mpm_idx].</li>
<li>Otherwise, IntraPredModeY[xPb][yPb] is derived by applying the following ordered steps:
<ol id="ol0002" compact="compact" ol-style="">
<li>1) The array candModeList[x], x = 0...&lt;dlt&gt;2&lt;/dlt&gt;&lt;ins&gt;5&lt;/ins&gt; is modified as the following ordered steps:&lt;ins&gt;
<ol id="ol0003" compact="compact" ol-style="">
<li>i. candModeList[idxPlanar] = candModeList[0]</li>
<li>ii. candModeList[idxDC] = candModeList[1]</li>
<li>iii. candModeList[0] = INTRA PLANAR</li>
<li>iv. candModeList[1] = INTRA_DC&lt;/ins&gt;</li>
<li>v. When candModeList[&lt;dlt&gt;0&lt;/dlt&gt;&lt;ins&gt;2&lt;/ins&gt;] is greater than candModeList[&lt;dlt&gt;1&lt;/dlt&gt;&lt;ins&gt;3&lt;/ins&gt;], both values are swapped as follows:<br/>
(candModeList[&lt;dlt&gt;0&lt;/dlt&gt;&lt;ins&gt;2&lt;/ins&gt;], candModeList[&lt;dlt&gt;1&lt;/dlt&gt;&lt;ins&gt;3&lt;/ins&gt;]) = Swap(candModeList[&lt;dlt&gt;0&lt;/dlt&gt;&lt;ins&gt;2&lt;/ins&gt;], candModeList[&lt;dlt&gt;1&lt;/dlt&gt;&lt;ins&gt;3&lt;/ins&gt;]) (8-23)</li>
<li>vi. When candModeList[&lt;dlt&gt;0&lt;/dlt&gt;&lt;ins&gt;2&lt;/ins&gt;] is greater than candModeList[&lt;dlt&gt;2&lt;/dlt&gt;&lt;ins&gt;4&lt;/ins&gt;], both values are swapped as follows:<br/>
(candModeList[&lt;dlt&gt;0&lt;/dlt&gt;&lt;ins&gt;2&lt;/ins&gt;], candModeList[&lt;dlt&gt;2&lt;/dlt&gt;&lt;ins&gt;4&lt;/ins&gt;]) = Swap(candModeList[ &lt;dlt&gt;0&lt;/dlt&gt;&lt;ins&gt;2&lt;/ins&gt;], candModeList[&lt;dlt&gt;2&lt;/dlt&gt;&lt;ins&gt;4&lt;/ins&gt;]) (8-24)</li>
<li>vii. <u>&lt;ins&gt;When candModeList[2 1 is greater than candModeList[5], both values are swapped as follows: (candModeList[2], candModeList[5]) = Swap( candModeList[2], candModeList[5])&lt;/ins&gt;</u></li>
<li>viii. When candModeList[&lt;dlt&gt;1&lt;/dlt&gt;&lt;ins&gt;3&lt;/ins&gt;] is greater than candModeList[&lt;dlt&gt;2&lt;/dlt&gt;&lt;ins&gt;4&lt;/ins&gt;], both values are swapped as follows:<br/>
(candModeList[&lt;dlt&gt;1&lt;/delete &gt;&lt;ins&gt;3&lt;/ins&gt;], candModeList[&lt;dlt&gt;2&lt;/dlt&gt;&lt;ins&gt;4&lt;/ins&gt;]) =<!-- EPO <DP n="72"> --> Swap(candModeList[ &lt;dlt&gt;1&lt;/dlt&gt;&lt;ins&gt;3&lt;/ins&gt;], candModeList[&lt;dlt&gt;2&lt;/dlt&gt;&lt;ins&gt;4&lt;/ins&gt;]) (8-25)</li>
<li>ix. &lt;ins&gt;When candModeList[3] is greater than candModeList[5], both values are swapped as follows:<br/>
(candModeList[3], candModeList[5]) = Swap( candModeList[3], candModeList[5])</li>
<li>x. When candModeList[4] is greater than candModeList[5], both values are swapped as follows:<br/>
(candModeList[4], candModeList[5]) = Swap(candModeList[4], candModeList[5] )&lt;/ins&gt;</li>
</ol></li>
<li>2) IntraPredModeY[xPb][yPb] is derived by the following ordered steps:
<ol id="ol0004" compact="compact" ol-style="">
<li>i. IntraPredModeY[xPb][yPb] is set equal to rem_intra_luma_pred_mode[xPb][yPb].</li>
<li>ii. For i equal to 0 to &lt;dlt&gt;2&lt;/dlt&gt;&lt;ins&gt;5&lt;/ins&gt;, inclusive, when IntraPredModeY[xPb][yPb] is greater than or equal to candModeList[i], the value of IntraPredModeY[xPb][yPb] is incremented by one.</li>
</ol></li>
</ol></li>
</ul></li>
</ul></p>
<p id="p0195" num="0195">In the example adapted version of subclause 8.4.2 of JCTVC-N1003 shown above, the derivation process for the MPMs of the current PU includes a derivation process for a representative intra prediction mode (candIntraPredModeA) for a left neighboring column and a representative intra prediction mode (candIntraPredModeB) for an above neighboring row. In this example, is left neighboring column corresponds to samples (xNbA, yNbA + x) for x = x..nPbs and the above neighboring row corresponds to samples (xNbA+x, yNbA) for x = 0..nPbs), where nPbs is the width and height of the prediction block of the current PU.</p>
<p id="p0196" num="0196">Furthermore, in the example adapted version of subclause 8.4.2 of JCTVC-N1003 shown above, the list of MPM candidates (i.e., candModeList) always includes the planar, DC, vertical (i.e., INTRA_ANGULAR26), horizontal (i.e., INTRA_ANGULAR10), and diagonal (i.e., INTRA_ANGULAR18) intra prediction modes if candIntraPredModeA is the same as candIntraPredModeB and candIntraPredModeA is planar or DC. However, in this example, if candIntraPredModeA is not planar and not DC, the list of MPM candidates includes candIntraPredModeA, the planar intra prediction, three angular intra prediction modes<!-- EPO <DP n="73"> --> closest to candIntraPredModeA, and the DC intra prediction mode. The three angular intra prediction modes closest to candIntraPredModeA are calculated as: <maths id="math0032" num=""><math display="block"><mn>2</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi>candIntraPredModeA</mi><mo>−</mo><mn>1</mn></mfenced><mi>%</mi><mn>32</mn></mfenced><mo>,</mo></math><img id="ib0032" file="imgb0032.tif" wi="69" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0033" num=""><math display="block"><mrow><mo>(</mo><mrow><mn>2</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi>candIntraPredModeA</mi><mo>+</mo><mn>29</mn></mfenced><mi>%</mi><mn>32</mn></mfenced></mrow></mrow><mo>,</mo></math><img id="ib0033" file="imgb0033.tif" wi="76" he="5" img-content="math" img-format="tif"/></maths> and <maths id="math0034" num=""><math display="block"><mn>2</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi>candModeList</mi><mfenced open="[" close="]"><mn>2</mn></mfenced><mo>−</mo><mn>1</mn></mfenced><mi>%</mi><mn>32</mn></mfenced></math><img id="ib0034" file="imgb0034.tif" wi="64" he="5" img-content="math" img-format="tif"/></maths> In the formulae above, % denotes the modulo operation.</p>
<p id="p0197" num="0197">Similarly, in the example adapted version of subclause 8.4.2 of JCTVC-N1003 shown above, if candIntraPredModeA is not equal to candIntraPredModeB, the video coder may include in the list of MPM candidates, other angular intra prediction modes determined to be closest either candIntraPredModeA or candIntraPredModeB using the formulae shown in the example adapted version of subclause 8.4.2 of JCTVC-N1003 that include modulo operations.</p>
<p id="p0198" num="0198">As described above, in some examples of this disclosure, video encoder 20 and video decoder 30 may use more than 33 angular intra prediction modes. The following text describes examples changes to JCTVC-N1003 to implement 65 angular intra prediction modes.</p>
<heading id="h0008"><b>8.4.4.2.6 Specification of intra prediction mode in the range of INTRA_ANGULAR2.. INTRA_ANGULAR34</b></heading>
<p id="p0199" num="0199">Inputs to this process are:
<ul id="ul0024" list-style="dash" compact="compact">
<li>the intra prediction mode predModeIntra,</li>
<li>the neighbouring samples p[x][y], with x = -1, y = -1..nTbS * 2 - 1 and x = 0..nTbS * 2 - 1, y = -1,</li>
<li>a variable nTbS specifying the transform block size,</li>
<li>a variable cIdx specifying the colour component of the current block.</li>
</ul></p>
<p id="p0200" num="0200">Outputs of this process are the predicted samples predSamples[x][y], with x, y = 0..nTbS - 1.</p>
<p id="p0201" num="0201"><figref idref="f0008">FIG. 8-2</figref>, which is <figref idref="f0009">FIG. 9</figref> of this disclosure, illustrates the total 33 intra angles and Table 8-4 specifies the mapping table between predModeIntra and the angle parameter intraPredAngle.<!-- EPO <DP n="74"> -->
<tables id="tabl0005" num="0005">
<table frame="all">
<title>&lt;dlt&gt;<b>Table 8-4 - Specification of intraPredAngle</b></title>
<tgroup cols="18">
<colspec colnum="1" colname="col1" colwidth="27mm"/>
<colspec colnum="2" colname="col2" colwidth="10mm"/>
<colspec colnum="3" colname="col3" colwidth="8mm"/>
<colspec colnum="4" colname="col4" colwidth="10mm"/>
<colspec colnum="5" colname="col5" colwidth="10mm"/>
<colspec colnum="6" colname="col6" colwidth="10mm"/>
<colspec colnum="7" colname="col7" colwidth="8mm"/>
<colspec colnum="8" colname="col8" colwidth="8mm"/>
<colspec colnum="9" colname="col9" colwidth="8mm"/>
<colspec colnum="10" colname="col10" colwidth="8mm"/>
<colspec colnum="11" colname="col11" colwidth="8mm"/>
<colspec colnum="12" colname="col12" colwidth="8mm"/>
<colspec colnum="13" colname="col13" colwidth="8mm"/>
<colspec colnum="14" colname="col14" colwidth="8mm"/>
<colspec colnum="15" colname="col15" colwidth="10mm"/>
<colspec colnum="16" colname="col16" colwidth="10mm"/>
<colspec colnum="17" colname="col17" colwidth="10mm"/>
<colspec colnum="18" colname="col18" colwidth="8mm"/>
<tbody>
<row>
<entry align="center"><b>predMode Intra</b></entry>
<entry align="center"><b>1</b></entry>
<entry align="center"><b>2</b></entry>
<entry align="center"><b>3</b></entry>
<entry align="center"><b>4</b></entry>
<entry align="center"><b>5</b></entry>
<entry align="center"><b>6</b></entry>
<entry align="center"><b>7</b></entry>
<entry align="center"><b>8</b></entry>
<entry align="center"><b>9</b></entry>
<entry align="center"><b>1 0</b></entry>
<entry align="center"><b>11</b></entry>
<entry align="center"><b>1 2</b></entry>
<entry align="center"><b>1 3</b></entry>
<entry align="center"><b>14</b></entry>
<entry align="center"><b>15</b></entry>
<entry align="center"><b>16</b></entry>
<entry align="center"><b>17</b></entry></row>
<row>
<entry align="center"><b>intraPred Angle</b></entry>
<entry align="center">-</entry>
<entry align="center">32</entry>
<entry align="center">26</entry>
<entry align="center">21</entry>
<entry align="center">17</entry>
<entry align="center">1 3</entry>
<entry align="center">9</entry>
<entry align="center">5</entry>
<entry align="center">2</entry>
<entry align="center">0</entry>
<entry align="center">-2</entry>
<entry align="center">- 5</entry>
<entry align="center">- 9</entry>
<entry align="center">-1 3</entry>
<entry align="center">-1 7</entry>
<entry align="center">-2 1</entry>
<entry align="center">-26</entry></row>
<row>
<entry align="center"><b>predMode Intra</b></entry>
<entry align="center"><b>18</b></entry>
<entry align="center"><b>19</b></entry>
<entry align="center"><b>20</b></entry>
<entry align="center"><b>21</b></entry>
<entry align="center"><b>22</b></entry>
<entry align="center"><b>2 3</b></entry>
<entry align="center"><b>2 4</b></entry>
<entry align="center"><b>25</b></entry>
<entry align="center"><b>2 6</b></entry>
<entry align="center"><b>2 7</b></entry>
<entry align="center"><b>28</b></entry>
<entry align="center"><b>2 9</b></entry>
<entry align="center"><b>3 0</b></entry>
<entry align="center"><b>31</b></entry>
<entry align="center"><b>32</b></entry>
<entry align="center"><b>33</b></entry>
<entry align="center"><b>34</b></entry></row>
<row>
<entry align="center"><b>intraPred Angle</b></entry>
<entry align="center">-3 2</entry>
<entry align="center">-26</entry>
<entry align="center">-2 1</entry>
<entry align="center">-1 7</entry>
<entry align="center">-1 3</entry>
<entry align="center">- 9</entry>
<entry align="center">- 5</entry>
<entry align="center">-2</entry>
<entry align="center">0</entry>
<entry align="center">2</entry>
<entry align="center">5</entry>
<entry align="center">9</entry>
<entry align="center">1 3</entry>
<entry align="center">17</entry>
<entry align="center">21</entry>
<entry align="center">26</entry>
<entry align="center">32</entry></row></tbody></tgroup>
</table>
</tables>
&lt;/dlt&gt;<!-- EPO <DP n="75"> -->
<tables id="tabl0006" num="0006">
<table frame="all">
<title>&lt;ins&gt;<b>Table 8-4 - Specification of intraPredAngle</b></title>
<tgroup cols="18">
<colspec colnum="1" colname="col1" colwidth="27mm"/>
<colspec colnum="2" colname="col2" colwidth="9mm"/>
<colspec colnum="3" colname="col3" colwidth="9mm"/>
<colspec colnum="4" colname="col4" colwidth="9mm"/>
<colspec colnum="5" colname="col5" colwidth="9mm"/>
<colspec colnum="6" colname="col6" colwidth="9mm"/>
<colspec colnum="7" colname="col7" colwidth="9mm"/>
<colspec colnum="8" colname="col8" colwidth="9mm"/>
<colspec colnum="9" colname="col9" colwidth="9mm"/>
<colspec colnum="10" colname="col10" colwidth="9mm"/>
<colspec colnum="11" colname="col11" colwidth="9mm"/>
<colspec colnum="12" colname="col12" colwidth="9mm"/>
<colspec colnum="13" colname="col13" colwidth="9mm"/>
<colspec colnum="14" colname="col14" colwidth="9mm"/>
<colspec colnum="15" colname="col15" colwidth="9mm"/>
<colspec colnum="16" colname="col16" colwidth="9mm"/>
<colspec colnum="17" colname="col17" colwidth="9mm"/>
<colspec colnum="18" colname="col18" colwidth="9mm"/>
<tbody>
<row>
<entry align="center"><b>predMode Intra</b></entry>
<entry align="center"><b>0</b></entry>
<entry align="center"><b>1</b></entry>
<entry align="center"><b>2</b></entry>
<entry align="center"><b>3</b></entry>
<entry align="center"><b>4</b></entry>
<entry align="center"><b>5</b></entry>
<entry align="center"><b>6</b></entry>
<entry align="center"><b>7</b></entry>
<entry align="center"><b>8</b></entry>
<entry align="center"><b>9</b></entry>
<entry align="center"><b>10</b></entry>
<entry align="center"><b>11</b></entry>
<entry align="center"><b>12</b></entry>
<entry align="center"><b>13</b></entry>
<entry align="center"><b>14</b></entry>
<entry align="center"><b>15</b></entry>
<entry align="center"><b>16</b></entry></row>
<row>
<entry align="center"><b>intraPred Angle</b></entry>
<entry align="center">-</entry>
<entry align="center">-</entry>
<entry align="center">32</entry>
<entry align="center">29</entry>
<entry align="center">26</entry>
<entry align="center">23</entry>
<entry align="center">21</entry>
<entry align="center">19</entry>
<entry align="center">17</entry>
<entry align="center">15</entry>
<entry align="center">13</entry>
<entry align="center">11</entry>
<entry align="center">9</entry>
<entry align="center">7</entry>
<entry align="center">5</entry>
<entry align="center">3</entry>
<entry align="center">2</entry></row>
<row>
<entry align="center"><b>predMode Intra</b></entry>
<entry align="center"><b>17</b></entry>
<entry align="center"><b>18</b></entry>
<entry align="center"><b>19</b></entry>
<entry align="center"><b>20</b></entry>
<entry align="center"><b>21</b></entry>
<entry align="center"><b>22</b></entry>
<entry align="center"><b>23</b></entry>
<entry align="center"><b>24</b></entry>
<entry align="center"><b>25</b></entry>
<entry align="center"><b>26</b></entry>
<entry align="center"><b>27</b></entry>
<entry align="center"><b>28</b></entry>
<entry align="center"><b>29</b></entry>
<entry align="center"><b>30</b></entry>
<entry align="center"><b>31</b></entry>
<entry align="center"><b>32</b></entry>
<entry align="center"><b>33</b></entry></row>
<row>
<entry align="center"><b>intraPred Angle</b></entry>
<entry align="center">1</entry>
<entry align="center">0</entry>
<entry align="center">1</entry>
<entry align="center">2</entry>
<entry align="center">3</entry>
<entry align="center">5</entry>
<entry align="center">7</entry>
<entry align="center">9</entry>
<entry align="center">11</entry>
<entry align="center">13</entry>
<entry align="center">15</entry>
<entry align="center">17</entry>
<entry align="center">19</entry>
<entry align="center">21</entry>
<entry align="center">23</entry>
<entry align="center">26</entry>
<entry align="center">29</entry></row>
<row>
<entry align="center"><b>predMode Intra</b></entry>
<entry align="center"><b>34</b></entry>
<entry align="center"><b>35</b></entry>
<entry align="center"><b>36</b></entry>
<entry align="center"><b>37</b></entry>
<entry align="center"><b>38</b></entry>
<entry align="center"><b>39</b></entry>
<entry align="center"><b>40</b></entry>
<entry align="center"><b>41</b></entry>
<entry align="center"><b>42</b></entry>
<entry align="center"><b>43</b></entry>
<entry align="center"><b>44</b></entry>
<entry align="center"><b>45</b></entry>
<entry align="center"><b>46</b></entry>
<entry align="center"><b>47</b></entry>
<entry align="center"><b>48</b></entry>
<entry align="center"><b>49</b></entry>
<entry align="center"><b>50</b></entry></row>
<row>
<entry align="center"><b>intraPred Angle</b></entry>
<entry align="center">32</entry>
<entry align="center">29</entry>
<entry align="center">26</entry>
<entry align="center">23</entry>
<entry align="center">21</entry>
<entry align="center">19</entry>
<entry align="center">17</entry>
<entry align="center">15</entry>
<entry align="center">13</entry>
<entry align="center">11</entry>
<entry align="center">9</entry>
<entry align="center">7</entry>
<entry align="center">5</entry>
<entry align="center">3</entry>
<entry align="center">2</entry>
<entry align="center">1</entry>
<entry align="center">0</entry></row>
<row>
<entry align="center"><b>predMode Intra</b></entry>
<entry align="center"><b>51</b></entry>
<entry align="center"><b>52</b></entry>
<entry align="center"><b>53</b></entry>
<entry align="center"><b>54</b></entry>
<entry align="center"><b>55</b></entry>
<entry align="center"><b>56</b></entry>
<entry align="center"><b>57</b></entry>
<entry align="center"><b>58</b></entry>
<entry align="center"><b>59</b></entry>
<entry align="center"><b>60</b></entry>
<entry align="center"><b>61</b></entry>
<entry align="center"><b>62</b></entry>
<entry align="center"><b>63</b></entry>
<entry align="center"><b>64</b></entry>
<entry align="center"><b>65</b></entry>
<entry align="center"><b>66</b></entry>
<entry align="center"><b>67</b></entry></row>
<row>
<entry align="center"><b>intraPred Angle</b></entry>
<entry align="center">1</entry>
<entry align="center">2</entry>
<entry align="center">3</entry>
<entry align="center">5</entry>
<entry align="center">7</entry>
<entry align="center">9</entry>
<entry align="center">11</entry>
<entry align="center">13</entry>
<entry align="center">15</entry>
<entry align="center">17</entry>
<entry align="center">19</entry>
<entry align="center">21</entry>
<entry align="center">23</entry>
<entry align="center">26</entry>
<entry align="center">29</entry>
<entry align="center">32</entry>
<entry align="center">-</entry></row></tbody></tgroup>
</table>
</tables>
&lt;/ins&gt;</p>
<p id="p0202" num="0202">Table 8-5 further specifies the mapping table between predModeIntra and the inverse angle parameter invAngle.
<tables id="tabl0007" num="0007">
<table frame="all">
<title><b>Table 8-5 - Specification of invAngle</b></title>
<tgroup cols="9">
<colspec colnum="1" colname="col1" colwidth="28mm"/>
<colspec colnum="2" colname="col2" colwidth="13mm"/>
<colspec colnum="3" colname="col3" colwidth="13mm"/>
<colspec colnum="4" colname="col4" colwidth="11mm"/>
<colspec colnum="5" colname="col5" colwidth="11mm"/>
<colspec colnum="6" colname="col6" colwidth="11mm"/>
<colspec colnum="7" colname="col7" colwidth="13mm"/>
<colspec colnum="8" colname="col8" colwidth="13mm"/>
<colspec colnum="9" colname="col9" colwidth="11mm"/>
<tbody>
<row>
<entry align="center"><b>predModeIntra</b></entry>
<entry align="center"><b>11</b></entry>
<entry align="center"><b>12</b></entry>
<entry align="center"><b>13</b></entry>
<entry align="center"><b>14</b></entry>
<entry align="center"><b>15</b></entry>
<entry align="center"><b>16</b></entry>
<entry align="center"><b>17</b></entry>
<entry align="center"><b>18</b></entry></row>
<row>
<entry align="center"><b>invAngle</b></entry>
<entry align="center">-4096</entry>
<entry align="center">-1638</entry>
<entry align="center">-910</entry>
<entry align="center">-630</entry>
<entry align="center">-482</entry>
<entry align="center">-390</entry>
<entry align="center">-315</entry>
<entry align="center">-256</entry></row>
<row>
<entry align="center"><b>predModeIntra</b></entry>
<entry align="center"><b>19</b></entry>
<entry align="center"><b>20</b></entry>
<entry align="center"><b>21</b></entry>
<entry align="center"><b>22</b></entry>
<entry align="center"><b>23</b></entry>
<entry align="center"><b>24</b></entry>
<entry align="center"><b>25</b></entry>
<entry align="center"><b>26</b></entry></row>
<row>
<entry align="center"><b>invAngle</b></entry>
<entry align="center">-315</entry>
<entry align="center">-390</entry>
<entry align="center">-482</entry>
<entry align="center">-630</entry>
<entry align="center">-910</entry>
<entry align="center">-1638</entry>
<entry align="center">-4096</entry>
<entry align="center">-</entry></row></tbody></tgroup>
</table>
</tables><!-- EPO <DP n="76"> --></p>
<p id="p0203" num="0203">The values of the prediction samples predSamples[x][y], with x, y = 0..nTbS - 1 are derived as follows:
<ul id="ul0025" list-style="dash" compact="compact">
<li>If predModeIntra is equal or greater than 18, the following ordered steps apply:
<ol id="ol0005" compact="compact" ol-style="">
<li>1. The reference sample array ref[x] is specified as follows:
<ul id="ul0026" list-style="dash" compact="compact">
<li>The following applies: <maths id="math0035" num="(8-47)"><math display="block"><mi>ref</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mo>=</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn><mo>+</mo><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mo>,</mo><mspace width="1ex"/><mi>with</mi><mspace width="1ex"/><mi mathvariant="normal">x</mi><mo>=</mo><mi mathvariant="normal">0</mi><mi>..</mi><mi>nTbS</mi></math><img id="ib0035" file="imgb0035.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
<li>If intraPredAngle is less than 0, the main reference sample array is extended as follows:
<ul id="ul0027" list-style="dash" compact="compact">
<li>When (nTbS * intraPredAngle) » 5 is less than -1, <maths id="math0036" num="(8-48)"><math display="block"><mtable><mtr><mtd><mrow><mi>ref</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mo>=</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">x</mi><mo>*</mo><mi>invAngle</mi><mo>+</mo><mn>128</mn></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>8</mn></mfenced></mfenced><mo>,</mo></mrow></mtd></mtr><mtr><mtd><mrow><mi>with</mi><mspace width="1ex"/><mi mathvariant="normal">x</mi><mo>=</mo><mo>−</mo><mn>1</mn><mo>.</mo><mo>.</mo><mfenced separators=""><mi>nTbS</mi><mo>*</mo><mi>intraPredAngle</mi></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>5</mn></mrow></mtd></mtr></mtable><mspace width="1ex"/></math><img id="ib0036" file="imgb0036.tif" wi="117" he="13" img-content="math" img-format="tif"/></maths></li>
</ul></li>
<li>Otherwise, <maths id="math0037" num="(8-49)"><math display="block"><mi>ref</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mo>=</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn><mo>+</mo><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mo>,</mo><mspace width="1ex"/><mi>with</mi><mspace width="1ex"/><mi mathvariant="normal">x</mi><mo>=</mo><mi>nTbS</mi><mo>+</mo><mi mathvariant="normal">1</mi><mi>..</mi><mi>2*nTbS</mi></math><img id="ib0037" file="imgb0037.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
</ul></li>
<li>2. The values of the prediction samples predSamples[x][y], with x, y = 0..nTbS - 1 are derived as follows:
<ol id="ol0006" compact="compact" ol-style="">
<li>a. The index variable ildx and the multiplication factor iFact are derived as follows: <maths id="math0038" num="(8-50)"><math display="block"><mi>iIdx</mi><mo>=</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">y</mi><mo>+</mo><mn>1</mn></mfenced><mo>*</mo><mi>intraPredAngle</mi></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>5</mn></math><img id="ib0038" file="imgb0038.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0039" num="(8-51)"><math display="block"><mi>iFact</mi><mo>=</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">y</mi><mo>+</mo><mn>1</mn></mfenced><mo>*</mo><mi>intraPredAngle</mi></mfenced><mo>&amp;</mo><mn>31</mn></math><img id="ib0039" file="imgb0039.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
<li>b. Depending on the value of iFact, the following applies:
<ul id="ul0028" list-style="dash" compact="compact">
<li>If iFact is not equal to 0, the value of the prediction samples predSamples[x][y] is derived as follows: <maths id="math0040" num="(8-52)"><math display="block"><mtable columnalign="left"><mtr><mtd><mi>predSamples</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>=</mo></mtd></mtr><mtr><mtd><mfenced separators=""><mfenced separators=""><mn>32</mn><mo>−</mo><mi>iFact</mi></mfenced><mo>*</mo><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>1</mn></mfenced><mo>+</mo><mi>iFact</mi><mo>*</mo><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>2</mn></mfenced><mo>+</mo><mn>16</mn></mfenced><mo>&gt;</mo><mo>&gt;</mo></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></math><img id="ib0040" file="imgb0040.tif" wi="126" he="20" img-content="math" img-format="tif"/></maths><!-- EPO <DP n="77"> --></li>
<li>Otherwise, the value of the prediction samples predSamples[x][y] is derived as follows: <maths id="math0041" num="(8-53)"><math display="block"><mi>predSamples</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>=</mo><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>1</mn></mfenced></math><img id="ib0041" file="imgb0041.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
</ul></li>
<li>c. When predModeIntra is equal to 26 (vertical), cIdx is equal to 0 and nTbS is less than 32, the following filtering applies with x = 0, y = 0..nTbS - 1: <maths id="math0042" num="(8-54)"><math display="block"><mtable columnalign="left"><mtr><mtd><mi>predSamples</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>=</mo></mtd></mtr><mtr><mtd><msub><mi>Clip1</mi><mi mathvariant="normal">Y</mi></msub><mfenced separators=""><mi mathvariant="normal">p</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mo>+</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>−</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>1</mn></mfenced></mfenced></mtd></mtr></mtable></math><img id="ib0042" file="imgb0042.tif" wi="126" he="12" img-content="math" img-format="tif"/></maths></li>
</ol></li>
</ol></li>
<li>Otherwise (predModeIntra is less than 18), the following ordered steps apply:
<ol id="ol0007" compact="compact" ol-style="">
<li>1. The reference sample array ref[x] is specified as follows:
<ul id="ul0029" list-style="dash" compact="compact">
<li>The following applies: <maths id="math0043" num="(8-55)"><math display="block"><mi>ref</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mo>=</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn><mo>+</mo><mi mathvariant="normal">x</mi></mfenced><mo>,</mo><mspace width="1ex"/><mi>with</mi><mspace width="1ex"/><mi mathvariant="normal">x</mi><mo>=</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>nTbS</mi></math><img id="ib0043" file="imgb0043.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
<li>If intraPredAngle is less than 0, the main reference sample array is extended as follows:
<ul id="ul0030" list-style="dash" compact="compact">
<li>When (nTbS * intraPredAngle) &gt;&gt; 5 is less than -1, <maths id="math0044" num="(8-56)"><math display="block"><mtable><mtr><mtd><mrow><mi>ref</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mo>=</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">x</mi><mo>*</mo><mi>invAngle</mi><mo>+</mo><mn>128</mn></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>8</mn></mfenced></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mo>,</mo></mrow></mtd></mtr><mtr><mtd><mrow><mi>with</mi><mspace width="1ex"/><mi mathvariant="normal">x</mi><mo>=</mo><mo>−</mo><mn>1</mn><mo>.</mo><mo>.</mo><mfenced separators=""><mi>nTbS</mi><mo>*</mo><mi>intraPredAngle</mi></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>5</mn></mrow></mtd></mtr></mtable><mspace width="1ex"/></math><img id="ib0044" file="imgb0044.tif" wi="117" he="13" img-content="math" img-format="tif"/></maths></li>
</ul></li>
<li>Otherwise, <maths id="math0045" num="(8-57)"><math display="block"><mi>ref</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mo>=</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn><mo>+</mo><mi mathvariant="normal">x</mi></mfenced><mo>,</mo><mspace width="1ex"/><mi>with</mi><mspace width="1ex"/><mi mathvariant="normal">x</mi><mo>=</mo><mi>nTbS</mi><mo>+</mo><mi mathvariant="normal">1</mi><mi>..</mi><mi>2*nTbS</mi></math><img id="ib0045" file="imgb0045.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
</ul></li>
<li>2. The values of the prediction samples predSamples[x][y], with x, y = 0..nTbS - 1 are derived as follows:
<ol id="ol0008" compact="compact" ol-style="">
<li>a. The index variable ildx and the multiplication factor iFact are derived as follows: <maths id="math0046" num="(8-58)"><math display="block"><mi>iIdx</mi><mo>=</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mn>1</mn></mfenced><mo>*</mo><mi>intraPredAngle</mi></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>5</mn></math><img id="ib0046" file="imgb0046.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0047" num="(8-59)"><math display="block"><mi>iFact</mi><mo>=</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mn>1</mn></mfenced><mo>*</mo><mi>intraPredAngle</mi></mfenced><mo>&amp;</mo><mn>31</mn></math><img id="ib0047" file="imgb0047.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
<li>b. Depending on the value of iFact, the following applies:<!-- EPO <DP n="78"> -->
<ul id="ul0031" list-style="dash" compact="compact">
<li>If iFact is not equal to 0, the value of the prediction samples predSamples[x][y] is derived as follows: <maths id="math0048" num="(8-60)"><math display="block"><mtable columnalign="left"><mtr><mtd><mi>predSamples</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>=</mo></mtd></mtr><mtr><mtd><mfenced separators=""><mfenced separators=""><mn>32</mn><mo>−</mo><mi>iFact</mi></mfenced><mo>*</mo><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">y</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>1</mn></mfenced><mo>+</mo><mi>iFact</mi><mo>*</mo><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">y</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>2</mn></mfenced><mo>+</mo><mn>16</mn></mfenced><mo>&gt;</mo><mo>&gt;</mo></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></math><img id="ib0048" file="imgb0048.tif" wi="126" he="20" img-content="math" img-format="tif"/></maths></li>
<li>Otherwise, the value of the prediction samples predSamples[x][y] is derived as follows: <maths id="math0049" num="(8-61)"><math display="block"><mi>predSamples</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>=</mo><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">y</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>1</mn></mfenced></math><img id="ib0049" file="imgb0049.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
</ul></li>
<li>c. When predModeIntra is equal to 10 (horizontal), cIdx is equal to 0 and nTbS is less than 32, the following filtering applies with x = 0..nTbS - 1, y = 0: <maths id="math0050" num="(8-62)"><math display="block"><mtable columnalign="left"><mtr><mtd><mi>predSamples</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>=</mo></mtd></mtr><mtr><mtd><msub><mi>Clip1</mi><mi mathvariant="normal">Y</mi></msub><mfenced separators=""><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>+</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">p</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mo>−</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>1</mn></mfenced></mfenced></mtd></mtr></mtable></math><img id="ib0050" file="imgb0050.tif" wi="126" he="13" img-content="math" img-format="tif"/></maths></li>
</ol></li>
</ol></li>
</ul></p>
<p id="p0204" num="0204">Table 8-5 further specifies the mapping table between predModeIntra and the inverse angle parameter invAngle.
<tables id="tabl0008" num="0008">
<table frame="all">
<title><b>Table 8-5 - Specification of invAngle</b></title>
<tgroup cols="9">
<colspec colnum="1" colname="col1" colwidth="28mm"/>
<colspec colnum="2" colname="col2" colwidth="13mm"/>
<colspec colnum="3" colname="col3" colwidth="13mm"/>
<colspec colnum="4" colname="col4" colwidth="11mm"/>
<colspec colnum="5" colname="col5" colwidth="11mm"/>
<colspec colnum="6" colname="col6" colwidth="11mm"/>
<colspec colnum="7" colname="col7" colwidth="13mm"/>
<colspec colnum="8" colname="col8" colwidth="13mm"/>
<colspec colnum="9" colname="col9" colwidth="11mm"/>
<tbody>
<row>
<entry align="center"><b>predModeIntra</b></entry>
<entry align="center"><b>11</b></entry>
<entry align="center"><b>12</b></entry>
<entry align="center"><b>13</b></entry>
<entry align="center"><b>14</b></entry>
<entry align="center"><b>15</b></entry>
<entry align="center"><b>16</b></entry>
<entry align="center"><b>17</b></entry>
<entry align="center"><b>18</b></entry></row>
<row>
<entry align="center"><b>invAngle</b></entry>
<entry align="center">-4096</entry>
<entry align="center">-1638</entry>
<entry align="center">-910</entry>
<entry align="center">-630</entry>
<entry align="center">-482</entry>
<entry align="center">-390</entry>
<entry align="center">-315</entry>
<entry align="center">-256</entry></row>
<row>
<entry align="center"><b>predModeIntra</b></entry>
<entry align="center"><b>19</b></entry>
<entry align="center"><b>20</b></entry>
<entry align="center"><b>21</b></entry>
<entry align="center"><b>22</b></entry>
<entry align="center"><b>23</b></entry>
<entry align="center"><b>24</b></entry>
<entry align="center"><b>25</b></entry>
<entry align="center"><b>26</b></entry></row>
<row>
<entry align="center"><b>invAngle</b></entry>
<entry align="center">-315</entry>
<entry align="center">-390</entry>
<entry align="center">-482</entry>
<entry align="center">-630</entry>
<entry align="center">-910</entry>
<entry align="center">-1638</entry>
<entry align="center">-4096</entry>
<entry align="center">-</entry></row></tbody></tgroup>
</table>
</tables></p>
<p id="p0205" num="0205">The values of the prediction samples predSamples[x][y], with x, y = 0..nTbS - 1 are derived as follows:
<ul id="ul0032" list-style="dash" compact="compact">
<li>If predModeIntra is equal or greater than 18, the following ordered steps apply:</li>
</ul><!-- EPO <DP n="79"> --></p>
<heading id="h0009"><b>7.4.9.11 Residual coding semantics</b></heading>
<p id="p0206" num="0206">For intra prediction, different scanning orders are used. The variable scanldx specifies which scan order is used where scanldx equal to 0 specifies an up-right diagonal scan order, scanldx equal to 1 specifies a horizontal scan order, and scanldx equal to 2 specifies a vertical scan order. The value of scanldx is derived as follows:
<ul id="ul0033" list-style="dash" compact="compact">
<li>If CuPredMode[x0][y0] is equal to MODE_INTRA and one or more of the following conditions are true:
<ul id="ul0034" list-style="dash">
<li>log2TrafoSize is equal to 2.</li>
<li>log2TrafoSize is equal to 3 and cIdx is equal to 0.</li>
</ul>
predModeIntra is derived as follows:
<ul id="ul0035" list-style="dash">
<li>If cIdx is equal to 0, predModeIntra is set equal to IntraPredModeY[x0][y0].</li>
<li>Otherwise, predModeIntra is set equal to IntraPredModeC.</li>
</ul>
scanldx is derived as follows:
<ul id="ul0036" list-style="dash">
<li>If predModeIntra is in the range of &lt;dlt&gt;6&lt;/dlt&gt;&lt;ins&gt;10&lt;/ins&gt; to &lt;dlt&gt;14&lt;/dlt&gt;&lt;ins&gt;26&lt;/ins&gt;, inclusive, scanldx is set equal to 2.</li>
<li>Otherwise if predModeIntra is in the range of &lt;dlt&gt;22&lt;/dlt&gt;&lt;ins&gt;42&lt;/ins&gt; to &lt;dlt&gt;30&lt;/dlt&gt;&lt;ins&gt;58&lt;/ins&gt;, inclusive, scanldx is set equal to 1.</li>
<li>Otherwise, scanldx is set equal to 0.</li>
</ul></li>
<li>Otherwise, scanldx is set equal to 0.</li>
</ul></p>
<heading id="h0010"><b>8.4.4.2.3 Filtering process of neighbouring samples</b></heading>
<p id="p0207" num="0207">Inputs to this process are:
<ul id="ul0037" list-style="dash">
<li>the neighbouring samples p[x][y], with x = -1, y = -1..nTbS * 2 - 1 and x = 0..nTbS * 2 - 1, y = -1,</li>
<li>a variable nTbS specifying the transform block size.</li>
</ul></p>
<p id="p0208" num="0208">Outputs of this process are the filtered samples pF[x][y], with x = -1, y = -1..nTbS * 2 - 1 and x = 0..nTbS * 2 - 1, y = -1.<!-- EPO <DP n="80"> --></p>
<p id="p0209" num="0209">The variable filterFlag is derived as follows:
<ul id="ul0038" list-style="dash" compact="compact">
<li>If one or more of the following conditions are true, filterFlag is set equal to 0:
<ul id="ul0039" list-style="dash">
<li>predModeIntra is equal to INTRA_DC.</li>
<li>nTbS is equal 4.</li>
</ul></li>
<li>Otherwise, the following applies:
<ul id="ul0040" list-style="dash">
<li>The variable minDistVerHor is set equal to Min(Abs(predModeIntra - 26), Abs(predModeIntra - 10)).</li>
<li>The variable intraHorVerDistThres[nTbS] is specified in Table 8-3.</li>
<li>The variable filterFlag is derived as follows:
<ul id="ul0041" list-style="dash">
<li>If minDistVerHor is greater than intraHorVerDistThres[nTbS], filterFlag is set equal to 1.</li>
<li>Otherwise, filterFlag is set equal to 0.</li>
</ul></li>
</ul></li>
</ul></p>
<heading id="h0011"><b>7.4.9.11 Residual coding semantics</b></heading>
<p id="p0210" num="0210">For intra prediction, different scanning orders are used. The variable scanldx specifies which scan order is used where scanldx equal to 0 specifies an up-right diagonal scan order, scanldx equal to 1 specifies a horizontal scan order, and scanIdx equal to 2 specifies a vertical scan order. The value of scanIdx is derived as follows:
<ul id="ul0042" list-style="dash" compact="compact">
<li>If CuPredMode[x0][y0] is equal to MODE_INTRA and one or more of the following conditions are true:
<ul id="ul0043" list-style="dash">
<li>log2TrafoSize is equal to 2.</li>
<li>log2TrafoSize is equal to 3 and cIdx is equal to 0.</li>
</ul>
predModeIntra is derived as follows:
<ul id="ul0044" list-style="dash">
<li>If cIdx is equal to 0, predModeIntra is set equal to IntraPredModeY[x0][y0].</li>
<li>Otherwise, predModeIntra is set equal to IntraPredModeC.</li>
</ul>
scanIdx is derived as follows:<!-- EPO <DP n="81"> -->
<ul id="ul0045" list-style="dash">
<li>If predModeIntra is in the range of &lt;dlt&gt;6&lt;/dlt&gt;&lt;ins&gt;10&lt;/ins&gt; to &lt;dlt&gt;14&lt;/dlt&gt;&lt;ins&gt;26&lt;/ins&gt;, inclusive, scanIdx is set equal to 2.</li>
<li>Otherwise if predModeIntra is in the range of &lt;dlt&gt;22&lt;/dlt&gt;&lt;ins&gt;42&lt;/ins&gt; to &lt;dlt&gt;30&lt;/dlt&gt;&lt;ins&gt;58&lt;/ins&gt;, inclusive, scanIdx is set equal to 1.</li>
<li>Otherwise, scanIdx is set equal to 0.</li>
</ul></li>
<li>Otherwise, scanIdx is set equal to 0.</li>
</ul></p>
<heading id="h0012"><b>8.4.4.2.3 Filtering process of neighbouring samples</b></heading>
<p id="p0211" num="0211">Inputs to this process are:
<ul id="ul0046" list-style="dash">
<li>the neighbouring samples p[x][y], with x = -1, y = -1..nTbS * 2 - 1 and x = 0..nTbS * 2 - 1, y = -1,</li>
<li>a variable nTbS specifying the transform block size.</li>
</ul></p>
<p id="p0212" num="0212">Outputs of this process are the filtered samples pF[x][y], with x = -1, y = -1..nTbS * 2 - 1 and x = 0..nTbS * 2 - 1, y = -1.</p>
<p id="p0213" num="0213">The variable filterFlag is derived as follows:
<ul id="ul0047" list-style="dash" compact="compact">
<li>If one or more of the following conditions are true, filterFlag is set equal to 0:
<ul id="ul0048" list-style="dash">
<li>predModeIntra is equal to INTRA_DC.</li>
<li>nTbS is equal 4.</li>
</ul></li>
<li>Otherwise, the following applies:
<ul id="ul0049" list-style="dash">
<li>The variable minDistVerHor is set equal to Min(Abs(predModeIntra - 26), Abs(predModeIntra - 10)).</li>
<li>The variable intraHorVerDistThres[nTbS] is specified in Table 8-3.</li>
<li>The variable filterFlag is derived as follows:
<ul id="ul0050" list-style="dash" compact="compact">
<li>If minDistVerHor is greater than intraHorVerDistThres[nTbS], filterFlag is set equal to 1.<!-- EPO <DP n="82"> --></li>
<li>Otherwise, filterFlag is set equal to 0.</li>
</ul></li>
</ul></li>
</ul>
<tables id="tabl0009" num="0009">
<table frame="all">
<title><b>Table 8-3 - Specification of intraHorVerDistThres[nTbS] for various transform block sizes</b></title>
<tgroup cols="4">
<colspec colnum="1" colname="col1" colwidth="50mm"/>
<colspec colnum="2" colname="col2" colwidth="33mm"/>
<colspec colnum="3" colname="col3" colwidth="28mm"/>
<colspec colnum="4" colname="col4" colwidth="26mm"/>
<thead>
<row>
<entry align="center" valign="top"/>
<entry align="center" valign="top"><b>nTbS = 8</b></entry>
<entry align="center" valign="top"><b>nTbS = 16</b></entry>
<entry align="center" valign="top"><b>nTbS = 32</b></entry></row></thead>
<tbody>
<row rowsep="0">
<entry align="center"><b>intraHorVerDistThres</b></entry>
<entry align="center">&lt;dlt&gt;7</entry>
<entry align="center">&lt;dlt&gt;1</entry>
<entry align="center">0</entry></row>
<row rowsep="0">
<entry align="center"><b>[nTbS]</b></entry>
<entry align="center">&lt;/dlt&gt;</entry>
<entry align="center">&lt;/dlt&gt;</entry>
<entry align="center"/></row>
<row rowsep="0">
<entry align="center"/>
<entry align="center">&lt;ins&gt;14&lt;/i</entry>
<entry align="center">&lt;ins&gt;2</entry>
<entry align="center"/></row>
<row>
<entry align="center"/>
<entry align="center">ns&gt;</entry>
<entry align="center">&lt;/ins&gt;</entry>
<entry align="center"/></row></tbody></tgroup>
</table>
</tables></p>
<p id="p0214" num="0214">When filterFlag is equal to 1, the following applies:</p>
<p id="p0215" num="0215">As described above, in accordance with some techniques of this disclosure, video encoder 20 and video decoder 30 may apply an <i>N</i>-tap intra interpolation filter. The following text describes example changes to JCTVC-N1003 to implement application of a 4-tap intra interpolation filter.</p>
<heading id="h0013"><u>&lt;ins&gt;<b>x.x.x Intra interpolation filter coefficients initialization process</b></u>&lt;/ins&gt;</heading>
<p id="p0216" num="0216">Output of this process is the array filterCubic[sFrac][pos]. The array index sFrac specifies the fractional position ranging from 0 to 31, pos specifies the filter coefficient for the pos<sup>th</sup> sample. The array filterCubic and filterGaussian is derived as follows:
<img id="ib0051" file="imgb0051.tif" wi="49" he="57" img-content="program-listing" img-format="tif"/><!-- EPO <DP n="83"> -->
<img id="ib0052" file="imgb0052.tif" wi="130" he="233" img-content="program-listing" img-format="tif"/><!-- EPO <DP n="84"> --></p>
<heading id="h0014"><b>8.4.4.2.6 Specification of intra prediction mode in the range of INTRA ANGULAR2.. INTRA ANGULAR34</b></heading>
<p id="p0217" num="0217">Inputs to this process are:
<ul id="ul0051" list-style="dash">
<li>the intra prediction mode predModeIntra,</li>
<li>the neighbouring samples p[x][y], with x = -1, y = -1..nTbS * 2 - 1 and<br/>
x = 0..nTbS * 2 - 1, y = -1,</li>
<li>a variable nTbS specifying the transform block size,</li>
<li>a variable cIdx specifying the colour component of the current block.</li>
</ul></p>
<p id="p0218" num="0218">Outputs of this process are the predicted samples predSamples[x][y], with x, y = 0..nTbS - 1.</p>
<p id="p0219" num="0219">The values of the prediction samples predSamples[x][y], with x, y = 0..nTbS - 1 are derived as follows:
<ul id="ul0052" list-style="dash" compact="compact">
<li>If predModeIntra is equal or greater than 18, the following ordered steps apply:
<ul id="ul0053" list-style="none" compact="compact">
<li>3. The reference sample array ref[x] is specified as follows:
<ul id="ul0054" list-style="dash" compact="compact">
<li>The following applies: <maths id="math0051" num="(8-47)"><math display="block"><mi>ref</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mo>=</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn><mo>+</mo><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mo>,</mo><mspace width="1ex"/><mi>with</mi><mspace width="1ex"/><mi mathvariant="normal">x</mi><mo>=</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>nTbS</mi></math><img id="ib0053" file="imgb0053.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
<li>If intraPredAngle is less than 0, the main reference sample array is extended as follows:
<ul id="ul0055" list-style="dash" compact="compact">
<li>When (nTbS * intraPredAngle) &gt;&gt; 5 is less than -1, <maths id="math0052" num="(8-48)"><math display="block"><mtable><mtr><mtd><mrow><mi>ref</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mo>=</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">x</mi><mo>*</mo><mi>invAngle</mi><mo>+</mo><mn>128</mn></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>8</mn></mfenced></mfenced><mo>,</mo></mrow></mtd></mtr><mtr><mtd><mrow><mi>with</mi><mspace width="1ex"/><mi mathvariant="normal">x</mi><mo>=</mo><mo>−</mo><mn>1</mn><mo>.</mo><mo>.</mo><mfenced separators=""><mi>nTbS</mi><mo>*</mo><mi>intraPredAngle</mi></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>5</mn></mrow></mtd></mtr></mtable><mspace width="1ex"/></math><img id="ib0054" file="imgb0054.tif" wi="117" he="13" img-content="math" img-format="tif"/></maths></li>
</ul></li>
<li>Otherwise, <maths id="math0053" num="(8-49)"><math display="block"><mi>ref</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mo>=</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn><mo>+</mo><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mo>,</mo><mspace width="1ex"/><mi>with</mi><mspace width="1ex"/><mi mathvariant="normal">x</mi><mo>=</mo><mi>nTbS</mi><mo>+</mo><mi mathvariant="normal">1</mi><mi>..</mi><mi>2*nTbS</mi></math><img id="ib0055" file="imgb0055.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
</ul></li>
<li>4. The values of the prediction samples predSamples[x][y], with x, y = 0..nTbS - 1 are derived as follows:<!-- EPO <DP n="85"> -->
<ol id="ol0009" compact="compact" ol-style="">
<li>a. The index variable ildx and the multiplication factor iFact are derived as follows: <maths id="math0054" num="(8-50)"><math display="block"><mi>iIdx</mi><mo>=</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">y</mi><mo>+</mo><mn>1</mn></mfenced><mo>*</mo><mi>intraPredAngle</mi></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>5</mn></math><img id="ib0056" file="imgb0056.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0055" num="(8-51)"><math display="block"><mi>iFact</mi><mo>=</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">y</mi><mo>+</mo><mn>1</mn></mfenced><mo>*</mo><mi>intraPredAngle</mi></mfenced><mo>&amp;</mo><mn>31</mn></math><img id="ib0057" file="imgb0057.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
<li>b. Depending on the value of iFact, the following applies:
<ul id="ul0056" list-style="dash" compact="compact">
<li>If iFact is not equal to 0, the value of the prediction samples predSamples[x][y] is derived as follows: <maths id="math0056" num="(8-52)"><math display="block"><mtable columnalign="left"><mtr><mtd><mi>&lt;dlt&gt;predSamples</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>=</mo></mtd></mtr><mtr><mtd><mfenced separators=""><mfenced separators=""><mn>32</mn><mo>−</mo><mi>iFact</mi></mfenced><mo>*</mo><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>1</mn></mfenced><mo>+</mo><mi>iFact</mi><mo>*</mo><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>2</mn></mfenced><mo>+</mo><mn>16</mn></mfenced><mo>&gt;</mo><mo>&gt;</mo></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></math><img id="ib0058" file="imgb0058.tif" wi="126" he="20" img-content="math" img-format="tif"/></maths> &lt;ins&gt;For p=0,..,3, pF[p] = (cIdx==0 &amp;&amp; nTbS&lt;=8) ? filterCubic[iFact][p] : filterGaussian[iFact][p] <maths id="math0057" num=""><math display="block"><mi mathvariant="normal">P</mi><mfenced open="[" close="]"><mn>1</mn></mfenced><mo>=</mo><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>1</mn></mfenced></math><img id="ib0059" file="imgb0059.tif" wi="43" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0058" num=""><math display="block"><mi mathvariant="normal">P</mi><mfenced open="[" close="]"><mn>2</mn></mfenced><mo>=</mo><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>2</mn></mfenced></math><img id="ib0060" file="imgb0060.tif" wi="43" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0059" num=""><math display="block"><mi mathvariant="normal">P</mi><mfenced open="[" close="]"><mn>0</mn></mfenced><mo>=</mo><mfenced separators=""><mi mathvariant="normal">x</mi><mo>=</mo><mo>=</mo><mn>0</mn></mfenced><mi mathvariant="normal">?</mi><mspace width="1ex"/><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>1</mn></mfenced><mspace width="1ex"/><mo>:</mo><mspace width="1ex"/><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mi>iIdx</mi></mfenced></math><img id="ib0061" file="imgb0061.tif" wi="87" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0060" num=""><math display="block"><mi mathvariant="normal">P</mi><mfenced open="[" close="]"><mn>3</mn></mfenced><mo>=</mo><mfenced separators=""><mi mathvariant="normal">x</mi><mo>=</mo><mo>=</mo><mi>nTbS</mi><mo>−</mo><mi mathvariant="normal">1</mi></mfenced><mi mathvariant="normal">?</mi><mspace width="1ex"/><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>2</mn></mfenced><mspace width="1ex"/><mo>:</mo><mspace width="1ex"/><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mi mathvariant="normal">3</mi></mfenced></math><img id="ib0062" file="imgb0062.tif" wi="101" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0061" num="(8-52)"><math display="block"><mtable columnalign="left"><mtr><mtd><mi>predSamples</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>=</mo></mtd></mtr><mtr><mtd><mspace width="1em"/><mspace width="1em"/><mspace width="1em"/><mspace width="1em"/><mrow><mo>(</mo><mrow><mi>pF</mi><mfenced open="[" close="]"><mn>0</mn></mfenced><mo>*</mo><mi mathvariant="normal">P</mi><mfenced open="[" close="]"><mn>0</mn></mfenced><mo>+</mo><mi>pF</mi><mfenced open="[" close="]"><mn>1</mn></mfenced><mo>*</mo><mi mathvariant="normal">P</mi><mfenced open="[" close="]"><mn>1</mn></mfenced><mo>+</mo><mi>pF</mi><mfenced open="[" close="]"><mn>2</mn></mfenced><mo>*</mo><mi mathvariant="normal">P</mi><mfenced open="[" close="]"><mn>2</mn></mfenced><mo>+</mo></mrow></mrow></mtd></mtr><mtr><mtd><mrow><mrow><mi>pF</mi><mfenced open="[" close="]"><mn>3</mn></mfenced><mo>*</mo><mi mathvariant="normal">P</mi><mfenced open="[" close="]"><mn>3</mn></mfenced><mo>+</mo><mn>128</mn></mrow><mo>)</mo></mrow><mo>&gt;</mo><mo>&gt;</mo><mn>8</mn><mspace width="1em"/><mfenced separators=""><mn>8</mn><mo>−</mo><mn>52</mn></mfenced><mo>&lt;</mo><mi>/ins</mi><mo>&gt;</mo></mtd></mtr></mtable></math><img id="ib0063" file="imgb0063.tif" wi="101" he="20" img-content="math" img-format="tif"/></maths></li>
<li>Otherwise, the value of the prediction samples predSamples[x][y] is derived as follows: <maths id="math0062" num="(8-53)"><math display="block"><mi>predSamples</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>=</mo><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>1</mn></mfenced></math><img id="ib0064" file="imgb0064.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
</ul></li>
<li>c. When predModeIntra is equal to 26 (vertical), cIdx is equal to 0 and nTbS is less than 32, the following filtering applies with x = 0, y = 0..nTbS - 1: <maths id="math0063" num="(8-54)"><math display="block"><mtable columnalign="left"><mtr><mtd><mi>predSamples</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>=</mo></mtd></mtr><mtr><mtd><msub><mi>Clip1</mi><mi mathvariant="normal">Y</mi></msub><mfenced separators=""><mi mathvariant="normal">p</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mo>+</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>−</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>1</mn></mfenced></mfenced></mtd></mtr></mtable></math><img id="ib0065" file="imgb0065.tif" wi="126" he="13" img-content="math" img-format="tif"/></maths></li>
</ol></li>
</ul></li>
<li>Otherwise (predModeIntra is less than 18), the following ordered steps apply:<!-- EPO <DP n="86"> -->
<ul id="ul0057" list-style="none" compact="compact">
<li>3. The reference sample array ref[x] is specified as follows:
<ul id="ul0058" list-style="dash" compact="compact">
<li>The following applies: <maths id="math0064" num="(8-55)"><math display="block"><mi>ref</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mo>=</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn><mo>+</mo><mi mathvariant="normal">x</mi></mfenced><mo>,</mo><mspace width="1ex"/><mi>with</mi><mspace width="1ex"/><mi mathvariant="normal">x</mi><mo>=</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>nTbS</mi></math><img id="ib0066" file="imgb0066.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
<li>If intraPredAngle is less than 0, the main reference sample array is extended as follows:
<ul id="ul0059" list-style="dash" compact="compact">
<li>When (nTbS * intraPredAngle) &gt;&gt; 5 is less than -1, <maths id="math0065" num="(8-56)"><math display="block"><mtable><mtr><mtd><mrow><mi>ref</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mo>=</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn><mo>+</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">x</mi><mo>*</mo><mi>invAngle</mi><mo>+</mo><mn>128</mn></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>8</mn></mfenced></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mo>,</mo></mrow></mtd></mtr><mtr><mtd><mrow><mi>with</mi><mspace width="1ex"/><mi mathvariant="normal">x</mi><mo>=</mo><mo>−</mo><mn>1</mn><mo>.</mo><mo>.</mo><mfenced separators=""><mi>nTbS</mi><mo>*</mo><mi>intraPredAngle</mi></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>5</mn></mrow></mtd></mtr></mtable><mspace width="1ex"/></math><img id="ib0067" file="imgb0067.tif" wi="117" he="13" img-content="math" img-format="tif"/></maths></li>
</ul></li>
<li>Otherwise, <maths id="math0066" num="(8-57)"><math display="block"><mi>ref</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mo>=</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn><mo>+</mo><mi mathvariant="normal">x</mi></mfenced><mo>,</mo><mspace width="1ex"/><mi>with</mi><mspace width="1ex"/><mi mathvariant="normal">x</mi><mo>=</mo><mi>nTbS</mi><mo>+</mo><mi mathvariant="normal">1</mi><mi>..</mi><mi>2*nTbS</mi></math><img id="ib0068" file="imgb0068.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
</ul></li>
<li>4. The values of the prediction samples predSamples[x][y], with x, y = 0..nTbS - 1 are derived as follows:
<ul id="ul0060" list-style="none" compact="compact">
<li>d. The index variable ildx and the multiplication factor iFact are derived as follows: <maths id="math0067" num="(8-58)"><math display="block"><mi>iIdx</mi><mo>=</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mn>1</mn></mfenced><mo>*</mo><mi>intraPredAngle</mi></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>5</mn></math><img id="ib0069" file="imgb0069.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0068" num="(8-59)"><math display="block"><mi>iFact</mi><mo>=</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">x</mi><mo>+</mo><mn>1</mn></mfenced><mo>*</mo><mi>intraPredAngle</mi></mfenced><mo>&amp;</mo><mn>31</mn></math><img id="ib0070" file="imgb0070.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
<li>e. Depending on the value of iFact, the following applies:
<ul id="ul0061" list-style="dash" compact="compact">
<li>If iFact is not equal to 0, the value of the prediction samples predSamples[x][y] is derived as follows: <maths id="math0069" num="(8-60)"><math display="block"><mtable columnalign="left"><mtr><mtd><mi>predSamples</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>=</mo></mtd></mtr><mtr><mtd><mfenced separators=""><mfenced separators=""><mn>32</mn><mo>−</mo><mi>iFact</mi></mfenced><mo>*</mo><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">y</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>1</mn></mfenced><mo>+</mo><mi>iFact</mi><mo>*</mo><mi>ref</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">y</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>2</mn></mfenced><mo>+</mo><mn>16</mn></mfenced><mo>&gt;</mo><mo>&gt;</mo></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></math><img id="ib0071" file="imgb0071.tif" wi="125" he="20" img-content="math" img-format="tif"/></maths></li>
<li>Otherwise, the value of the prediction samples predSamples[x][y] is derived as follows: <maths id="math0070" num="(8-61)"><math display="block"><mi>predSamples</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>=</mo><mi>ref</mi><mrow><mo>[</mo><mrow><mi mathvariant="normal">y</mi><mo>+</mo><mi>iIdx</mi><mo>+</mo><mn>1</mn></mrow></mrow></math><img id="ib0072" file="imgb0072.tif" wi="126" he="5" img-content="math" img-format="tif"/></maths></li>
</ul><!-- EPO <DP n="87"> --></li>
<li>f. When predModeIntra is equal to 10 (horizontal), cIdx is equal to 0 and nTbS is less than 32, the following filtering applies with x = 0..nTbS - 1, y = 0: <maths id="math0071" num="(8-62)"><math display="block"><mtable columnalign="left"><mtr><mtd><mi>predSamples</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>=</mo></mtd></mtr><mtr><mtd><msub><mi>Clip1</mi><mi mathvariant="normal">Y</mi></msub><mfenced separators=""><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mfenced open="[" close="]"><mi mathvariant="normal">y</mi></mfenced><mo>+</mo><mfenced separators=""><mfenced separators=""><mi mathvariant="normal">p</mi><mfenced open="[" close="]"><mi mathvariant="normal">x</mi></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mo>−</mo><mi mathvariant="normal">p</mi><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced><mfenced open="[" close="]" separators=""><mo>−</mo><mn>1</mn></mfenced></mfenced><mo>&gt;</mo><mo>&gt;</mo><mn>1</mn></mfenced></mfenced></mtd></mtr></mtable></math><img id="ib0073" file="imgb0073.tif" wi="126" he="12" img-content="math" img-format="tif"/></maths></li>
</ul></li>
</ul></li>
</ul></p>
<p id="p0220" num="0220">The methods further described in accordance with techniques of this disclosure are not according to the invention and are present for illustration purposes only.</p>
<p id="p0221" num="0221"><figref idref="f0010">FIG. 10</figref> is a flowchart illustrating a method of encoding video data in accordance with techniques of this disclosure. <figref idref="f0010">FIG. 10</figref> is described with reference to a generic video encoder. The generic video encoder may, for example, correspond to video encoder 20, although the techniques of this disclosure are not limited to any specific type of video encoder. The video encoder derives, from among a plurality of intra prediction modes, MMPMs for intra prediction of a block of video data (200). In one example, <i>M</i> may be greater than 3. The video encoder encodes a syntax element that indicates whether a MPM index or a non-MPM index is used to indicate a selected intra prediction mode (202) of the plurality of intra prediction modes for intra prediction of the block of video data. The MPM index indicates which of the <i>M</i> MPMs is the selected intra prediction mode. The non-MPM index indicates which of the plurality of intra prediction modes other than the <i>M</i> MPMs is the selected intra prediction mode. Based on the indicated one of the MPM index or the non-MPM index being the MPM index, the video encoder selects, for each of one or more context-modeled bins of the MPM index, based on intra prediction modes used to decode one or more neighboring blocks, a context index for the context-modeled bin (204). The video encoder encodes the block of video data based on the selected intra prediction mode (206).</p>
<p id="p0222" num="0222"><figref idref="f0011">FIG. 11</figref> is a flowchart illustrating a method of decoding video data in accordance with techniques of this disclosure. <figref idref="f0011">FIG. 11</figref> is described with reference to a generic video decoder. The generic video decoder may, for example, correspond to video decoder 30, although the techniques of this disclosure are not limited to any specific type of video decoder. The video decoder derives, from among a plurality of intra prediction modes, <i>M</i> MPMs for intra prediction of a block of video data (220). In one example, <i>M</i> may be greater than 3. The video decoder encodes a syntax element that indicates whether a MPM index or a non-MPM index is used to indicate a selected intra prediction mode (222) of the plurality of intra prediction modes for intra prediction of the block of video data. The MPM index indicates which of the <i>M</i> MPMs is the selected intra prediction mode. The non-MPM index indicates which of the plurality of<!-- EPO <DP n="88"> --> intra prediction modes other than the MMPMs is the selected intra prediction mode. Based on the indicated one of the MPM index or the non-MPM index being the MPM index, the video decoder selects, for each of one or more context-modeled bins of the MPM index, based on intra prediction modes used to decode one or more neighboring blocks, a context index for the context-modeled bin (224). The video decoder reconstructs the block of video data based on the selected intra prediction mode (226).</p>
<p id="p0223" num="0223"><figref idref="f0012">FIG. 12</figref> is a flowchart illustrating a method of encoding video data in accordance with techniques of this disclosure. <figref idref="f0012">FIG. 12</figref> is described with reference to a generic video encoder. The generic video encoder may, for example, correspond to video encoder 20, although the techniques of this disclosure are not limited to any specific type of video encoder. The video encoder derives <i>M</i> MPMs (300) for intra prediction of the block of video data from among a plurality of intra prediction modes. In one example, <i>M</i> may be greater than 3 and the MPMs may include an MPM for a left neighboring column and an MPM for an above neighboring row. In one example, the <i>M</i> MPMs may be derived by at least one of (i) defining a representative intra prediction mode for the left neighboring column and using the representative intra prediction mode for the left neighboring column as the MPM for the left neighboring column (302), or (ii) defining a representative intra prediction mode for the above neighboring row and using the representative intra prediction mode for the above neighboring row as the MPM for the above neighboring row (304).</p>
<p id="p0224" num="0224">The video encoder may encode a syntax element that indicates whether a MPM index or a non-MPM index is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the block of video data (306). Additionally, the video encoder may encode the indicated one of the MPM index or the non-MPM index (308). The MPM index indicates which of the <i>M</i> MPMs is the selected intra prediction mode. The non-MPM index indicates which of the plurality of intra prediction modes other than the <i>M</i> MPM is the selected intra prediction mode. The video encoder may encode the block of video data based on the selected intra prediction mode (310).</p>
<p id="p0225" num="0225"><figref idref="f0013">FIG. 13</figref> is a flowchart illustrating a method of decoding video data in accordance with techniques of this disclosure. <figref idref="f0013">FIG. 13</figref> is described with reference to a generic video decoder. The generic video decoder may, for example, correspond to video decoder 30, although the techniques of this disclosure are not limited to any<!-- EPO <DP n="89"> --> specific type of video decoder. The video decoder derives <i>M</i> MPMs for intra prediction of the block of video data from among a plurality of intra prediction modes (350). In one example, <i>M</i> may be greater than 3 and the MPMs may include an MPM for a left neighboring column and an MPM for an above neighboring row. The <i>M</i> most probable modes may be derived by at least one of (i) defining a representative intra prediction mode for the left neighboring column and using the representative intra prediction mode for the left neighboring column as the MPM for the left neighboring column (352), or (ii) defining a representative intra prediction mode for the above neighboring row and using the representative intra prediction mode for the above neighboring row as the MPM for the above neighboring row (354).</p>
<p id="p0226" num="0226">The video decoder may decode a syntax element that indicates whether a MPM index or a non-MPM index is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the block of video data (356). Additionally, the video decoder may decode the indicated one of the MPM index or the non-MPM index (358). The MPM index indicates which of the <i>M</i> MPMs is the selected intra prediction mode. The non-MPM index indicates which of the plurality of intra prediction modes other than the MMPM is the selected intra prediction mode. The video decoder may encode the block of video data based on the selected intra prediction mode (360).</p>
<p id="p0227" num="0227"><figref idref="f0014">FIG. 14</figref> is a flowchart illustrating a method of encoding video data in accordance with techniques of this disclosure. <figref idref="f0014">FIG. 14</figref> is described with reference to a generic video encoder. The generic video encoder may, for example, correspond to video encoder 20, although the techniques of this disclosure are not limited to any specific type of video encoder. The video encoder derives <i>M</i> MPMs (400) for intra prediction of the block of video data from among a plurality of intra prediction modes. In one example, <i>M</i> may be greater than 3. The video encoder encodes a syntax element that indicates whether a MPM index or a non-MPM index is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the block of video data (402). In the example of <figref idref="f0012">FIG. 12</figref>, the MPM index indicates which of the <i>M</i> MPMs is the selected intra prediction mode. Furthermore, the non-MPM index indicates which of the plurality of intra prediction modes other than the <i>M</i> MPMs is the selected intra prediction mode. Based on the MPM index indicating the selected intra prediction mode, the video encoder encodes the non-MPM index (404).<!-- EPO <DP n="90"> --> In the example of <figref idref="f0014">FIG. 14</figref>, the non-MPM index is encoded in the bitstream as a code word shorter than ┌log<sub>2</sub> <i>N</i>┐ bits if the non-MPM index satisfies a criterion and is encoded in the bitstream as a fixed length code with ┌log<sub>2</sub> <i>N</i>┐ bits otherwise. In the example of <figref idref="f0014">FIG. 14</figref>, there is a total of N available values of the non-MPM index. The video encoder encodes the block of video data based on the selected intra prediction mode (406).</p>
<p id="p0228" num="0228"><figref idref="f0015">FIG. 15</figref> is a flowchart illustrating a method of decoding video data in accordance with techniques of this disclosure. <figref idref="f0015">FIG. 15</figref> is described with reference to a generic video decoder. The generic video decoder may, for example, correspond to video decoder 30, although the techniques of this disclosure are not limited to any specific type of video decoder. The video decoder derives <i>M</i> MPMs for intra prediction of the block of video data from among a plurality of intra prediction modes (450). In one example, <i>M</i> may be greater than 3. The video decoder decodes a syntax element that indicates whether a MPM index or a non-MPM index is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the block of video data (452). The MPM index indicates which of the <i>M</i> MPMs is the selected intra prediction mode. The non-MPM index indicates which of the plurality of intra prediction modes other than the <i>M</i> MPMs is the selected intra prediction mode. Based on the MPM index indicating the selected intra prediction mode, the video decoder decodes the non-MPM index (454). In the example of <figref idref="f0015">FIG. 15</figref>, the non-MPM index is encoded in the bitstream as a code word shorter than ┌log<sub>2</sub> <i>N</i>┐ bits if the non-MPM index satisfies a criterion and is encoded in the bitstream as a fixed length code with ┌log<sub>2</sub> <i>N</i>┐ bits otherwise. In the example of <figref idref="f0015">FIG. 15</figref>, there may be a total of <i>N</i> available values of the non-MPM index. Furthermore, in the example of <figref idref="f0015">FIG. 15</figref>, the video decoder reconstructs the block of video data based on the selected intra prediction mode (456).</p>
<p id="p0229" num="0229"><figref idref="f0016">FIG. 16</figref> is a flowchart illustrating a method of encoding video data in accordance with techniques of this disclosure. <figref idref="f0016">FIG. 16</figref> is described with reference to a generic video encoder. The generic video encoder may, for example, correspond to video encoder 20, although the techniques of this disclosure are not limited to any specific type of video encoder. The video encoder derives <i>M</i> MPMs for intra prediction of the block of video data from among a plurality of intra prediction modes (600). In the example of <figref idref="f0016">FIG. 16</figref>, <i>M</i> is greater than 3. The video encoder encodes a syntax<!-- EPO <DP n="91"> --> element that indicates whether a MPM index or a non-MPM index is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the block of video data (602). The video encoder encodes the indicated one of the MPM index or the non-MPM index (604). The MPM index indicates which of the MMPMs is the selected intra prediction mode. The non-MPM index indicates which of the plurality of intra prediction modes other than the <i>M</i> MPMs is the selected intra prediction mode. The video encoder encodes the block of video data based on the selected intra prediction mode (606).</p>
<p id="p0230" num="0230"><figref idref="f0017">FIG. 17</figref> is a flowchart illustrating a method of decoding video data in accordance with techniques of this disclosure. <figref idref="f0017">FIG. 17</figref> is described with reference to a generic video decoder. The generic video decoder may, for example, correspond to video decoder 30, although the techniques of this disclosure are not limited to any specific type of video decoder. The video decoder derives <i>M</i> MPMs for intra prediction of the block of video data from among a plurality of intra prediction modes (650). In the example of <figref idref="f0017">FIG. 17</figref>, <i>M</i> is greater than 3. The video decoder decodes a syntax element that indicates whether a MPM index or a non-MPM index is used to indicate a selected intra prediction mode of the plurality of intra prediction modes for intra prediction of the block of video data (652). The video decoder decodes the indicated one of the MPM index or the non-MPM index (654). The MPM index indicates which of the <i>M</i> MPMs is the selected intra prediction mode. The non-MPM index indicates which of the plurality of intra prediction modes other than the <i>M</i> MMMs is the selected intra prediction mode (654). The video decoder reconstructs the block of video data based on the selected intra prediction mode (656).</p>
<p id="p0231" num="0231"><figref idref="f0018">FIG. 18</figref> is a flowchart illustrating a method of encoding video data in accordance with techniques of this disclosure. <figref idref="f0018">FIG. 18</figref> is described with reference to a generic video encoder. The generic video encoder may, for example, correspond to video encoder 20, although the techniques of this disclosure are not limited to any specific type of video encoder. The video encoder encodes syntax information that indicates a selected intra prediction mode for the block of video data from among a plurality of intra prediction modes (700). In one example, the plurality of intra prediction modes may include greater than 33 angular intra prediction modes. The angular intra prediction modes may be defined such that interpolation is performed in<!-- EPO <DP n="92"> --> 1/32 pel accuracy. The video encoder encodes the block of video data based on the selected intra prediction mode (702).</p>
<p id="p0232" num="0232"><figref idref="f0018">FIG. 19</figref> is a flowchart illustrating a method of decoding video data in accordance with techniques of this disclosure. <figref idref="f0018">FIG. 19</figref> is described with reference to a generic video decoder. The generic video decoder may, for example, correspond to video decoder 30, although the techniques of this disclosure are not limited to any specific type of video decoder. The video decoder decodes syntax information that indicates a selected intra prediction mode for the block of video data from among a plurality of intra prediction modes (750). In one example, the plurality of intra prediction modes may include greater than 33 angular intra prediction modes, and the angular intra prediction modes may be defined such that interpolation is performed in 1/32 pel accuracy. The video decoder may reconstruct the block of video data based on the selected intra prediction mode (752).</p>
<p id="p0233" num="0233"><figref idref="f0019">FIG. 20</figref> is a flowchart illustrating a method of encoding video data in accordance with techniques of this disclosure. <figref idref="f0019">FIG. 20</figref> is described with reference to a generic video encoder. The generic video encoder may, for example, correspond to video encoder 20, although the techniques of this disclosure are not limited to any specific type of video encoder. The video encoder encodes syntax information that indicates a selected intra prediction mode for the block of video data from among a plurality of intra prediction modes (800). The video encoder applies an <i>N</i>-tap intra interpolation filter to neighboring reconstructed samples of the block of video data according to the selected intra prediction mode (802). In one example, <i>N</i> may be greater than 2. The video encoder may encode the block of video data based on the filtered neighboring reconstructed samples according to the selected intra prediction mode (804).</p>
<p id="p0234" num="0234"><figref idref="f0020">FIG. 21</figref> is a flowchart illustrating a method of decoding video data in accordance with techniques of this disclosure. <figref idref="f0020">FIG. 21</figref> is described with reference to a generic video decoder. The generic video decoder may, for example, correspond to video decoder 30, although the techniques of this disclosure are not limited to any specific type of video decoder. The video decoder decodes syntax information that indicates a selected intra prediction mode for a block of video data from among a plurality of intra prediction modes (850). The video decoder applies an <i><u>N</u></i>-tap intra interpolation filter to neighboring reconstructed samples of the block of video data<!-- EPO <DP n="93"> --> according to the selected intra prediction mode (852). In one example, <i>N</i> may be greater than 2. The video decoder may reconstruct the block of video data based on the filtered neighboring reconstructed samples according to the selected intra prediction mode (854).</p>
<p id="p0235" num="0235">In one or more examples, the functions described may be implemented in hardware, software, firmware, or any combination thereof. If implemented in software, the functions may be stored on or transmitted over as one or more instructions or code on a computer-readable medium and executed by a hardware-based processing unit. Computer-readable media may include computer-readable storage media, which corresponds to a tangible medium such as data storage media, or communication media including any medium that facilitates transfer of a computer program from one place to another, e.g., according to a communication protocol. In this manner, computer-readable media generally may correspond to (1) tangible computer-readable storage media which is non-transitory or (2) a communication medium such as a signal or carrier wave. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions, code and/or data structures for implementation of the techniques described in this disclosure. A computer program product may include a computer-readable medium.</p>
<p id="p0236" num="0236">By way of example, and not limitation, such computer-readable storage media can comprise RAM, ROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage, or other magnetic storage devices, flash memory, or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. Also, any connection is properly termed a computer-readable medium. For example, if instructions are transmitted from a website, server, or other remote source using a coaxial cable, fiber optic cable, twisted pair, digital subscriber line (DSL), or wireless technologies such as infrared, radio, and microwave, then the coaxial cable, fiber optic cable, twisted pair, DSL, or wireless technologies such as infrared, radio, and microwave are included in the definition of medium. It should be understood, however, that computer-readable storage media and data storage media do not include connections, carrier waves, signals, or other transitory media, but are instead directed to non-transitory, tangible storage media. Disk and disc, as used herein, includes compact disc (CD), laser disc, optical disc, digital versatile disc (DVD), floppy disk and blu-ray disc where disks usually reproduce data magnetically,<!-- EPO <DP n="94"> --> while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer-readable media.</p>
<p id="p0237" num="0237">Instructions may be executed by one or more processors, such as one or more digital signal processors (DSPs), general purpose microprocessors, application specific integrated circuits (ASICs), field programmable logic arrays (FPGAs), or other equivalent integrated or discrete logic circuitry. Accordingly, the term "processor," as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. In addition, in some aspects, the functionality described herein may be provided within dedicated hardware and/or software modules configured for encoding and decoding, or incorporated in a combined codec. Also, the techniques could be fully implemented in one or more circuits or logic elements.</p>
<p id="p0238" num="0238">The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses, including a wireless handset, an integrated circuit (IC) or a set of ICs (e.g., a chip set). Various components, modules, or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques, but do not necessarily require realization by different hardware units. Rather, as described above, various units may be combined in a codec hardware unit or provided by a collection of interoperative hardware units, including one or more processors as described above, in conjunction with suitable software and/or firmware.</p>
</description>
<claims id="claims01" lang="en"><!-- EPO <DP n="95"> -->
<claim id="c-en-01-0001" num="0001">
<claim-text>A method of decoding a block of video data, the method comprising:
<claim-text>selecting, based on intra prediction modes used to decode one or more neighboring blocks of the block of video data, a subset of 33 angular intra prediction modes from among a plurality of intra prediction modes, wherein the plurality of intra prediction modes includes 65 angular intra prediction modes;</claim-text>
<claim-text>decoding (750) syntax information that indicates a selected intra prediction mode for a current prediction unit, PU, of the block of video data from among the subset of 33 angular intra prediction modes; and</claim-text>
<claim-text>reconstructing (752) the block of video data based on the selected intra prediction mode using 1/32 pel interpolation accuracy, wherein reconstructing the block of video data comprises:<br/>
for each respective sample of a predictive block of the current PU:
<claim-text>determining a fractional position between two neighboring reconstructed samples by projecting, along a prediction direction associated with the selected intra prediction mode, a coordinate of the respective sample to a row or column of neighboring reconstructed samples containing the two neighboring reconstructed samples, wherein the two neighboring reconstructed samples neighbor the current PU; and</claim-text>
<claim-text>calculating a value of the respective sample using an interpolation filter that uses values of the two neighboring reconstructed samples to interpolate a value at the determined fractional position, the interpolation being in 1/32 pel accuracy.</claim-text></claim-text></claim-text></claim>
<claim id="c-en-01-0002" num="0002">
<claim-text>The method of claim 1, further comprising determining, based on at least one of a coding unit size or a prediction unit size, a total number of intra prediction modes in the plurality of intra prediction modes.<!-- EPO <DP n="96"> --></claim-text></claim>
<claim id="c-en-01-0003" num="0003">
<claim-text>The method of claim 1, wherein a total number of intra prediction modes in the plurality of intra prediction modes is signaled in at least one of: a sequence parameter set, picture parameter set, or a slice header.</claim-text></claim>
<claim id="c-en-01-0004" num="0004">
<claim-text>The method of claim 1, wherein the interpolation filter is formulated as: <maths id="math0072" num=""><math display="block"><msub><mi mathvariant="normal">p</mi><mi>xy</mi></msub><mo>=</mo><mfenced separators=""><mn>1</mn><mo>−</mo><mi mathvariant="normal">α</mi></mfenced><mo>⋅</mo><mi mathvariant="normal">L</mi><mo>+</mo><mi mathvariant="normal">α</mi><mo>⋅</mo><mi mathvariant="normal">R</mi><mo>,</mo></math><img id="ib0074" file="imgb0074.tif" wi="37" he="5" img-content="math" img-format="tif"/></maths> where p<sub>xy</sub> is the calculated value of the respective sample, L and R are values of the two reconstructed neighboring samples, and α is the determined fractional position.</claim-text></claim>
<claim id="c-en-01-0005" num="0005">
<claim-text>A method of encoding a block of video data, the method comprising:
<claim-text>selecting, based on intra prediction modes used to encode one or more neighboring blocks of the block of video data, a subset of 33 angular intra prediction modes from among a plurality of intra prediction modes, wherein the plurality of intra prediction modes includes 65 angular intra prediction modes;</claim-text>
<claim-text>encoding (700) syntax information that indicates a selected intra prediction mode for a current prediction unit, PU, of the block of video data from among the subset of 33 angular intra prediction modes; and</claim-text>
<claim-text>encoding (702) the block of video data based on the selected intra prediction mode using 1/32 pel interpolation accuracy, wherein encoding the block of video data comprises:<br/>
for each respective sample of a predictive block of the current PU:
<claim-text>determining a fractional position between two neighboring reconstructed samples by projecting, along a prediction direction associated with the selected intra prediction mode, a coordinate of the respective sample to a row or column of neighboring reconstructed samples containing the two neighboring reconstructed samples, wherein the two neighboring reconstructed samples neighbor the current PU; and</claim-text>
<claim-text>calculating a prediction value of the respective sample using an interpolation filter that uses values of the two neighboring reconstructed samples to interpolate a value at the determined fractional position, the interpolation being in 1/32 pel accuracy.</claim-text></claim-text><!-- EPO <DP n="97"> --></claim-text></claim>
<claim id="c-en-01-0006" num="0006">
<claim-text>The method of claim 5, further comprising determining, based on at least one of a coding unit size or a prediction unit size, a total number of intra prediction modes in the plurality of intra prediction modes.</claim-text></claim>
<claim id="c-en-01-0007" num="0007">
<claim-text>The method of claim 5, wherein a total number of intra prediction modes in the plurality of intra prediction modes is signaled in at least one of: a sequence parameter set, picture parameter set, or a slice header.</claim-text></claim>
<claim id="c-en-01-0008" num="0008">
<claim-text>The method of claim 5, wherein the interpolation filter is formulated as: <maths id="math0073" num=""><math display="block"><msub><mi mathvariant="normal">p</mi><mi>xy</mi></msub><mo>=</mo><mfenced separators=""><mn>1</mn><mo>−</mo><mi mathvariant="normal">α</mi></mfenced><mo>⋅</mo><mi mathvariant="normal">L</mi><mo>+</mo><mi mathvariant="normal">α</mi><mo>⋅</mo><mi mathvariant="normal">R</mi><mo>,</mo></math><img id="ib0075" file="imgb0075.tif" wi="37" he="5" img-content="math" img-format="tif"/></maths> where p<sub>xy</sub> is the calculated value of the respective sample, L and R are values of the two reconstructed neighboring samples, and α is the determined fractional position.</claim-text></claim>
<claim id="c-en-01-0009" num="0009">
<claim-text>A device for decoding video data, the device comprising:<br/>
a memory configured to store the video data; and<br/>
one or more processors configured to:
<claim-text>select, based on intra prediction modes used to decode one or more neighboring blocks of a block of video data in a current picture of video data, a subset of 33 angular intra prediction modes from among a plurality of intra prediction modes, wherein the plurality of intra prediction modes includes 65 angular intra prediction modes;</claim-text>
<claim-text>decode (750) syntax information that indicates a selected intra prediction mode for a current prediction unit, PU, of the block of video data from among the subset of 33 angular intra prediction modes; and</claim-text>
<claim-text>reconstruct (752) the block of video data based on the selected intra prediction mode, the angular intra prediction modes defined such that interpolation is performed in 1/32 pel accuracy, wherein reconstructing the block of video data comprises:<br/>
for each respective sample of a predictive block of the current PU:
<claim-text>determining a fractional position between two neighboring reconstructed samples by projecting, along a prediction direction associated with the selected intra prediction mode, a coordinate of the respective sample to a row or column of neighboring reconstructed samples containing the two<!-- EPO <DP n="98"> --> neighboring reconstructed samples, wherein the two neighboring reconstructed samples neighbor the current PU; and</claim-text>
<claim-text>calculating a value of the respective sample using an interpolation filter that uses values of the two neighboring reconstructed samples to interpolate a value at the determined fractional position, the interpolation being in 1/32 pel accuracy.</claim-text></claim-text></claim-text></claim>
<claim id="c-en-01-0010" num="0010">
<claim-text>A device for encoding video data, the device comprising:<br/>
a memory configured to store the video data; and<br/>
one or more processors configured to:
<claim-text>select, based on intra prediction modes used to encode one or more neighboring blocks of a block of video data, a subset of 33 angular intra prediction modes from among a plurality of intra prediction modes, wherein the plurality of intra prediction modes includes 65 angular intra prediction modes;</claim-text>
<claim-text>encode (700) syntax information that indicates a selected intra prediction mode for a current prediction unit, PU, of the block of video data from among the subset of 33 angular intra prediction modes; and</claim-text>
<claim-text>encode (702) the block of video data based on the selected intra prediction mode using 1/32 pel interpolation accuracy, wherein encoding the block of video data comprises:<br/>
for each respective sample of a predictive block of the current PU:
<claim-text>determining a fractional position between two neighboring reconstructed samples by projecting, along a prediction direction associated with the selected intra prediction mode, a coordinate of the respective sample to a row or column of neighboring reconstructed samples containing the two neighboring reconstructed samples, wherein the two neighboring reconstructed samples neighbor the current PU; and</claim-text>
<claim-text>calculating a prediction value of the respective sample using an interpolation filter that uses values of the two neighboring reconstructed samples to interpolate a value at the determined fractional position, the interpolation being in 1/32 pel accuracy.</claim-text></claim-text><!-- EPO <DP n="99"> --></claim-text></claim>
<claim id="c-en-01-0011" num="0011">
<claim-text>A computer readable medium that stores instructions that, when executed by one or more processors cause the one or more processors to perform the method of any of claims 1 to 8.</claim-text></claim>
</claims>
<claims id="claims02" lang="de"><!-- EPO <DP n="100"> -->
<claim id="c-de-01-0001" num="0001">
<claim-text>Verfahren zum Decodieren eines Blocks von Videodaten, wobei das Verfahren Folgendes beinhaltet:
<claim-text>Auswählen, auf der Basis von Intra-Prädiktionsmodi, die zum Decodieren eines oder mehrerer benachbarter Blöcke des Blocks von Videodaten benutzt werden, einer Teilmenge von 33 angularen Intra-Prädiktionsmodi aus mehreren Intra-Prädiktionsmodi, wobei die mehreren Intra-Prädiktionsmodi 65 angulare Intra-Prädiktionsmodi umfassen;</claim-text>
<claim-text>Decodieren (750) von Syntaxinformationen, die einen gewählten Intra-Prädiktionsmodus für eine aktuelle Prädiktionseinheit, PU, des Blocks von Videodaten aus der Teilmenge von 33 angularen Intra-Prädiktionsmodi anzeigen; und</claim-text>
<claim-text>Rekonstruieren (752) des Blocks von Videodaten auf der Basis des gewählten Intra-Prädiktionsmodus mit einer Interpolationsgenauigkeit von 1/32 pel, wobei das Rekonstruieren des Blocks von Videodaten Folgendes beinhaltet:<br/>
für jedes jeweilige Sample eines prädiktiven Blocks der aktuellen PU:
<claim-text>Bestimmen einer fraktionalen Position zwischen zwei benachbarten rekonstruierten Samples durch Projizieren, entlang einer mit dem gewählten Intra-Prädiktionsmodus assoziierten Prädiktionsrichtung, einer Koordinate des jeweiligen Sample auf eine Reihe oder Spalte von benachbarten rekonstruierten Samples, die die beiden benachbarten rekonstruierten Samples enthalten, wobei die beiden benachbarten rekonstruierten Samples der aktuellen PU benachbart sind; und</claim-text>
<claim-text>Berechnen eines Wertes des jeweiligen Sample mittels eines Interpolationsfilters, das Werte der<!-- EPO <DP n="101"> --> beiden benachbarten rekonstruierten Samples zum Interpolieren eines Wertes an der bestimmten fraktionalen Position benutzt, wobei die Interpolation mit einer Genauigkeit von 1/32 pel erfolgt.</claim-text></claim-text></claim-text></claim>
<claim id="c-de-01-0002" num="0002">
<claim-text>Verfahren nach Anspruch 1, das ferner das Bestimmen, auf der Basis einer Codiereinheitsgröße und/oder einer Prädiktionseinheitsgröße, einer Gesamtzahl von Intra-Prädiktionsmodi der mehreren Intra-Prädiktionsmodi beinhaltet.</claim-text></claim>
<claim id="c-de-01-0003" num="0003">
<claim-text>Verfahren nach Anspruch 1, wobei eine Gesamtzahl von Intra-Prädiktionsmodi aus den mehreren Intra-Prädiktionsmodi in mindestens einem aus einem Sequenzparametersatz, einem Bildparametersatz und einem Slice-Header signalisiert wird.</claim-text></claim>
<claim id="c-de-01-0004" num="0004">
<claim-text>Verfahren nach Anspruch 1, wobei das Interpolationsfilter formuliert wird als: <maths id="math0074" num=""><math display="block"><msub><mi mathvariant="normal">p</mi><mi>xy</mi></msub><mo>=</mo><mfenced separators=""><mn>1</mn><mo>−</mo><mi mathvariant="normal">α</mi></mfenced><mo>⋅</mo><mi mathvariant="normal">L</mi><mo>+</mo><mi mathvariant="normal">α</mi><mo>⋅</mo><mi mathvariant="normal">R</mi><mo>,</mo></math><img id="ib0076" file="imgb0076.tif" wi="47" he="6" img-content="math" img-format="tif"/></maths> wobei p<sub>xy</sub> der berechnete Wert des jeweiligen Sample ist, L und R Werte der beiden rekonstruierten benachbarten Samples sind und α die bestimmte fraktionale Position ist.</claim-text></claim>
<claim id="c-de-01-0005" num="0005">
<claim-text>Verfahren zum Encodieren eines Blocks von Videodaten, wobei das Verfahren Folgendes beinhaltet:
<claim-text>Auswählen, auf der Basis von Intra-Prädiktionsmodi, die zum Encodieren eines oder mehrerer benachbarter Blöcke des Blocks von Videodaten benutzt werden, einer Teilmenge von 33 angularen Intra-Prädiktionsmodi aus mehreren Intra-Prädiktionsmodi, wobei die mehreren Intra-Prädiktionsmodi<!-- EPO <DP n="102"> --> 65 angulare Intra-Prädiktionsmodi umfassen;</claim-text>
<claim-text>Encodieren (700) von Syntaxinformationen, die einen gewählten Intra-Prädiktionsmodus für eine aktuelle Prädiktionseinheit, PU, des Blocks von Videodaten aus der Teilmenge von 33 angularen Intra-Prädiktionsmodi anzeigen; und<br/>
Encodieren (702) des Blocks von Videodaten auf der Basis des gewählten Intra-Prädiktionsmodus mit einer Interpolationsgenauigkeit von 1/32 pel, wobei das Encodieren des Blocks von Videodaten Folgendes beinhaltet:<br/>
für jedes jeweilige Sample eines prädiktiven Blocks der aktuellen PU:
<claim-text>Bestimmen einer fraktionalen Position zwischen zwei benachbarten rekonstruierten Samples durch Projizieren, entlang einer mit dem gewählten Intra-Prädiktionsmodus assoziierten Prädiktionsrichtung, einer Koordinate des jeweiligen Sample auf eine Reihe oder Spalte benachbarter rekonstruierter Samples, die die beiden benachbarten rekonstruierten Samples enthalten, wobei die beiden benachbarten rekonstruierten Samples der aktuellen PU benachbart sind; und</claim-text>
<claim-text>Berechnen eines Prädiktionswertes des jeweiligen Sample mit einem Interpolationsfilter, das Werte der beiden benachbarten rekonstruierten Samples zum Interpolieren eines Wertes an der bestimmten fraktionalen Position benutzt, wobei die Interpolation mit einer Genauigkeit von 1/32 pel erfolgt.</claim-text></claim-text><!-- EPO <DP n="103"> --></claim-text></claim>
<claim id="c-de-01-0006" num="0006">
<claim-text>Verfahren nach Anspruch 5, das ferner das Bestimmen, auf der Basis einer Codiereinheitsgröße und/oder einer Prädiktionseinheitsgröße, einer Gesamtzahl von Intra-Prädiktionsmodi der mehreren Intra-Prädiktionsmodi beinhaltet.</claim-text></claim>
<claim id="c-de-01-0007" num="0007">
<claim-text>Verfahren nach Anspruch 5, wobei eine Gesamtzahl von Intra-Prädiktionsmodi der mehreren Intra-Prädiktionsmodi in mindestens einem aus einem Sequenzparametersatz, einem Bildparametersatz und einem Slice-Header signalisiert wird.</claim-text></claim>
<claim id="c-de-01-0008" num="0008">
<claim-text>Verfahren nach Anspruch 5, wobei das Interpolationsfilter formuliert wird als: <maths id="math0075" num=""><math display="block"><msub><mi mathvariant="normal">p</mi><mi>xy</mi></msub><mo>=</mo><mfenced separators=""><mn>1</mn><mo>−</mo><mi mathvariant="normal">α</mi></mfenced><mo>⋅</mo><mi mathvariant="normal">L</mi><mo>+</mo><mi mathvariant="normal">α</mi><mo>⋅</mo><mi mathvariant="normal">R</mi><mo>,</mo></math><img id="ib0077" file="imgb0077.tif" wi="47" he="6" img-content="math" img-format="tif"/></maths> wobei p<sub>xy</sub> der berechnete Wert des jeweiligen Sample ist, L und R Werte der beiden rekonstruierten benachbarten Samples sind und α die bestimmte fraktionale Position ist.</claim-text></claim>
<claim id="c-de-01-0009" num="0009">
<claim-text>Gerät zum Decodieren von Videodaten, wobei das Gerät Folgendes umfasst:<br/>
einen Speicher, der zum Speichern der Videodaten konfiguriert ist; und<br/>
einen oder mehrere Prozessoren, konfiguriert zum:
<claim-text>Auswählen, auf der Basis von Intra-Prädiktionsmodi, die zum Decodieren von einem oder mehreren benachbarten Blöcken eines Blocks von Videodaten in einem aktuellen Bild von Videodaten benutzt werden, einer Teilmenge von 33 angularen Intra-Prädiktionsmodi aus mehreren Intra-Prädiktionsmodi, wobei die mehreren Intra-Prädiktionsmodi 65 angulare Intra-Prädiktionsmodi umfassen;<!-- EPO <DP n="104"> --></claim-text>
<claim-text>Decodieren (750) von Syntaxinformationen, die einen gewählten Intra-Prädiktionsmodus für eine aktuelle Prädiktionseinheit, PU, des Blocks von Videodaten aus der Teilmenge von 33 angularen Intra-Prädiktionsmodi anzeigen; und</claim-text>
<claim-text>Rekonstruieren (752) des Blocks von Videodaten auf der Basis des gewählten Intra-Prädiktionsmodus, wobei die angularen Intra-Prädiktionsmodi so definiert sind, dass Interpolation mit einer Genauigkeit von 1/32 pel durchgeführt wird, wobei das Rekonstruieren des Blocks von Videodaten Folgendes beinhaltet:<br/>
für jedes jeweilige Sample eines prädiktiven Blocks der aktuellen PU:
<claim-text>Bestimmen einer fraktionalen Position zwischen zwei benachbarten rekonstruierten Samples durch Projizieren, entlang einer mit dem gewählten Intra-Prädiktionsmodus assoziierten Prädiktionsrichtung, einer Koordinate des jeweiligen Sample auf eine Reihe oder Spalte von benachbarten rekonstruierten Samples, die die beiden benachbarten rekonstruierten Samples enthalten, wobei die beiden benachbarten rekonstruierten Samples der aktuellen PU benachbart sind; und</claim-text>
<claim-text>Berechnen eines Wertes des jeweiligen Sample mittels eines Interpolationsfilters, das Werte der beiden benachbarten rekonstruierten Samples zum Interpolieren eines Wertes an der bestimmten fraktionalen Position benutzt, wobei die Interpolation mit einer Genauigkeit von 1/32 pel erfolgt.</claim-text></claim-text><!-- EPO <DP n="105"> --></claim-text></claim>
<claim id="c-de-01-0010" num="0010">
<claim-text>Gerät zum Encodieren von Videodaten, wobei das Gerät Folgendes umfasst:<br/>
einen Speicher, der zum Speichern der Videodaten konfiguriert ist; und<br/>
einen oder mehrere Prozessoren, konfiguriert zum:
<claim-text>Auswählen, auf der Basis von Intra-Prädiktionsmodi, die zum Encodieren von einem oder mehreren benachbarten Blöcken eines Blocks von Videodaten verwendet werden, einer Teilmenge von 33 angularen Intra-Prädiktionsmodi aus mehreren Intra-Prädiktionsmodi, wobei die mehreren Intra-Prädiktionsmodi 65 angulare Intra-Pädiktionsmodi umfassen;</claim-text>
<claim-text>Encodieren (700) von Syntaxinformationen, die einen gewählten Intra-Prädiktionsmodus für eine aktuelle Prädiktionseinheit, PU, des Blocks von Videodaten aus der Teilmenge von 33 angularen Intra-Prädiktionsmodi anzeigen; und</claim-text>
<claim-text>Encodieren (702) des Blocks von Videodaten auf der Basis des gewählten Intra-Prädiktionsmodus mit einer Interpolationsgenauigkeit von 1/32 pel, wobei das Encodieren des Blocks von Videodaten Folgendes beinhaltet:<br/>
für jedes jeweilige Sample eines prädiktiven Blocks der aktuellen PU:
<claim-text>Bestimmen einer fraktionalen Position zwischen zwei benachbarten rekonstruierten Samples durch Projizieren, entlang einer mit dem gewählten Intra-Prädiktionsmodus assoziierten Prädiktionsrichtung, einer Koordinate des jeweiligen Sample auf eine Reihe oder Spalte von benachbarten<!-- EPO <DP n="106"> --> rekonstruierten Samples, die die beiden benachbarten rekonstruierten Samples enthalten, wobei die beiden benachbarten rekonstruierten Samples der aktuellen PU benachbart sind; und</claim-text>
<claim-text>Berechnen eines Prädiktionswertes des jeweiligen Sample mittels eines Interpolationsfilters, das Werte der beiden benachbarten rekonstruierten Samples zum Interpolieren eines Wertes an der bestimmten fraktionalen Position verwendet, wobei die Interpolation mit einer Genauigkeit von 1/32 pel erfolgt.</claim-text></claim-text></claim-text></claim>
<claim id="c-de-01-0011" num="0011">
<claim-text>Computerlesbares Medium, das Befehle speichert, die bei Ausführung durch einen oder mehrere Prozessoren bewirken, dass die ein oder mehreren Prozessoren das Verfahren nach einem der Ansprüche 1 bis 8 durchführen.</claim-text></claim>
</claims>
<claims id="claims03" lang="fr"><!-- EPO <DP n="107"> -->
<claim id="c-fr-01-0001" num="0001">
<claim-text>Procédé de décodage d'un bloc de données vidéo, le procédé comprenant :
<claim-text>la sélection, en fonction de modes d'intra-prédiction utilisés pour décoder un ou plusieurs blocs voisins du bloc de données vidéo, d'un sous-ensemble de 33 modes d'intra-prédiction angulaire parmi une pluralité de modes d'intra-prédiction, la pluralité de modes d'intra-prédiction comprenant 65 modes d'intra-prédiction angulaire ;</claim-text>
<claim-text>le décodage (750) d'informations de syntaxe qui indiquent un mode d'intra-prédiction sélectionné pour une unité de prédiction, PU, actuelle, du bloc de données vidéo parmi le sous-ensemble de 33 modes d'intra-prédiction angulaire ; et</claim-text>
<claim-text>la reconstruction (752) du bloc de données vidéo en fonction du mode d'intra-prédiction sélectionné en utilisant une précision d'interpolation de 1/32 pixel, la reconstruction du bloc de données vidéo comprenant :<br/>
pour chaque échantillon respectif d'un bloc prédictif de la PU actuelle :
<claim-text>la détermination d'une position fractionnaire entre deux échantillons reconstruits voisins en projetant, le long d'une direction de prédiction associée au mode d'intra-prédiction sélectionné, une coordonnée de l'échantillon respectif vers une rangée ou une colonne d'échantillons reconstruits voisins contenant les deux échantillons reconstruits voisins, les deux échantillons reconstruits voisins étant voisins de la PU actuelle ; et</claim-text>
<claim-text>le calcul d'une valeur de l'échantillon respectif à l'aide d'un filtre d'interpolation qui utilise des valeurs des deux échantillons reconstruits voisins pour interpoler une valeur à la position fractionnaire déterminée, l'interpolation étant d'une précision de 1/32 pixel.</claim-text></claim-text></claim-text></claim>
<claim id="c-fr-01-0002" num="0002">
<claim-text>Procédé selon la revendication 1, comprenant en outre la détermination, sur la base d'au moins une taille d'unité de codage ou d'une taille d'unité de prédiction, d'un nombre total de modes d'intra-prédiction dans la pluralité des modes d'intra-prédiction.</claim-text></claim>
<claim id="c-fr-01-0003" num="0003">
<claim-text>Procédé selon la revendication 1, dans lequel un nombre total de modes d'intra-prédiction dans la pluralité des modes d'intra-prédiction est signalé dans au moins un : d'un ensemble de paramètres de séquence, d'un ensemble de paramètres d'image ou d'un en-tête de tranche.</claim-text></claim>
<claim id="c-fr-01-0004" num="0004">
<claim-text>Procédé selon revendication 1, dans lequel le filtre d'interpolation est formulé comme suit <maths id="math0076" num=""><math display="block"><msub><mi mathvariant="normal">p</mi><mi>xy</mi></msub><mo>=</mo><mfenced separators=""><mn>1</mn><mo>−</mo><mi mathvariant="normal">α</mi></mfenced><mi>.L</mi><mo>+</mo><mi>α+</mi><mi mathvariant="normal">R</mi><mo>,</mo></math><img id="ib0078" file="imgb0078.tif" wi="39" he="5" img-content="math" img-format="tif"/></maths> où p<sub>xy</sub> est la valeur calculée de l'échantillon respectif, L et R sont des valeurs des deux échantillons reconstruits voisins, et α est la position fractionnaire déterminée.</claim-text></claim>
<claim id="c-fr-01-0005" num="0005">
<claim-text>Procédé d'encodage d'un bloc de données vidéo, le procédé comprenant :<!-- EPO <DP n="108"> -->
<claim-text>la sélection, en fonction de modes d'intra-prédiction utilisés pour décoder un ou plusieurs blocs voisins du bloc de données vidéo, d'un sous-ensemble de 33 modes d'intra-prédiction angulaire parmi une pluralité de modes d'intra-prédiction, la pluralité de modes d'intra-prédiction comprenant 65 modes d'intra-prédiction angulaire ;</claim-text>
<claim-text>l'encodage (700) d'informations de syntaxe qui indiquent un mode d'intra-prédiction sélectionné pour une unité de prédiction, PU, actuelle du bloc de données vidéo parmi le sous-ensemble de 33 modes d'intra-prédiction angulaire ; et</claim-text>
<claim-text>l'encodage (702) du bloc de données vidéo en fonction du mode d'intra-prédiction sélectionné en utilisant une précision d'interpolation de 1/32 pixel, l'encodage du bloc de données vidéo comprenant :<br/>
pour chaque échantillon respectif d'un bloc prédictif de la PU actuelle :
<claim-text>la détermination d'une position fractionnaire entre deux échantillons reconstruits voisins en projetant, le long d'une direction de prédiction associée au mode d'intra-prédiction sélectionné, une coordonnée de l'échantillon respectif vers une rangée ou une colonne d'échantillons reconstruits voisins contenant les deux échantillons reconstruits voisins, les deux échantillons reconstruits voisins étant voisins de la PU actuelle ; et</claim-text>
<claim-text>le calcul d'une valeur de prédiction de l'échantillon respectif à l'aide d'un filtre d'interpolation qui utilise des valeurs des deux échantillons reconstruits voisins pour interpoler une valeur à la position fractionnaire déterminée, l'interpolation étant d'une précision de 1/32 pixel.</claim-text></claim-text></claim-text></claim>
<claim id="c-fr-01-0006" num="0006">
<claim-text>Procédé selon la revendication 5, comprenant en outre la détermination, sur la base d'au moins une taille d'unité de codage ou d'une taille d'unité de prédiction, d'un nombre total de modes d'intra-prédiction dans la pluralité de modes d'intra-prédiction.</claim-text></claim>
<claim id="c-fr-01-0007" num="0007">
<claim-text>Procédé selon la revendication 5, dans lequel un nombre total de modes d'intra-prédiction dans la pluralité de modes d'intra-prédiction est signalé dans au moins un : d'un ensemble de paramètres de séquence, d'un ensemble de paramètres d'image, ou d'un en-tête de tranche.</claim-text></claim>
<claim id="c-fr-01-0008" num="0008">
<claim-text>Procédé selon la revendication 5, dans lequel le filtre d'interpolation est formulé comme suit : <maths id="math0077" num=""><math display="block"><msub><mi mathvariant="normal">p</mi><mi>xy</mi></msub><mo>=</mo><mfenced separators=""><mn>1</mn><mo>−</mo><mi mathvariant="normal">α</mi></mfenced><mi>.L</mi><mo>+</mo><mi>α+</mi><mi mathvariant="normal">R</mi><mo>,</mo></math><img id="ib0079" file="imgb0079.tif" wi="39" he="5" img-content="math" img-format="tif"/></maths> où p<sub>xy</sub> est la valeur calculée de l'échantillon respectif, L et R sont des valeurs des deux échantillons reconstruits voisins, et α est la position fractionnaire déterminée.</claim-text></claim>
<claim id="c-fr-01-0009" num="0009">
<claim-text>Dispositif de décodage de données vidéo, le dispositif comprenant :
<claim-text>une mémoire configurée pour mémoriser les données vidéo ; et</claim-text>
<claim-text>un ou plusieurs processeurs configurés pour :<!-- EPO <DP n="109"> -->
<claim-text>sélectionner, en fonction de modes d'intra-prédiction utilisés pour décoder un ou plusieurs blocs voisins du bloc de données vidéo, un sous-ensemble de 33 modes d'intra-prédiction angulaire parmi une pluralité de modes d'intra-prédiction, la pluralité de modes d'intra-prédiction comprenant 65 modes d'intra-prédiction angulaire ;</claim-text>
<claim-text>décoder (750) des informations de syntaxe qui indiquent un mode d'intra-prédiction sélectionné pour une unité de prédiction, PU, actuelle, du bloc de données vidéo parmi le sous-ensemble de 33 modes d'intra-prédiction angulaire ; et</claim-text>
<claim-text>reconstruire (752) le bloc de données vidéo en fonction du mode d'intra-prédiction sélectionné en utilisant une précision d'interpolation de 1/32 pixel, la reconstruction du bloc de données vidéo comprenant :<br/>
pour chaque échantillon respectif d'un bloc prédictif de la PU actuelle :
<claim-text>la détermination d'une position fractionnaire entre deux échantillons reconstruits voisins en projetant, le long d'une direction de prédiction associée au mode d'intra-prédiction sélectionné, une coordonnée de l'échantillon respectif vers une rangée ou une colonne d'échantillons reconstruits voisins contenant les deux échantillons reconstruits voisins, les deux échantillons reconstruits voisins étant voisins de la PU actuelle ; et</claim-text>
<claim-text>le calcul d'une valeur de l'échantillon respectif à l'aide d'un filtre d'interpolation qui utilise des valeurs des deux échantillons reconstruits voisins pour interpoler une valeur à la position fractionnaire déterminée, l'interpolation étant d'une précision de 1/32 pixel.</claim-text></claim-text></claim-text></claim-text></claim>
<claim id="c-fr-01-0010" num="0010">
<claim-text>Dispositif d'encodage de données vidéo, le dispositif comprenant :
<claim-text>une mémoire configurée pour mémoriser les données vidéo ; et</claim-text>
<claim-text>un ou plusieurs processeurs configurés pour :
<claim-text>sélectionner, en fonction de modes d'intra-prédiction utilisés pour décoder un ou plusieurs blocs voisins du bloc de données vidéo, un sous-ensemble de 33 modes d'intra-prédiction angulaire parmi une pluralité de modes d'intra-prédiction, la pluralité de modes d'intra-prédiction comprenant 65 modes d'intra-prédiction angulaire ;</claim-text>
<claim-text>encoder (700) des informations de syntaxe qui indiquent un mode d'intra-prédiction sélectionné pour une unité de prédiction, PU, actuelle du bloc de données vidéo parmi le sous-ensemble de 33 modes d'intra-prédiction angulaire ; et</claim-text>
<claim-text>encoder (702) le bloc de données vidéo en fonction du mode d'intra-prédiction sélectionné en utilisant une précision d'interpolation de 1/32 pixel, l'encodage du bloc de données vidéo comprenant :<br/>
pour chaque échantillon respectif d'un bloc prédictif de la PU actuelle :
<claim-text>la détermination d'une position fractionnaire entre deux échantillons reconstruits voisins en projetant, le long d'une direction de prédiction associée au mode d'intra-prédiction sélectionné, une coordonnée de l'échantillon respectif vers une rangée ou une colonne<!-- EPO <DP n="110"> --> d'échantillons reconstruits voisins contenant les deux échantillons reconstruits voisins, les deux échantillons reconstruits voisins étant voisins de la PU actuelle ; et</claim-text>
<claim-text>le calcul d'une valeur de prédiction de l'échantillon respectif à l'aide d'un filtre d'interpolation qui utilise des valeurs des deux échantillons reconstruits voisins pour interpoler une valeur à la position fractionnaire déterminée, l'interpolation étant d'une précision de 1/32 pixel.</claim-text></claim-text></claim-text></claim-text></claim>
<claim id="c-fr-01-0011" num="0011">
<claim-text>Support lisible par ordinateur mémorisant des instructions qui, à leur exécution par un ou plusieurs processeurs, amènent les un ou plusieurs processeurs à réaliser le procédé selon l'une des revendications 1 à 8.</claim-text></claim>
</claims>
<drawings id="draw" lang="en"><!-- EPO <DP n="111"> -->
<figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="164" he="216" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="112"> -->
<figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="147" he="224" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="113"> -->
<figure id="f0003" num="3"><img id="if0003" file="imgf0003.tif" wi="152" he="210" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="114"> -->
<figure id="f0004" num="4"><img id="if0004" file="imgf0004.tif" wi="142" he="226" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="115"> -->
<figure id="f0005" num="5"><img id="if0005" file="imgf0005.tif" wi="111" he="201" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="116"> -->
<figure id="f0006" num="6"><img id="if0006" file="imgf0006.tif" wi="155" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="117"> -->
<figure id="f0007" num="7"><img id="if0007" file="imgf0007.tif" wi="138" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="118"> -->
<figure id="f0008" num="8"><img id="if0008" file="imgf0008.tif" wi="148" he="220" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="119"> -->
<figure id="f0009" num="9"><img id="if0009" file="imgf0009.tif" wi="135" he="217" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="120"> -->
<figure id="f0010" num="10"><img id="if0010" file="imgf0010.tif" wi="120" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="121"> -->
<figure id="f0011" num="11"><img id="if0011" file="imgf0011.tif" wi="115" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="122"> -->
<figure id="f0012" num="12"><img id="if0012" file="imgf0012.tif" wi="107" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="123"> -->
<figure id="f0013" num="13"><img id="if0013" file="imgf0013.tif" wi="101" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="124"> -->
<figure id="f0014" num="14"><img id="if0014" file="imgf0014.tif" wi="115" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="125"> -->
<figure id="f0015" num="15"><img id="if0015" file="imgf0015.tif" wi="122" he="228" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="126"> -->
<figure id="f0016" num="16"><img id="if0016" file="imgf0016.tif" wi="120" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="127"> -->
<figure id="f0017" num="17"><img id="if0017" file="imgf0017.tif" wi="122" he="202" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="128"> -->
<figure id="f0018" num="18,19"><img id="if0018" file="imgf0018.tif" wi="134" he="225" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="129"> -->
<figure id="f0019" num="20"><img id="if0019" file="imgf0019.tif" wi="122" he="187" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="130"> -->
<figure id="f0020" num="21"><img id="if0020" file="imgf0020.tif" wi="115" he="212" img-content="drawing" img-format="tif"/></figure>
</drawings>
<ep-reference-list id="ref-list">
<heading id="ref-h0001"><b>REFERENCES CITED IN THE DESCRIPTION</b></heading>
<p id="ref-p0001" num=""><i>This list of references cited by the applicant is for the reader's convenience only. It does not form part of the European patent document. Even though great care has been taken in compiling the references, errors or omissions cannot be excluded and the EPO disclaims all liability in this regard.</i></p>
<heading id="ref-h0002"><b>Patent documents cited in the description</b></heading>
<p id="ref-p0002" num="">
<ul id="ref-ul0001" list-style="bullet">
<li><patcit id="ref-pcit0001" dnum="US31294611" dnum-type="L"><document-id><country>US</country><doc-number>31294611</doc-number><name>Maani, Ehsan</name><date>20111206</date></document-id></patcit><crossref idref="pcit0001">[0076]</crossref></li>
</ul></p>
<heading id="ref-h0003"><b>Non-patent literature cited in the description</b></heading>
<p id="ref-p0003" num="">
<ul id="ref-ul0002" list-style="bullet">
<li><nplcit id="ref-ncit0001" npl-type="b"><article><atl/><book><author><name>VIVIENNE SZE</name></author><book-title>High Efficiency Video Coding (HEVC), Algorithms and Architectures</book-title></book></article></nplcit><crossref idref="ncit0001">[0005]</crossref></li>
<li><nplcit id="ref-ncit0002" npl-type="s"><article><author><name>ZHAO et al.</name></author><atl>Fast Mode Decision Algorithm for Intra Prediction in HEVC</atl><serial><sertitle>Proceedings the IEEE Conference on Visual Communication and Image Processing (VCIP)</sertitle><pubdate><sdate>20110000</sdate><edate/></pubdate></serial></article></nplcit><crossref idref="ncit0002">[0005]</crossref></li>
<li><nplcit id="ref-ncit0003" npl-type="b"><article><atl>Improved intra angular prediction by DCT-based interpolation filter</atl><book><author><name>MATSUO et al.</name></author><book-title>Signal Processing Conference (EUSIPCO), 2012 Proceedings of the 20th European</book-title><imprint><name>IEEE</name><pubdate>20120000</pubdate></imprint><location><pp><ppf>1568</ppf><ppl>1572</ppl></pp></location></book></article></nplcit><crossref idref="ncit0003">[0076]</crossref></li>
<li><nplcit id="ref-ncit0004" npl-type="s"><article><author><name>M. GUO</name></author><author><name>X. GUO</name></author><author><name>S. LEI</name></author><atl>Improved Intra Mode Coding</atl><serial><sertitle>Joint Collaborative Team on Video Coding (JCT-VC) of ITU-T SG16 WP3 and ISO/IEC JTC1/SC29/WG11, 4th Meeting: Daegu, Korea</sertitle><pubdate><sdate>20110120</sdate><edate/></pubdate></serial></article></nplcit><crossref idref="ncit0004">[0076]</crossref></li>
</ul></p>
</ep-reference-list>
</ep-patent-document>
