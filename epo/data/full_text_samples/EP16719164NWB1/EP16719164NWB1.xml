<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE ep-patent-document PUBLIC "-//EPO//EP PATENT DOCUMENT 1.5.1//EN" "ep-patent-document-v1-5-1.dtd">
<!-- This XML data has been generated under the supervision of the European Patent Office -->
<ep-patent-document id="EP16719164B1" file="EP16719164NWB1.xml" lang="en" country="EP" doc-number="3286725" kind="B1" date-publ="20211006" status="n" dtd-version="ep-patent-document-v1-5-1">
<SDOBI lang="en"><B000><eptags><B001EP>ATBECHDEDKESFRGBGRITLILUNLSEMCPTIESILTLVFIROMKCYALTRBGCZEEHUPLSK..HRIS..MTNORS..SM..................</B001EP><B003EP>*</B003EP><B005EP>J</B005EP><B007EP>BDM Ver 2.0.12 (4th of August) -  2100000/0</B007EP></eptags></B000><B100><B110>3286725</B110><B120><B121>EUROPEAN PATENT SPECIFICATION</B121></B120><B130>B1</B130><B140><date>20211006</date></B140><B190>EP</B190></B100><B200><B210>16719164.2</B210><B220><date>20160404</date></B220><B240><B241><date>20170927</date></B241><B242><date>20191106</date></B242></B240><B250>en</B250><B251EP>en</B251EP><B260>en</B260></B200><B300><B310>201514694806</B310><B320><date>20150423</date></B320><B330><ctry>US</ctry></B330></B300><B400><B405><date>20211006</date><bnum>202140</bnum></B405><B430><date>20180228</date><bnum>201809</bnum></B430><B450><date>20211006</date><bnum>202140</bnum></B450><B452EP><date>20210706</date></B452EP></B400><B500><B510EP><classification-ipcr sequence="1"><text>G06T   1/60        20060101AFI20161102BHEP        </text></classification-ipcr></B510EP><B520EP><classifications-cpc><classification-cpc sequence="1"><text>H04N   1/32101     20130101 FI20161027BHEP        </text></classification-cpc><classification-cpc sequence="2"><text>G06T   1/60        20130101 LI20160613BHEP        </text></classification-cpc></classifications-cpc></B520EP><B540><B541>de</B541><B542>SHEETGENERATOR FÜR EINEN BILDPROZESSOR</B542><B541>en</B541><B542>SHEET GENERATOR FOR IMAGE PROCESSOR</B542><B541>fr</B541><B542>GÉNÉRATEUR DE "SHEET" POUR UN PROCESSEUR D'IMAGE</B542></B540><B560><B561><text>US-A1- 2014 164 737</text></B561><B561><text>US-A1- 2015 086 134</text></B561><B562><text>P H J Van Oosterhout: "OPTIMIZED PIXEL TEMPLATE IMAGE CORRELATOR", Master Thesis, 19 August 1992 (1992-08-19), pages 1-72, XP55279159, Retrieved from the Internet: URL:http://alexandria.tue.nl/extra2/afstve rsl/E/563812.pdf [retrieved on 2016-06-09]</text></B562><B562><text>S.G. DYKES ET AL: "Communication and computation patterns of large scale image convolutions on parallel architectures", PARALLEL PROCESSING SYMPOSIUM, 1994. PROCEEDINGS., EIGHTH INTERNATIONA L CANCUN, MEXICO 26-29 APRIL 1994, 1 January 1994 (1994-01-01), pages 926-931, XP055279443, DOI: 10.1109/IPPS.1994.288195 ISBN: 978-0-8186-5602-6</text></B562></B560></B500><B700><B720><B721><snm>MEIXNER, Albert</snm><adr><str>1600 Amphitheatre Parkway</str><city>Mountain View, CA 94043</city><ctry>US</ctry></adr></B721><B721><snm>REDGRAVE, Jason Rupert</snm><adr><str>1600 Amphitheatre Parkway</str><city>Mountain View, CA 94043</city><ctry>US</ctry></adr></B721><B721><snm>SHACHAM, Ofer</snm><adr><str>1600 Amphitheatre Parkway</str><city>Mountain View, CA 94043</city><ctry>US</ctry></adr></B721><B721><snm>ZHU, Qiuling</snm><adr><str>1600 Amphitheatre Parkway</str><city>Mountain View, CA 94043</city><ctry>US</ctry></adr></B721><B721><snm>FINCHELSTEIN, Daniel Frederic</snm><adr><str>1600 Amphitheatre Parkway</str><city>Mountain View, CA 94043</city><ctry>US</ctry></adr></B721></B720><B730><B731><snm>Google LLC</snm><iid>101696670</iid><irf>PM357704EP</irf><adr><str>1600 Amphitheatre Parkway</str><city>Mountain View, CA 94043</city><ctry>US</ctry></adr></B731></B730><B740><B741><snm>Suckling, Andrew Michael</snm><sfx>et al</sfx><iid>100037251</iid><adr><str>Marks &amp; Clerk LLP 
Fletcher House 
The Oxford Science Park 
Heatley Road</str><city>Oxford OX4 4GE</city><ctry>GB</ctry></adr></B741></B740></B700><B800><B840><ctry>AL</ctry><ctry>AT</ctry><ctry>BE</ctry><ctry>BG</ctry><ctry>CH</ctry><ctry>CY</ctry><ctry>CZ</ctry><ctry>DE</ctry><ctry>DK</ctry><ctry>EE</ctry><ctry>ES</ctry><ctry>FI</ctry><ctry>FR</ctry><ctry>GB</ctry><ctry>GR</ctry><ctry>HR</ctry><ctry>HU</ctry><ctry>IE</ctry><ctry>IS</ctry><ctry>IT</ctry><ctry>LI</ctry><ctry>LT</ctry><ctry>LU</ctry><ctry>LV</ctry><ctry>MC</ctry><ctry>MK</ctry><ctry>MT</ctry><ctry>NL</ctry><ctry>NO</ctry><ctry>PL</ctry><ctry>PT</ctry><ctry>RO</ctry><ctry>RS</ctry><ctry>SE</ctry><ctry>SI</ctry><ctry>SK</ctry><ctry>SM</ctry><ctry>TR</ctry></B840><B860><B861><dnum><anum>US2016025895</anum></dnum><date>20160404</date></B861><B862>en</B862></B860><B870><B871><dnum><pnum>WO2016171882</pnum></dnum><date>20161027</date><bnum>201643</bnum></B871></B870></B800></SDOBI>
<description id="desc" lang="en"><!-- EPO <DP n="1"> -->
<heading id="h0001"><b><u>Field of Invention</u></b></heading>
<p id="p0001" num="0001">The field of invention pertains generally to image processing, and, more specifically, to a sheet generator for an image processor.</p>
<heading id="h0002"><b><u>Background</u></b></heading>
<p id="p0002" num="0002">Image processing typically involves the processing of pixel values that are organized into an array. Here, a spatially organized two dimensional array captures the two dimensional nature of images (additional dimensions may include time (e.g., a sequence of two dimensional images) and data type (e.g., colors). In a typical scenario, the arrayed pixel values are provided by a camera that has generated a still image or a sequence of frames to capture images of motion. Traditional image processors typically fall on either side of two extremes.</p>
<p id="p0003" num="0003">A first extreme performs image processing tasks as software programs executing on a general purpose processor or general purpose-like processor (e.g., a general purpose processor with vector instruction enhancements). Although the first extreme typically provides a highly versatile application software development platform, its use of finer grained data structures combined with the associated overhead (e.g., instruction fetch and decode, handling of on-chip and off-chip data, speculative execution) ultimately results in larger amounts of energy being consumed per unit of data during execution of the program code.</p>
<p id="p0004" num="0004">A second, opposite extreme applies fixed function hardwired circuitry to much larger blocks of data. The use of larger (as opposed to finer grained) blocks of data applied directly to custom designed circuits greatly reduces power consumption per unit of data. However, the use of custom designed fixed function circuitry generally results in a limited set of tasks that the processor is able to perform. As such, the widely versatile programming environment (that is associated with the first extreme) is lacking in the second extreme.</p>
<p id="p0005" num="0005">The master thesis titled "Optimized Pixel Template Image Correlator" by P.H.J Van Oosterhout describes a custom chip named "Optimized Pixel Template Image Correlator (OPTIC)" that implements different kinds of picture processing techniques which are based on graylevel images and which can perform techniques at the speed of 20 megapixels per second. The OPTIC architecture comprises a configurable shift register array containing 64 8 bit registers. These registers are joined together in eight blocks of eight registers and form a shift array. Multiplexers at the beginning of each row allow data from a previous row or data from a data input to be routed to the shift array. This allows a pixel processing window to be configured<!-- EPO <DP n="2"> --> in four different shapes, 1x64, 2x32, 4x16 or 8x8. While processing an image, the window moves along the image and the pixels inside the window are processed. To this end, image lines comprising the pixels inside the window are stored in a line buffer.</p>
<p id="p0006" num="0006">The paper titled "Communication and Computation Patterns of Large Scale Image Convolutions on Parallel Architectures" presents an analysis of a texture segmentation application containing a 96x96 convolution implemented on distributed memory multicomputers, wherein the parallel algorithms are tailored to each machine's architecture.</p>
<p id="p0007" num="0007"><patcit id="pcit0001" dnum="US2015086134A"><text>US 2015/086134</text></patcit> proposes a convolution image processor includes a load and store unit, a shift register unit, and a mapping unit. The load and store unit is configured to load and store image pixel data and allow for unaligned access of the image pixel data. The shift register is configured to load and store at least a portion of the image pixel data from the load and store unit and concurrently provide access to each image pixel value in the portion of the image pixel data. The mapping unit is configured to generate a number of shifted versions of image pixel data and corresponding stencil data from the portion of the image pixel data, and concurrently perform one or more operations on each image pixel value in the shifted versions of the portion of the image pixel data and a corresponding stencil value in the corresponding stencil data.</p>
<p id="p0008" num="0008"><patcit id="pcit0002" dnum="US2014164737A"><text>US 2014/164737</text></patcit> proposes a method for executing instructions on a single-program, multiple-data processor system having a fixed number of execution lanes, including: scheduling a primary instruction for execution with a first wave of multiple data; assigning the first wave to a corresponding primary subset of the execution lanes; scheduling a secondary instruction having a second wave of multiple data, such that the second wave fits in lanes that are unused by the primary subset of lanes; assigning the second wave to a corresponding secondary subset of the lanes; fetching the primary and secondary instructions; configuring the execution lanes such that the primary subset is responsive to the primary instruction and the secondary subset is simultaneously responsive to the secondary instruction; and simultaneously executing the primary and secondary instructions in the execution lanes.</p>
<p id="p0009" num="0009">A technology platform that provides for both highly versatile application software development opportunities combined with improved power efficiency per unit of data remains a desirable yet missing solution.<!-- EPO <DP n="3"> --></p>
<heading id="h0003"><b><u>Summary</u></b></heading>
<p id="p0010" num="0010">The present invention provides a method according to claim 1; a machine readable storage medium according to claim 10, the machine readable storage medium containing program code that when processed by a processor and/or controller causes such a method to be performed; and an apparatus according to claim 11. According to a further aspect of the present disclosure, a sheet generator circuit is described. The sheet generator includes electronic circuitry to receive a line group of image data including multiple rows of data from a frame of image data. The multiple rows are sufficient in number to encompass multiple neighboring overlapping stencils. The electronic circuitry is to parse the line group into a smaller sized sheet. The electronic circuitry is to load the sheet into a data computation unit having a two dimensional shift array structure coupled to an array of processors.</p>
<p id="p0011" num="0011">According to yet another aspect of the present disclosure, an apparatus is described having means for receiving a line group of image data including multiple rows of data from a frame of image data. The multiple rows are sufficient in number to encompass multiple neighboring overlapping stencils. The apparatus also includes means for parsing the line group into a smaller sized sheet. The apparatus also includes means for loading the sheet into a two dimensional shift array structure coupled to an array of processors. The apparatus also includes means for executing program code on the array of processors to process the multiple neighboring overlapping stencils over said sheet.</p>
<heading id="h0004"><b><u>List of Figures</u></b></heading>
<p id="p0012" num="0012">The following description and accompanying drawings are used to illustrate embodiments of the invention. In the drawings:<!-- EPO <DP n="4"> -->
<ul id="ul0001" list-style="none" compact="compact">
<li><figref idref="f0001">Fig. 1</figref> shows an embodiment of an image processor hardware architecture;</li>
<li><figref idref="f0002">Figs. 2a</figref>, <figref idref="f0003">2b</figref>, <figref idref="f0004">2c</figref>, <figref idref="f0005">2d</figref> and <figref idref="f0006">2e</figref> depict the parsing of image data into a line group, the parsing of a line group into a sheet and the operation performed on a sheet with overlapping stencils;</li>
<li><figref idref="f0007">Fig. 3a</figref> shows an embodiment of a stencil processor;</li>
<li><figref idref="f0008">Fig. 3b</figref> shows an embodiment of a instruction word of the stencil processor;</li>
<li><figref idref="f0009">Fig. 4</figref> shows an embodiment of a data computation unit within a stencil processor;</li>
<li><figref idref="f0010">Figs. 5a</figref>, <figref idref="f0011">5b</figref>, <figref idref="f0012">5c</figref>, <figref idref="f0013">5d</figref>, <figref idref="f0014">5e</figref>, <figref idref="f0015">5f</figref>, <figref idref="f0016">5g</figref>, <figref idref="f0017">5h</figref>, <figref idref="f0018">5i</figref>, <figref idref="f0019">5j</figref> and <figref idref="f0020">5k</figref> depict an example of the use of a two-dimensional shift array and an execution lane array to determine a pair of neighboring output pixel values with overlapping stencils;</li>
<li><figref idref="f0021">Fig. 6</figref> shows an embodiment of a unit cell for an integrated execution lane array and two-dimensional shift array;</li>
<li><figref idref="f0022">Fig. 7</figref> pertains to a first operation performed by a sheet generator;</li>
<li><figref idref="f0023">Fig. 8</figref> pertains to a second operation performed by a sheet generator;</li>
<li><figref idref="f0024">Fig. 9</figref> pertains to a third operation performed by a sheet generator;</li>
<li><figref idref="f0025">Fig. 10</figref> pertains to a fourth operation performed by a sheet generator;</li>
<li><figref idref="f0026">Fig. 11</figref> pertains to a fifth operation performed by a sheet generator;</li>
<li><figref idref="f0027">Fig. 12</figref> pertains to a sixth operation performed by a sheet generator;</li>
<li><figref idref="f0028">Fig. 13</figref> shows an embodiment of a sheet generator;</li>
<li><figref idref="f0029">Fig. 14</figref> shows an embodiment of a computing system.</li>
</ul></p>
<heading id="h0005"><b><u>Detailed Description</u></b></heading>
<heading id="h0006"><b><i><u>a. image processor hardware architecture and operation</u></i></b></heading>
<p id="p0013" num="0013"><figref idref="f0001">Fig. 1</figref> shows an embodiment of an architecture 100 for an image processor implemented in hardware. The image processor may be targeted, for example, by a compiler that converts program code written for a virtual processor within a simulated environment into program code that is actually executed by the hardware processor. As observed in <figref idref="f0001">Fig. 1</figref>, the architecture 100 includes a plurality of line buffer units 101_1 through 101_M interconnected to a plurality of stencil processor units 102_1 through 102 N and corresponding sheet generator units 103_1 through 103 N through a network 104 (e.g., a network on chip (NOC) including an on chip switch network, an on chip ring network or other kind of network). In an embodiment, any line buffer unit may connect to any sheet generator and corresponding stencil processor through the network 104.<!-- EPO <DP n="5"> --></p>
<p id="p0014" num="0014">In an embodiment, program code is compiled and loaded onto a_corresponding stencil processor 102 to perform the image processing operations earlier defined by a software developer (program code may also be loaded onto the stencil processor's associated sheet generator 103, e.g., depending on design and implementation). In at least some instances an image processing pipeline may be realized by loading a first kernel program for a first pipeline stage into a first stencil processor 102_1, loading a second kernel program for a second pipeline stage into a second stencil processor 102_2, etc. where the first kernel performs the functions of the first stage of the pipeline, the second kernel performs the functions of the second stage of the pipeline, etc. and additional control flow methods are installed to pass output image data from one stage of the pipeline to the next stage of the pipeline.</p>
<p id="p0015" num="0015">In other configurations, the image processor may be realized as a parallel machine having two or more stencil processors 102_1, 102_2 operating the same kernel program code. For example, a highly dense and high data rate stream of image data may be processed by spreading frames across multiple stencil processors each of which perform the same function.</p>
<p id="p0016" num="0016">In yet other configurations, essentially any DAG of kernels may be loaded onto the hardware processor by configuring respective stencil processors with their own respective kernel of program code and configuring appropriate control flow hooks into the hardware to direct output images from one kernel to the input of a next kernel in the DAG design.</p>
<p id="p0017" num="0017">As a general flow, frames of image data are received by a macro I/O unit 105 and passed to one or more of the line buffer units 101 on a frame by frame basis. A particular line buffer unit parses its frame of image data into a smaller region of image data, referred to as a "a line group", and then passes the line group through the network 104 to a particular sheet generator. A complete or "full" singular line group may be composed, for example, with the data of multiple contiguous complete rows or columns of a frame (for simplicity the present specification will mainly refer to contiguous rows). The sheet generator further parses the line group of image data into a smaller region of image data, referred to as a "sheet", and presents the sheet to its corresponding stencil processor.</p>
<p id="p0018" num="0018">In the case of an image processing pipeline or a DAG flow having a single input, generally, input frames are directed to the same line buffer unit 101_1 which parses the image data into line groups and directs the line groups to the sheet generator 103_1 whose corresponding stencil processor 102_1 is executing the code of the first kernel in the pipeline/DAG. Upon completion of operations by the stencil processor 102_1 on the line groups it processes, the sheet generator 103_1 sends output line groups to a "downstream" line buffer<!-- EPO <DP n="6"> --> unit 101_2 (in some use cases the output line group may be sent_back to the same line buffer unit 101_1 that earlier had sent the input line groups).</p>
<p id="p0019" num="0019">One or more "consumer" kernels that represent the next stage/operation in the pipeline/DAG executing on their own respective other sheet generator and stencil processor (e.g., sheet generator 103_2 and stencil processor 102_2) then receive from the downstream line buffer unit 101_2 the image data generated by the first stencil processor 102_1. In this manner, a "producer" kernel operating on a first stencil processor has its output data forwarded to a "consumer" kernel operating on a second stencil processor where the consumer kernel performs the next set of tasks after the producer kernel consistent with the design of the overall pipeline or DAG.</p>
<p id="p0020" num="0020">A stencil processor 102 is designed to simultaneously operate on multiple overlapping stencils of image data. The multiple overlapping stencils and internal hardware processing capacity of the stencil processor effectively determines the size of a sheet. Here, within a stencil processor 102, arrays of execution lanes operate in unison to simultaneously process the image data surface area covered by the multiple overlapping stencils.</p>
<p id="p0021" num="0021">As will be described in more detail below, in various embodiments<u>,</u> sheets of image data are loaded into a two-dimensional register array structure within the stencil processor 102. The use of sheets and the two-dimensional register array structure is believed to effectively provide for power consumption improvements by moving a large amount of data into a large amount of register space as, e.g., a single load operation with processing tasks performed directly on the data immediately thereafter by an execution lane array. Additionally, the use of an execution lane array and corresponding register array provide for different stencil sizes that are easily programmable/configurable.</p>
<p id="p0022" num="0022"><figref idref="f0002 f0003 f0004 f0005 f0006">Figs. 2a through 2e</figref> illustrate at a high level embodiments of both the parsing activity of a line buffer unit 101, the finer grained parsing activity of a sheet generator unit 103 as well as the stencil processing activity of the stencil processor 102 that is coupled to the sheet generator unit 103.</p>
<p id="p0023" num="0023"><figref idref="f0002">Fig. 2a</figref> depicts an embodiment of an input frame of image data 201. <figref idref="f0002">Fig. 2a</figref> also depicts an outline of three overlapping stencils 202 (each having a dimension of 3 pixels x 3 pixels) that a stencil processor is designed to operate over. The output pixel that each stencil respectively generates output image data for is highlighted in solid black. For simplicity, the three overlapping stencils 202 are depicted as overlapping only in the vertical direction. It is<!-- EPO <DP n="7"> --> pertinent to recognize that in actuality a stencil processor may be designed to have overlapping stencils in both the vertical and horizontal directions.</p>
<p id="p0024" num="0024">Because of the vertical overlapping stencils 202 within the stencil processor, as observed in <figref idref="f0002">Fig. 2a</figref>, there exists a wide band of image data within the frame that a single stencil processor can operate over. As will be discussed in more detail below, in an embodiment, the stencil processors process data within their overlapping stencils in a left to right fashion across the image data (and then repeat for the next set of lines, in top to bottom order). Thus, as the stencil processors continue forward with their operation, the number of solid black output pixel blocks will grow right-wise horizontally. As discussed above, a line buffer unit 101 is responsible for parsing a line group of input image data from an incoming frame that is sufficient for the stencil processors to operate over for an extended number of upcoming cycles. An exemplary depiction of a line group is illustrated as a shaded region 203. In an embodiment, the line buffer unit 101 can comprehend different dynamics for sending/receiving a line group to/from a sheet generator. For example, according to one mode, referred to as "full group", the complete full width lines of image data are passed between a line buffer unit and a sheet generator. According to a second mode, referred to as "virtually tall", a line group is passed initially with a subset of full width rows. The remaining rows are then passed sequentially in smaller (less than full width) pieces.</p>
<p id="p0025" num="0025">With the line group 203 of the input image data having been defined by the line buffer unit and passed to the sheet generator unit, the sheet generator unit further parses the line group into finer sheets that are more precisely fitted to the hardware limitations of the stencil processor. More specifically, as will be described in more detail further below, in an embodiment, each stencil processor consists of a two dimensional shift register array. The two dimensional shift register array essentially shifts image data "beneath" an array of execution lanes where the pattern of the shifting causes each execution lane to operate on data within its own respective stencil (that is, each execution lane processes on its own stencil of information to generate an output for that stencil). In an embodiment, sheets are surface areas of input image data that "fill" or are otherwise loaded into the two dimensional shift register array.</p>
<p id="p0026" num="0026">As will be described in more detail below, in various embodiments, there are actually multiple layers of two dimensional register data that can be shifted on any cycle. For convenience, much of the present description will simply use the term "two-dimensional shift register" and the like to refer to structures that have one or more such layers of two-dimensional register data that can be shifted.<!-- EPO <DP n="8"> --></p>
<p id="p0027" num="0027">Thus, as observed in <figref idref="f0003">Fig. 2b</figref>, the sheet generator parses an initial sheet 204 from the line group 203 and provides it to the stencil processor (here, the sheet of data corresponds to the shaded region that is generally identified by reference number 204). As observed in <figref idref="f0004">Figs. 2c</figref> and <figref idref="f0005">2d</figref>, the stencil processor operates on the sheet of input image data by effectively moving the overlapping stencils 202 in a left to right fashion over the sheet. As of <figref idref="f0005">Fig. 2d</figref>, the number of pixels for which an output value could be calculated from the data within the sheet is exhausted (no other pixel positions can have an output value determined from the information within the sheet). For simplicity the border regions of the image have been ignored.</p>
<p id="p0028" num="0028">As observed in <figref idref="f0006">Fig. 2e</figref> the sheet generator then provides a next sheet 205 for the stencil processor to continue operations on. Note that the initial positions of the stencils as they begin operation on the next sheet is the next progression to the right from the point of exhaustion on the first sheet (as depicted previously in <figref idref="f0005">Fig. 2d</figref>). With the new sheet 205, the stencils will simply continue moving to the right as the stencil processor operates on the new sheet in the same manner as with the processing of the first sheet.</p>
<p id="p0029" num="0029">Note that there is some overlap between the data of the first sheet 204 and the data of the second sheet 205 owing to the border regions of stencils that surround an output pixel location. The overlap could be handled simply by the sheet generator re-transmitting the overlapping data twice. In alternate implementations, to feed a next sheet to the stencil processor, the sheet generator may proceed to only send new data to the stencil processor and the stencil processor reuses the overlapping data from the previous sheet.</p>
<heading id="h0007"><b><i><u>b. stencil processor design and operation</u></i></b></heading>
<p id="p0030" num="0030"><figref idref="f0007">Fig. 3a</figref> shows an embodiment of a stencil processor architecture 300. As observed in <figref idref="f0007">Fig. 3a</figref>, the stencil processor includes a data computation unit 301, a scalar processor 302 and associated memory 303 and an I/O unit 304. The data computation unit 301 includes an array of execution lanes 305, a two-dimensional shift array structure 306 and separate random access memories 307 associated with specific rows or columns of the array.</p>
<p id="p0031" num="0031">The I/O unit 304 is responsible for loading "input" sheets of data received from the sheet generator into the data computation unit 301 and storing "output" sheets of data from the stencil processor into the sheet generator. In an embodiment the loading of sheet data into the data computation unit 301 entails parsing a received sheet into rows/columns of image data and loading the rows/columns of image data into the two dimensional shift register structure 306 or respective random access memories 307 of the rows/columns of the execution lane array (described in more detail below). If the sheet is initially loaded into memories 307, the<!-- EPO <DP n="9"> --> individual execution lanes within the execution lane array 305 may then load sheet data into the two-dimensional shift register structure 306 from the random access memories 307 when appropriate (e.g., as a load instruction just prior to operation on the sheet's data). Upon completion of the loading of a sheet of data into the register structure 306 (whether directly from a sheet generator or from memories 307), the execution lanes of the execution lane array 305 operate on the data and eventually "write back" finished data as a sheet directly back to the sheet generator, or, into the random access memories 307. If the later the I/O unit 304 fetches the data from the random access memories 307 to form an output sheet which is then forwarded to the sheet generator.</p>
<p id="p0032" num="0032">The scalar processor 302 includes a program controller 309 that reads the instructions of the stencil processor's program code from scalar memory 303 and issues the instructions to the execution lanes in the execution lane array 305. In an embodiment, a single same instruction is broadcast to all execution lanes within the array 305 to effect a SIMD-like behavior from the data computation unit 301. In an embodiment, the instruction format of the instructions read from scalar memory 303 and issued to the execution lanes of the execution lane array 305 includes a very-long-instruction-word (VLIW) type format that includes more than one opcode per instruction. In a further embodiment, the VLIW format includes both an ALU opcode that directs a mathematical function performed by each execution lane's ALU (which, as described below, in an embodiment may specify more than one traditional ALU operation) and a memory opcode (that directs a memory operation for a specific execution lane or set of execution lanes).</p>
<p id="p0033" num="0033">The term "execution lane" refers to a set of one or more execution units capable of executing an instruction (e.g., logic circuitry that can execute an instruction). An execution lane can, in various embodiments, include more processor-like functionality beyond just execution units, however. For example, besides one or more execution units, an execution lane may also include logic circuitry that decodes a received instruction, or, in the case of more MIMD-like designs, logic circuitry that fetches and decodes an instruction. With respect to MIMD-like approaches, although a centralized program control approach has largely been described herein, a more distributed approach may be implemented in various alternative embodiments (e.g., including program code and a program controller within each execution lane of the array 305).</p>
<p id="p0034" num="0034">The combination of an execution lane array 305, program controller 309 and two dimensional shift register structure 306 provides a widely adaptable/configurable hardware platform for a broad range of programmable functions. For example, application software developers are able to program kernels having a wide range of different functional capability as<!-- EPO <DP n="10"> --> well as dimension (e.g., stencil size) given that the individual execution lanes are able to perform a wide variety of functions and are able to readily access input image data proximate to any output array location.</p>
<p id="p0035" num="0035">Apart from acting as a data store for image data being operated on by the execution lane array 305, the random access memories 307 may also keep one or more look-up tables. In various embodiments one or more scalar look-up tables may also be instantiated within the scalar memory 303.</p>
<p id="p0036" num="0036">A scalar look-up involves passing the same data value from the same look-up table from the same index to each of the execution lanes within the execution lane array 305. In various embodiments, the VLIW instruction format described above is expanded to also include a scalar opcode that directs a look-up operation performed by the scalar processor into a scalar look-up table. The index that is specified for use with the opcode may be an immediate operand or fetched from some other data storage location. Regardless, in an embodiment, a look-up from a scalar look-up table within scalar memory essentially involves broadcasting the same data value to all execution lanes within the execution lane array 305 during the same clock cycle. Additional details concerning use and operation of look-up tables is provided further below.</p>
<p id="p0037" num="0037"><figref idref="f0008">Fig. 3b</figref> summarizes the VLIW instruction word embodiments(s) discussed above. As observed in <figref idref="f0008">Fig. 3b</figref>, the VLIW instruction word format includes fields for three separate instructions: 1) a scalar instruction 351 that is executed by the scalar processor; 2) an ALU instruction 352 that is broadcasted and executed in SIMD fashion by the respective ALUs within the execution lane array; and, 3) a memory instruction 353 that is broadcasted and executed in a partial SIMD fashion (e.g., if execution lanes along a same row in the execution lane array share a same random access memory, then one execution lane from each of the different rows actually execute the instruction (the format of the memory instruction 353 may include an operand that identifies which execution lane from each row executes the instruction)</p>
<p id="p0038" num="0038">A field 354 for one or more immediate operands is also included. Which of the instructions 351, 352, 353 use which immediate operand information may be identified in the instruction format. Each of instructions 351, 352, 353 also include their own respective input operand and resultant information (e.g., local registers for ALU operations and a local register and a memory address for memory access instructions). In an embodiment, the scalar instruction 351 is executed by the scalar processor before the execution lanes within the execution lane array execute either of the other to instructions 352, 353. That is, the execution of the VLIW word includes a first cycle upon which the scalar instruction 351 is executed followed by a second<!-- EPO <DP n="11"> --> cycle upon with the other instructions 352, 353 may be executed (note that in various embodiments instructions 352 and 353 may be executed in parallel).</p>
<p id="p0039" num="0039">In an embodiment, the scalar instructions executed by the scalar processor include commands issued to the sheet generator to load/store sheets from/into the memories or 2D shift register of the data computation unit. Here, the sheet generator's operation can be dependent on the operation of the line buffer unit or other variables that prevent pre-runtime comprehension of the number of cycles it will take the sheet generator to complete any command issued by the scalar processor. As such, in an embodiment, any VLIW word whose scalar instruction 351 corresponds to or otherwise causes a command to be issued to the sheet generator also includes no-operation (NOOP) instructions in the other two instruction field 352, 353. The program code then enters a loop of NOOP instructions for instruction fields 352, 353 until the sheet generator completes its load/store to/from the data computation unit. Here, upon issuing a command to the sheet generator, the scalar processor may set a bit of an interlock register that the sheet generator resets upon completion of the command. During the NOOP loop the scalar processor monitors the bit of the interlock bit. When the scalar processor detects that the sheet generator has completed its command normal execution begins again.</p>
<p id="p0040" num="0040"><figref idref="f0009">Fig. 4</figref> shows an embodiment of a data computation component 401. As observed in <figref idref="f0009">Fig. 4</figref>, the data computation component 401 includes an array of execution lanes 405 that are logically positioned "above" a two-dimensional shift register array structure 406. As discussed above, in various embodiments, a sheet of image data provided by a sheet generator is loaded into the two-dimensional shift register 406. The execution lanes then operate on the sheet data from the register structure 406.</p>
<p id="p0041" num="0041">The execution lane array 405 and shift register structure 406 are fixed in position relative to one another. However, the data within the shift register array 406 shifts in a strategic and coordinated fashion to cause each execution lane in the execution lane array to process a different stencil within the data. As such, each execution lane determines the output image value for a different pixel in the output sheet being generated. From the architecture of <figref idref="f0009">Fig. 4</figref> it should be clear that overlapping stencils are not only arranged vertically but also horizontally as the execution lane array 405 includes vertically adjacent execution lanes as well as horizontally adjacent execution lanes.</p>
<p id="p0042" num="0042">Some notable architectural features of the data computation unit 401 include the shift register structure 406 having wider dimensions than the execution lane array 405. That is, there is a "halo" of registers 409 outside the execution lane array 405. Although the halo 409 is shown<!-- EPO <DP n="12"> --> to exist on two sides of the execution lane array, depending on implementation, the halo may exist on less (one) or more (three or four) sides of the execution lane array 405. The halo 405 serves to provide "spill-over" space for data that spills outside the bounds of the execution lane array 405 as the data is shifting "beneath" the execution lanes 405. As a simple case, a 5x5 stencil centered on the right edge of the execution lane array 405 will need four halo register locations further to the right when the stencil's leftmost pixels are processed. For ease of drawing, <figref idref="f0009">Fig. 4</figref> shows the registers of the right side of the halo as only having horizontal shift connections and registers of the bottom side of the halo as only having vertical shift connections when, in a nominal embodiment, registers on either side (right, bottom) would have both horizontal and vertical connections.</p>
<p id="p0043" num="0043">Additional spill-over room is provided by random access memories 407 that are coupled to each row and/or each column in the array, or portions thereof (E.g., a random access memory may be assigned to a "region" of the execution lane array that spans 4 execution lanes row wise and 2 execution lanes column wise. For simplicity the remainder of the application will refer mainly to row and/or column based allocation schemes). Here, if an execution lane's kernel operations require it to process pixel values outside of the two-dimensional shift register array 406 (which some image processing routines may require) the plane of image data is able to further spill-over, e.g., from the halo region 409 into random access memory 407. For example, consider a 6X6 stencil where the hardware includes a halo region of only four storage elements to the right of an execution lane on the right edge of the execution lane array. In this case, the data would need to be shifted further to the right off the right edge of the halo 409 to fully process the stencil. Data that is shifted outside the halo region 409 would then spill-over to random access memory 407. Other applications of the random access memories 407 and the stencil processor of <figref idref="f0007 f0008">Fig. 3</figref> are provided further below.</p>
<p id="p0044" num="0044"><figref idref="f0010 f0011 f0012 f0013 f0014 f0015 f0016 f0017 f0018 f0019 f0020">Figs. 5a through 5k</figref> demonstrate a working example of the manner in which image data is shifted within the two dimensional shift register array "beneath" the execution lane array as alluded to above. As observed in <figref idref="f0010">Fig. 5a</figref>, the data contents of the two dimensional shift array are depicted in a first array 507 and the execution lane array is depicted by a frame 505. Also, two neighboring execution lanes 510 within the execution lane array are simplistically depicted. In this simplistic depiction 510, each execution lane includes a register R1 that can accept data from the shift register, accept data from an ALU output (e.g., to behave as an accumulator across cycles), or write output data into an output destination.<!-- EPO <DP n="13"> --></p>
<p id="p0045" num="0045">Each execution lane also has available, in a local register R2, the contents "beneath" it in the two dimensional shift array. Thus, R1 is a physical register of the execution lane while R2 is a physical register of the two dimensional shift register array. The execution lane includes an ALU that can operate on operands provided by R1 and/or R2. As will be described in more detail further below, in an embodiment the shift register is actually implemented with multiple (a "depth" of) storage/register elements per array location but the shifting activity is limited to one plane of storage elements (e.g., only one plane of storage elements can shift per cycle). <figref idref="f0010 f0011 f0012 f0013 f0014 f0015 f0016 f0017 f0018 f0019 f0020">Figs. 5a through 5k</figref> depict one of these deeper register locations as being used to store the resultant X from the respective execution lanes. For illustrative ease the deeper resultant register is drawn alongside rather than beneath its counterpart register R2.</p>
<p id="p0046" num="0046"><figref idref="f0010 f0011 f0012 f0013 f0014 f0015 f0016 f0017 f0018 f0019 f0020">Figs. 5a through 5k</figref> focus on the calculation of two stencils whose central position is aligned with the pair of execution lane positions 511 depicted within the execution lane array. For ease of illustration, the pair of execution lanes 510 are drawn as horizontal neighbors when in fact, according to the following example, they are vertical neighbors.</p>
<p id="p0047" num="0047">As observed initially in <figref idref="f0010">Fig. 5a</figref>, the execution lanes are centered on their central stencil locations. <figref idref="f0011">Fig. 5b</figref> shows the object code executed by both execution lanes. As observed in <figref idref="f0011">Fig. 5b</figref> the program code of both execution lanes causes the data within the shift register array to shift down one position and shift right one position. This aligns both execution lanes to the upper left hand corner of their respective stencils. The program code then causes the data that is located (in R2) in their respective locations to be loaded into R1.</p>
<p id="p0048" num="0048">As observed in <figref idref="f0012">Fig. 5c</figref> the program code next causes the pair of execution lanes to shift the data within the shift register array one unit to the left which causes the value to the right of each execution lane's respective position to be shifted into each execution lane' position. The value in R1 (previous value) is then added with the new value that has shifted into the execution lane's position (in R2). The resultant is written into R1. As observed in <figref idref="f0013">Fig. 5d</figref> the same process as described above for <figref idref="f0012">Fig. 5c</figref> is repeated which causes the resultant R1 to now include the value A+B+C in the upper execution lane and F+G+H in the lower execution lane. At this point both execution lanes have processed the upper row of their respective stencils. Note the spill-over into a halo region on the left side of the execution lane array (if one exists on the left hand side) or into random access memory if a halo region does not exist on the left hand side of the execution lane array.</p>
<p id="p0049" num="0049">As observed in <figref idref="f0014">Fig. 5e</figref>, the program code next causes the data within the shift register array to shift one unit up which causes both execution lanes to be aligned with the right edge of<!-- EPO <DP n="14"> --> the middle row of their respective stencils. Register R1 of both execution lanes currently includes the summation of the stencil's top row and the middle row's rightmost value. <figref idref="f0015">Figs. 5f</figref> and <figref idref="f0016">5g</figref> demonstrate continued progress moving leftwise across the middle row of both execution lane's stencils. The accumulative addition continues such that at the end of processing of <figref idref="f0016">Fig. 5g</figref> both execution lanes include the summation of the values of the top row and the middle row of their respective stencils.</p>
<p id="p0050" num="0050"><figref idref="f0017">Fig. 5h</figref> shows another shift to align each execution lane with its corresponding stencil's lowest row. <figref idref="f0018">Figs. 5i</figref> and <figref idref="f0019">5j</figref> show continued shifting to complete processing over the course of both execution lanes' stencils. <figref idref="f0020">Fig. 5k</figref> shows additional shifting to align each execution lane with its correct position in the data array and write the resultant thereto.</p>
<p id="p0051" num="0051">In the example of <figref idref="f0010 f0011 f0012 f0013 f0014 f0015 f0016 f0017 f0018 f0019 f0020">Figs 5a-5k</figref> note that the object code for the shift operations may include an instruction format that identifies the direction and magnitude of the shift expressed in (X, Y) coordinates. For example, the object code for a shift up by one location may be expressed in object code as SHIFT 0, +1. As another example, a shift to the right by one location may expressed in object code as SHIFT +1, 0. In various embodiments shifts of larger magnitude may also be specified in object code (e.g., SHIFT 0, +2). Here, if the 2D shift register hardware only supports shifts by one location per cycle, the instruction may be interpreted by the machine to require multiple cycle execution, or, the 2D shift register hardware may be designed to support shifts by more than one location per cycle. Embodiments of the later are described in more detail further below.</p>
<p id="p0052" num="0052"><figref idref="f0021">Fig.6</figref> shows another, more detailed depiction of the unit cell for the array execution lane and shift register structure (registers in the halo region do not include a corresponding execution lane). The execution lane and the register space associated with each location in the execution lane array is, in an embodiment, implemented by instantiating the circuitry observed in <figref idref="f0021">Fig.6</figref> at each node of the execution lane array. As observed in <figref idref="f0021">Fig.6</figref>, the unit cell includes an execution lane 601 coupled to a register file 602 consisting of four registers R2 through R5. During any cycle, the execution lane 601 may read from or write to any of registers R1 through R5. For instructions requiring two input operands the execution lane may retrieve both of operands from any of R1 through R5.</p>
<p id="p0053" num="0053">In an embodiment, the two dimensional shift register structure is implemented by permitting, during a single cycle, the contents of any of (only) one of registers R2 through R4 to be shifted "out" to one of its neighbor's register files through output multiplexer 603, and, having the contents of any of (only) one of registers R2 through R4 replaced with content that is<!-- EPO <DP n="15"> --> shifted "in" from a corresponding one if its neighbors through input multiplexers 604 such that shifts between neighbors are in a same direction (e.g., all execution lanes shift left, all execution lanes shift right, etc.). Although it may be common for a same register to have its contents shifted out and replaced with content that is shifted in on a same cycle, the multiplexer arrangement 603, 604 permits for different shift source and shift target registers within a same register file during a same cycle.</p>
<p id="p0054" num="0054">As depicted in <figref idref="f0021">Fig.6</figref> note that during a shift sequence an execution lane will shift content out from its register file 602 to each of its left, right, top and bottom neighbors. In conjunction with the same shift sequence, the execution lane will also shift content into its register file from a particular one of its left, right, top and bottom neighbors. Again, the shift out target and shift in source should be consistent with a same shift direction for all execution lanes (e.g., if the shift out is to the right neighbor, the shift in should be from the left neighbor).</p>
<p id="p0055" num="0055">Although in one embodiment the content of only one register is permitted to be shifted per execution lane per cycle, other embodiments may permit the content of more than one register to be shifted in/out. For example, the content of two registers may be shifted out/in during a same cycle if a second instance of the multiplexer circuitry 603, 604 observed in <figref idref="f0021">Fig.6</figref> is incorporated into the design of <figref idref="f0021">Fig.6</figref>. Of course, in embodiments where the content of only one register is permitted to be shifted per cycle, shifts from multiple registers may take place between mathematical operations by consuming more clock cycles for shifts between mathematical operations (e.g., the contents of two registers may be shifted between math ops by consuming two shift ops between the math ops).</p>
<p id="p0056" num="0056">If less than all the content of an execution lane's register files are shifted out during a shift sequence note that the content of the non shifted out registers of each execution lane remain in place (do not shift). As such, any non shifted content that is not replaced with shifted in content persists local to the execution lane across the shifting cycle. The memory unit ("M") observed in each execution lane is used to load/store data from/to the random access memory space that is associated with the execution lane's row and/or column within the execution lane array. Here, the M unit acts as a standard M unit in that it is often used to load/store data that cannot be loaded/stored from/to the execution lane's own register space. In various embodiments, the primary operation of the M unit is to write data from a local register into memory, and, read data from memory and write it into a local register.</p>
<p id="p0057" num="0057">With respect to the ISA opcodes supported by the ALU unit of the hardware execution lane 601, in various embodiments, the mathematical opcodes supported by the hardware ALU<!-- EPO <DP n="16"> --> are integrally tied with (e.g., substantially the same as) the mathematical opcodes supported by a virtual execution lane (e.g., ADD, SUB, MOV, MUL, MAD, ABS, DIV, SHL, SHR, MIN/MAX, SEL, AND, OR, XOR, NOT). As described just above, memory access instructions can be executed by the execution lane 601 to fetch/store data from/to their associated random access memory. Additionally the hardware execution lane 601 supports shift op instructions (right, left, up, down) to shift data within the two dimensional shift register structure. As described above, program control instructions are largely executed by the scalar processor of the stencil processor.</p>
<heading id="h0008"><b><i><u>c. sheet generator operation and design</u></i></b></heading>
<p id="p0058" num="0058"><figref idref="f0022 f0023 f0024 f0025 f0026 f0027">Figs. 7-12</figref> pertain to special considerations and/or operations of the sheet generator. As described above, a sheet generator is responsible for generating sheets of information for processing by a corresponding stencil processor. In order to impose wide versatility/programmability into the design of the overall processor, the sheet generator in some circumstances may need to perform additional operations in preparing an input sheet beyond just parsing appropriate sections from a received line group.</p>
<p id="p0059" num="0059">For example, in some cases the program code will call for simultaneously processing multiple channels of a same image. For example many video images have a red (R) channel, a blue (B) channel and green (G) channel. In an embodiment the sheet generator is implemented with a processor having associated memory and program code that executes out of the memory.</p>
<p id="p0060" num="0060">As observed in <figref idref="f0022">Fig. 7</figref>, in response to a need detected from the application software that the kernel will simultaneously process data from different channels (which may have been hinted at from a compiler) the program code executed by the sheet generator will proceed to form separate sheets along different "planes" (i.e., form a different sheet from each channel) and load them together into the data computation unit. That is, the sheet generator will generate an R sheet, a B sheet and a G sheet for a same section of the array and load all three sheets into the computation unit. The execution lanes within the execution lane array are then free to operate on the R, G and B sheets as needed (e.g., by storing an R sheet in one layer of the register file, a G sheet in the another layer of the register file and a B sheet in yet another layer of the register file).</p>
<p id="p0061" num="0061"><figref idref="f0023">Fig. 8</figref> pertains to sheet generation for multi-dimensional input images. Here, although many input images are in the form of a simple array, in some cases each location of the array will correspond to a multi-dimensional data construct. As an illustrative example, <figref idref="f0023">Fig. 8</figref> depicts an image where each array location contains 27 different values that correspond to different<!-- EPO <DP n="17"> --> segments of 3x3x3 cube. Here, where each array location has a multi-dimensional data construct, the sheet generator will "unroll" the input array to form a separate sheet for each data construct dimension. Thus, as seen in <figref idref="f0023">Fig. 8</figref>, the sheet generator will generate 27 sheets (one for each cube segment) where each array location of each sheet across all the sheets contains a scalar value (one cube segment). The 27 sheets are then loaded into the stencil processor. The program code executed by the execution lanes within the execution lane array then operate on the 27 sheets with an understanding of the manner in which the multi-dimensional input array has been unrolled.</p>
<p id="p0062" num="0062"><figref idref="f0024">Fig. 9</figref> pertains to a technique used to permit the execution lanes within the execution lane array to handle different data bit widths. Here, as is understood in the art, greater dynamic range is achieved by increasing the bit width of the data values (a 16 bit value can express values with greater dynamic range than an 8 bit value can). In an embodiment, the stencil processors are expected to operate on images having different bit widths such as 8, 16 or 32 bit pixel values. As such, according to one approach, the execution lanes themselves are 32 bit machines in the sense that the execution lanes internally can handle 32 bit operands.</p>
<p id="p0063" num="0063">However, to decrease the size and complexity of the two dimensional shift register, the individual storage elements of the registers within each execution lane's register file are limited to 8 bits. In the case of 8 bit image data there is no issue because an entire sheet of data can fit in one register of the register file. By contrast, in the case of 16 or 32 bit operands, the sheet generator generates multiple sheets to appropriately express the input operand data set.</p>
<p id="p0064" num="0064">For example, as depicted in <figref idref="f0024">Fig. 9</figref> in the case of 16 bit input operands the sheet generator will generate a HI half sheet and a LO half sheet. The HI half sheet contains the upper 8 bits of each data item at the correct array location. The LO half sheet contains the lower 8 bits of each data item at the correct array location. 16 bit operations are then performed by loading both sheets into the stencil processor and informing the execution lane hardware (e.g., via an immediate value in the program code) that 16 bit operation is to take place. Here, as just one possible mode of operation, both the HI and LO sheets are loaded in two different registers of each execution lanes register file.</p>
<p id="p0065" num="0065">The execution lane units are able to internally construct the correct operands by first reading from one of the register file locations and appending the data therein with the data read from another of the register file locations. Similarly, in the write direction, the execution lane units will have to perform two writes. Specifically, a first write of the lower 8 bits to a first<!-- EPO <DP n="18"> --> register of the register file containing the LO sheet and then a second write of the upper 8 bits to a second register of the register file containing the HI sheet.</p>
<p id="p0066" num="0066">Recall from the discussion of <figref idref="f0027">Fig. 12</figref> that in various embodiment shifts the content of only one register is permitted to be shifted per cycle. As such, in order to move 16 bit data values around the two dimensional shift register structure, two cycles are consumed per shift sequence (between math ops) rather than one cycle in the case of 8 bit data values. That is, in the nominal case of 8 bit data values, all data can be shifted between locations in a single cycle. By contrast in the case of 16 bit data values, two 8 bit values have to be shifted per shift register shift operation (the HI half sheet and the LO half sheet). In an embodiment, in the case of 32 bits, the same principles apply except that four sheets are created to represent the entire image data rather than two sheets. Likewise, as many as four cycles may need to be consumed per shift sequence.</p>
<p id="p0067" num="0067"><figref idref="f0025">Fig. 10</figref> pertains to situations where the image processor "up-samples" the input image data from a lower density resolution to a higher density resolution. Here, the stencil processors are responsible for generating more output values per unit area of an image than the input image contains. The sheet generator handles the up-sampling problem by repeating a same data value across a sheet such that the sheet data value density corresponds to the up-sampled (higher density) output image. That is, for example in the case where the output execution lane array density corresponds to 4:1 up-sampling in view of the density of the input image (four output pixels for every input pixel), as observed in <figref idref="f0025">Fig. 10</figref>, the sheet generator manufactures a sheet with four identical values for every input value.</p>
<p id="p0068" num="0068"><figref idref="f0026">Fig. 11</figref> pertains to the reverse situation of "down-sampling". In the case of down-sampling, the sheet generator will generate more sheets than for a lower density input image. Specifically, if the input image has a factor of S higher resolution in one (e.g., X) direction and a factor of T higher resolution in the other (e.g., Y) direction, the sheet generator will generate S*T sheets from an initial more dense initial sheet. This effectively assigns more input pixels to any particular output pixel.</p>
<p id="p0069" num="0069"><figref idref="f0027">Fig. 12</figref> pertains to situations where the mathematical operations performed by the execution lanes within the execution lane array require a larger surface area of image data than the size of the two-dimensional shift register structure. As observed in <figref idref="f0027">Fig. 12</figref>, the sheet to be loaded into the two-dimensional shift register structure for processing corresponds to the shaded region 1201 of an input frame. The mathematical operations that will calculate output values for array locations within the shaded area, however, require values within the frame that is bounded<!-- EPO <DP n="19"> --> by the dashed border 1202 observed in <figref idref="f0027">Fig. 12</figref>. Thus, there exists a large "support region" outside the surface area of the two-dimensional shift register structure that will be included in the operations.</p>
<p id="p0070" num="0070">Under these conditions the sheet generator will not only load a sheet corresponding to the shaded region 1201 into the stencil processor but will also load the three (unshaded) neighboring sheets into the data computation unit. The program code executed by the execution lanes will call in and move out sheets to/from random access memory as needed and/or store some or all of the sheets in the deeper registers of the two dimensional shift register array.</p>
<p id="p0071" num="0071"><figref idref="f0028">Fig. 13</figref> provides an embodiment of the hardware design 1300 for the sheet generator. As observed in <figref idref="f0028">Fig. 13</figref>, in an embodiment, the sheet generator is implemented as a computing system having a processor/controller 1301 that executes program code stored in memory 1302 to perform sheet generator tasks such as any of the tasks described above with respect to <figref idref="f0022 f0023 f0024 f0025 f0026 f0027">Figs. 7-12</figref>. The sheet generator also includes an I/O unit 1303 for receiving/sending line groups from/to the network and receiving/sending sheets from/to the sheet generator's associated stencil processor.</p>
<p id="p0072" num="0072">A pertinent feature of the sheet generator is its configuration space 1304 which may be implemented as separate register space within the sheet generator (as depicted in <figref idref="f0028">Fig. 13</figref>), within the processor/controller 1301 and/or within memory 1302. The configuration space 1304 lends itself to the wide adaptability and programmability of the overall platform. Here, settings made in the configuration space 1304 may include, e.g., pertinent image features and dimensions such as frame size, line group size, sheet size, input image pixel resolution, output image pixel resolution, etc. The program code within memory 1302 then uses the information within configuration space as input variables to effect correct operation on correctly sized sheets, etc.</p>
<p id="p0073" num="0073">Alternatively or in some combination, the wide adaptability and programmability of the overall platform may be realized by loading custom program code into memory 1302 for a particular application and/or image dimension(s). Here, for example, a compiler may be able to make easy reference to the X, Y coordinates of the position relative addressing scheme and/or any of frame size and line group size to easily determine sheet sizes, sheet boundaries, etc and customize generic program code templates into software programs that are specific to the image processing task at hand. Likewise, any such translation and practical use of the relative positioning or other image dimensions may be entered into configuration space 1304 where program code existent on the sheet generator makes determinations of sheet boundaries, sheet sizes, etc.</p>
<heading id="h0009"><b><i><u>d. implementation embodiments</u></i></b></heading><!-- EPO <DP n="20"> -->
<p id="p0074" num="0074">It is pertinent to point out that the various image processor architecture features described above are not necessarily limited to image processing in the traditional sense and therefore may be applied to other applications that may (or may not) cause the image processor to be re-characterized. For example, if any of the various image processor architecture features described above were to be used in the creation and/or generation and/or rendering of animation as opposed to the processing of actual camera images, the image processor may be characterized as a graphics processing unit. Additionally, the image processor architectural features described above may be applied to other technical applications such as video processing, vision processing, image recognition and/or machine learning. Applied in this manner, the image processor may be integrated with (e.g., as a co-processor to) a more general purpose processor (e.g., that is or is part of a CPU of computing system), or, may be a stand alone processor within a computing system.</p>
<p id="p0075" num="0075">The hardware design embodiments discussed above may be embodied within a semiconductor chip and/or as a description of a circuit design for eventual targeting toward a semiconductor manufacturing process. In the case of the later, such circuit descriptions may take of the form of higher/behavioral level circuit descriptions (e.g., a VHDL description) or lower level circuit description (e.g., a register transfer level (RTL) description, transistor level description or mask description) or various combinations thereof. Circuit descriptions are typically embodied on a computer readable storage medium (such as a CD-ROM or other type of storage technology).</p>
<p id="p0076" num="0076">From the preceding sections is pertinent to recognize that an image processor as described above may be embodied in hardware on a computer system (e.g., as part of a handheld device's System on Chip (SOC) that processes data from the handheld device's camera). In cases where the image processor is embodied as a hardware circuit, note that the image data that is processed by the image processor may be received directly from a camera. Here, the image processor may be part of a discrete camera, or, part of a computing system having an integrated camera. In the case of the later the image data may be received directly from the camera or from the computing system's system memory (e.g., the camera sends its image data to system memory rather than the image processor). Note also that many of the features described in the preceding sections may be applicable to a graphics processor unit (which renders animation).</p>
<p id="p0077" num="0077"><figref idref="f0029">Fig. 14</figref> provides an exemplary depiction of a computing system. Many of the components of the computing system described below are applicable to a computing system having an integrated camera and associated image processor (e.g., a handheld device such as a<!-- EPO <DP n="21"> --> smartphone or tablet computer). Those of ordinary skill will be able to easily delineate between the two.</p>
<p id="p0078" num="0078">As observed in <figref idref="f0029">Fig. 14</figref>, the basic computing system may include a central processing unit 1401 (which may include, e.g., a plurality of general purpose processing cores 1415_1 through 1415 N and a main memory controller 1417 disposed on a multi-core processor or applications processor), system memory 1402, a display 1403 (e.g., touchscreen, flat-panel), a local wired point-to-point link (e.g., USB) interface 1404, various network I/O functions 1405 (such as an Ethernet interface and/or cellular modem subsystem), a wireless local area network (e.g., WiFi) interface 1406, a wireless point-to-point link (e.g., Bluetooth) interface 1407 and a Global Positioning System interface 1408, various sensors 1409_1 through 1409 N, one or more cameras 1410, a battery 1414, a power management control unit 1412, a speaker and microphone 1413 and an audio coder/decoder 1414.</p>
<p id="p0079" num="0079">An applications processor or multi-core processor 1450 may include one or more general purpose processing cores 1415 within its CPU 1401, one or more graphical processing units 1416, a memory management function 1417 (e.g., a memory controller), an I/O control function 1418 and an image processing unit 1419. The general purpose processing cores 1415 typically execute the operating system and application software of the computing system. The graphics processing units 1416 typically execute graphics intensive functions to, e.g., generate graphics information that is presented on the display 1403. The memory control function 1417 interfaces with the system memory 1402 to write/read data to/from system memory 1402. The power management control unit 1412 generally controls the power consumption of the system 1400.</p>
<p id="p0080" num="0080">The image processing unit 1419 may be implemented according to any of the image processing unit embodiments described at length above in the preceding sections. Alternatively or in combination, the IPU 1419 may be coupled to either or both of the GPU 1416 and CPU 1401 as a co-processor thereof. Additionally, in various embodiments, the GPU 1416 may be implemented with any of the image processor features described at length above.</p>
<p id="p0081" num="0081">Each of the touchscreen display 1403, the communication interfaces 1404 - 1407, the GPS interface 1408, the sensors 1409, the camera 1410, and the speaker/microphone codec 1413, 1414 all can be viewed as various forms of I/O (input and/or output) relative to the overall computing system including, where appropriate, an integrated peripheral device as well (e.g., the one or more cameras 1410). Depending on implementation, various ones of these I/O components may be integrated on the applications processor/multi-core processor 1450 or may<!-- EPO <DP n="22"> --> be located off the die or outside the package of the applications processor/multi-core processor 1450.</p>
<p id="p0082" num="0082">In an embodiment one or more cameras 1410 includes a depth camera capable of measuring depth between the camera and an object in its field of view. Application software, operating system software, device driver software and/or firmware executing on a general purpose CPU core (or other functional block having an instruction execution pipeline to execute program code) of an applications processor or other processor may perform any of the functions described above.</p>
<p id="p0083" num="0083">Embodiments of the invention may include various processes as set forth above. The processes may be embodied in machine-executable instructions. The instructions can be used to cause a general-purpose or special-purpose processor to perform certain processes. Alternatively, these processes may be performed by specific hardware components that contain hardwired logic for performing the processes, or by any combination of programmed computer components and custom hardware components.</p>
<p id="p0084" num="0084">Elements of the present invention may also be provided as a machine-readable medium for storing the machine-executable instructions. The machine-readable medium may include, but is not limited to, floppy diskettes, optical disks, CD-ROMs, and magneto-optical disks, FLASH memory, ROMs, RAMs, EPROMs, EEPROMs, magnetic or optical cards, propagation media or other type of media/machine-readable medium suitable for storing electronic instructions. For example, the present invention may be downloaded as a computer program which may be transferred from a remote computer (e.g., a server) to a requesting computer (e.g., a client) by way of data signals embodied in a carrier wave or other propagation medium via a communication link (e.g., a modem or network connection).</p>
<p id="p0085" num="0085">In the foregoing specification, the invention has been described with reference to specific exemplary embodiments thereof. It will, however, be evident that various modifications and changes may be made thereto within the scope of the appended claims. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense.</p>
</description>
<claims id="claims01" lang="en"><!-- EPO <DP n="23"> -->
<claim id="c-en-01-0001" num="0001">
<claim-text>A method, comprising:
<claim-text>receiving, by a sheet generator (103_1) and from a line buffer (101_1 ... 101_M), a line group (203) of image data including multiple rows of data from a frame (201) of image data, said multiple rows being sufficient in number to encompass multiple neighboring overlapping stencils (202);</claim-text>
<claim-text>parsing, by the sheet generator (103_1), said line group (203) into a plurality of smaller sized sheets (204, 205); and, for each sheet of the plurality of sheets:
<claim-text>loading, by the sheet generator (103_1), said sheet (204, 205) into a stencil processor (102-1) associated with the sheet generator and comprising a two dimensional shift array structure (306, 406, 602) coupled to an array (305, 405) of execution lanes (510, 601), the execution lane array (305,405) and the shift array structure (306, 406, 602) being fixed in position relative to one another;</claim-text>
<claim-text>executing program code on said array (305, 405) of execution lanes (510, 601) to process said multiple neighboring overlapping stencils (202) over said sheet (204, 205), wherein each execution lane (510, 601) processes its own stencil to generate an output value for that stencil, and wherein the output values of the execution lanes constitute respective pixel values in an output sheet of image data; and</claim-text>
<claim-text>receiving, by the sheet generator (103_1), the output sheet of image data from the associated stencil processor (102_1).</claim-text></claim-text></claim-text></claim>
<claim id="c-en-01-0002" num="0002">
<claim-text>The method of claim 1 wherein said neighboring overlapping stencils (202) extend in both horizontal and vertical directions.</claim-text></claim>
<claim id="c-en-01-0003" num="0003">
<claim-text>The method of claim 1 further comprising:
<claim-text>parsing line groups (203) from more than one channel;</claim-text>
<claim-text>parsing more than one sheet (204, 205) from the more than one channel to create at least two sheets from different channels;</claim-text>
<claim-text>loading said at least two sheets into said two dimensional shift array structure (306, 406, 602);</claim-text>
<claim-text>executing program code on said array (305, 405) of execution lanes (510, 601) to process said multiple neighboring overlapping stencils (202) concurrently over said at least two sheets;<!-- EPO <DP n="24"> --></claim-text>
<claim-text>wherein the two dimensional shift array structure (306,406, 602) comprises a plurality of layers, and wherein loading said at least two sheets into said two dimensional shift array structure (306,406, 602) comprises loading a first sheet having data from a first channel of the more than one channel into a first layer of the plurality of layers and loading a second sheet having data from a second channel of the more than one channel into a second layer of the plurality of layers.</claim-text></claim-text></claim>
<claim id="c-en-01-0004" num="0004">
<claim-text>The method of claim 1 further comprising:
<claim-text>parsing a line group (203) whose frame (201) is structured as an array having a multi-dimensional feature at an array location of the frame (201);</claim-text>
<claim-text>parsing the line group (203) into multiple sheets (204, 205) such that there exists a different sheet for each of the different dimensions of the feature.</claim-text></claim-text></claim>
<claim id="c-en-01-0005" num="0005">
<claim-text>The method of claim 1 wherein the register array (306, 406, 602) contains registers of a first bit width that is smaller than a second bit width at which the execution lanes (510, 601) are able to process data, the method further comprising:
<claim-text>receiving a line group (203) whose data values have the second bit width;</claim-text>
<claim-text>creating first and second sheets (204, 205) from the line group, the first sheet having values of the first size and containing an upper portion of the data values, the second sheet having values of the first size containing a lower portion of the data values;</claim-text>
<claim-text>loading the first and second sheets into the shift register array (306, 406, 602);</claim-text>
<claim-text>concurrently processing the first and second sheets with the array (305, 405) of execution lanes (510, 601) to process the data at the second bit width.</claim-text></claim-text></claim>
<claim id="c-en-01-0006" num="0006">
<claim-text>The method of claim 1 wherein the method further comprises one of:
<claim-text>effecting up-sampling by replicating a data value from a location of the line group (203) multiple times over at a corresponding location on the sheet (204, 205); and</claim-text>
<claim-text>effecting down-sampling by creating a second output sheet from the sheet (204, 205), the second output sheet having a density of pixel values that is less than the density of pixel values of the sheet (204, 205), wherein, no data is lost when comparing the content of the line group (203) that is mapped to the sheet (204, 205) and the second output sheet.</claim-text></claim-text></claim>
<claim id="c-en-01-0007" num="0007">
<claim-text>The method of claim 1 wherein the method further comprises:
<claim-text>recognizing that processing over the stencils (202) requires more image surface area than the sheet (204, 205);<!-- EPO <DP n="25"> --></claim-text>
<claim-text>parsing at least one more sheet from the line group (203) that neighbors the sheet; and,</claim-text>
<claim-text>loading the at least one more sheet into storage space coupled to the execution lanes (510, 601).</claim-text></claim-text></claim>
<claim id="c-en-01-0008" num="0008">
<claim-text>The method of claim 7 wherein the storage space is the two-dimensional shift array (306, 406, 602).</claim-text></claim>
<claim id="c-en-01-0009" num="0009">
<claim-text>The method of claim 1 wherein the method further comprises performing the parsing by executing program code on a processor and/or controller (1301).</claim-text></claim>
<claim id="c-en-01-0010" num="0010">
<claim-text>A machine readable storage medium containing program code that when processed by a processor and/or controller causes a method according to any of claims 1 to 9 to be performed.</claim-text></claim>
<claim id="c-en-01-0011" num="0011">
<claim-text>An apparatus (1400), comprising:<br/>
a sheet generator circuit (103, 1300) comprising electronic circuitry to
<claim-text>receive, from a line buffer (101_1 ... 101_M), a line group (203) of image data including multiple rows of data from a frame (201) of image data, said multiple rows being sufficient in number to encompass multiple neighboring overlapping stencils (202);</claim-text>
<claim-text>parse said line group into a smaller sized sheet (204, 205);</claim-text>
<claim-text>load said sheet (204, 205) into a data computation unit (301, 401) of an associated stencil processor (102_1), the data computation unit having a two dimensional shift array structure (306, 406, 602) coupled to an array (305, 405) of execution lanes (510, 601), the execution lane array (305,405) and the shift array structure (306, 406, 602) being fixed in position relative to one another, the stencil processor processing said multiple neighboring overlapping stencils (202) over said sheet (204, 205), wherein each execution lane (510, 601) is configured to process its own stencil to generate an output value for that stencil, and wherein the output values of the execution lanes constitute respective values in an output sheet of image data; and</claim-text>
<claim-text>receive the output sheet of image data from the associated stencil processor (102_1).</claim-text></claim-text></claim>
<claim id="c-en-01-0012" num="0012">
<claim-text>The apparatus (1400) of claim 11 wherein said neighboring overlapping stencils (202) extend in both horizontal and vertical directions.</claim-text></claim>
<claim id="c-en-01-0013" num="0013">
<claim-text>The apparatus (1400) of claim 11 wherein said electronic circuitry is further to:<!-- EPO <DP n="26"> -->
<claim-text>parse line groups (203) from more than one channel;</claim-text>
<claim-text>parse more than one sheet (204, 205) from the more than one channel to create at least two sheets from different channels;</claim-text>
<claim-text>load said at least two sheets into said data computation unit (301, 401).</claim-text></claim-text></claim>
<claim id="c-en-01-0014" num="0014">
<claim-text>The apparatus (1400) of claim 11 wherein the electronic circuitry is to:
<claim-text>receive a line group (203) whose data values have the second bit width;</claim-text>
<claim-text>create first and second sheets from the line group (203), the first sheet having values of the first size and containing an upper portion of the data values, the second sheet having values of the first size containing a lower portion of the data values;</claim-text>
<claim-text>load the first and second sheets into the data computation unit (301, 401).</claim-text></claim-text></claim>
<claim id="c-en-01-0015" num="0015">
<claim-text>The apparatus (1400) of claim 11 wherein the electronic circuitry is one of:
<claim-text>to effect up-sampling by replicating a data value from a location of the line group (203) multiple times over at a corresponding location on the sheet (204, 205); and</claim-text>
<claim-text>to effect down-sampling by creating a second output sheet from the sheet (204, 205), the second output sheet having a density of pixel values that is less than the density of pixel values of the sheet (204, 205), wherein, no data is lost when comparing the content of the line group (203) that is mapped to the sheet (204, 205) and the second output sheet.</claim-text></claim-text></claim>
</claims>
<claims id="claims02" lang="de"><!-- EPO <DP n="27"> -->
<claim id="c-de-01-0001" num="0001">
<claim-text>Verfahren, umfassend:
<claim-text>Empfangen einer Zeilengruppe (203) von Bilddaten, die mehrere Zeilen von Daten aus einem Rahmen (201) von Bilddaten einschließt, durch einen Blatterzeuger (103_1) und von einem Zeilenpuffer (101_1 ... 101_M), wobei die mehreren Zeilen zahlenmäßig ausreichend sind, um mehrere benachbarte überlappende Schablonen (202) zu umschließen;</claim-text>
<claim-text>Parsen der Zeilengruppe (203) durch den Blatterzeuger (103_1) in eine Vielzahl von Blättern geringerer Größe (204, 205); und, für jedes Blatt der Vielzahl von Blättern:
<claim-text>Laden des Blatts (204, 205) durch den Blatterzeuger (103_1) in einen Schablonenprozessor (102_1), der dem Blatterzeuger zugeordnet ist und eine zweidimensionale Verschiebe-Arraystruktur (306, 406, 602) umfasst, die mit einem Array (305, 405) von Ausführungsbahnen (510, 601) gekoppelt ist, wobei das Ausführungsbahn-Array (305, 405) und die Verschiebe-Arraystruktur (306, 406, 602) in ihrer Position relativ zueinander festgelegt sind;</claim-text>
<claim-text>Ausführen von Programmcode auf dem Array (305, 405) von Ausführungsbahnen (510, 601), um die mehreren benachbarten überlappenden Schablonen (202) auf dem Blatt (204, 205) zu verarbeiten, wobei jede Ausführungsbahn (510, 601) ihre eigene Schablone verarbeitet, um einen Ausgabewert für diese Schablone zu erzeugen, und wobei die Ausgabewerte der Ausführungsbahnen jeweilige Pixelwerte in einem Ausgabeblatt aus Bilddaten bilden; und</claim-text>
<claim-text>Empfangen des Ausgabeblatts von Bilddaten durch den Blatterzeuger (103_1) von dem zugeordneten Schablonenprozessor (102_1).</claim-text></claim-text></claim-text></claim>
<claim id="c-de-01-0002" num="0002">
<claim-text>Verfahren nach Anspruch 1, wobei die benachbarten überlappenden Schablonen (202) sich sowohl in horizontaler als auch in vertikaler Richtung erstrecken.</claim-text></claim>
<claim id="c-de-01-0003" num="0003">
<claim-text>Verfahren nach Anspruch 1, ferner umfassend:
<claim-text>Parsen von Zeilengruppen (203) aus mehr als einem Kanal;</claim-text>
<claim-text>Parsen von mehr als einem Blatt (204, 205) aus dem mehr als einen Kanal, um mindestens zwei Blätter aus unterschiedlichen Kanälen zu erzeugen;</claim-text>
<claim-text>Laden der mindestens zwei Blätter in die zweidimensionale Verschiebe-Arraystruktur (306, 406, 602);</claim-text>
<claim-text>Ausführen von Programmcode auf dem Array (305, 405) von Ausführungsbahnen (510, 601), um die mehreren benachbarten überlappenden Schablonen (202) gleichzeitig auf den mindestens zwei Blättern zu verarbeiten;</claim-text>
<claim-text>wobei die zweidimensionale Verschiebe-Arraystruktur (306, 406, 602) eine Vielzahl von Schichten umfasst, und wobei das Laden der mindestens zwei Blätter in die zweidimensionale Verschiebe-Arraystruktur (306, 406, 602), das Laden eines ersten Blatts<!-- EPO <DP n="28"> --> mit Daten aus einem ersten Kanal des mehr als einen Kanals in eine erste Schicht der Vielzahl von Schichten und das Laden eines zweiten Blatts mit Daten aus einem zweiten Kanal des mehr als einen Kanals in eine zweite Schicht der Vielzahl von Schichten, umfasst.</claim-text></claim-text></claim>
<claim id="c-de-01-0004" num="0004">
<claim-text>Verfahren nach Anspruch 1, ferner umfassend:
<claim-text>Parsen einer Zeilengruppe (203), deren Rahmen (201) als ein Array strukturiert ist, das an einer Array-Speicherstelle des Rahmens (201) ein mehrdimensionales Merkmal aufweist;</claim-text>
<claim-text>Parsen der Zeilengruppe (203) in mehrere Blätter (204, 205), sodass für jede der unterschiedlichen Dimensionen des Merkmals ein anderes Blatt existiert.</claim-text></claim-text></claim>
<claim id="c-de-01-0005" num="0005">
<claim-text>Verfahren nach Anspruch 1, wobei das Register-Array (306, 406, 602) Register mit einer ersten Bitbreite enthält, die kleiner ist als eine zweite Bitbreite, bei der die Ausführungsbahnen (510, 601) Daten verarbeiten können, wobei das Verfahren ferner umfasst:
<claim-text>Empfangen einer Zeilengruppe (203), deren Datenwerte die zweite Bitbreite aufweisen;</claim-text>
<claim-text>Erzeugen eines ersten und eines zweiten Blattes (204, 205) aus der Zeilengruppe, wobei das erste Blatt Werte der ersten Größe aufweist und einen oberen Abschnitt der Datenwerte enthält, wobei das zweite Blatt Werte der ersten Größe aufweist und einen unteren Abschnitt der Datenwerte enthält;</claim-text>
<claim-text>Laden des ersten und des zweiten Blatts in das Schieberegister-Array (306, 406, 602);</claim-text>
<claim-text>gleichzeitiges Verarbeiten des ersten und des zweiten Blatts mit dem Array (305, 405) von Ausführungsbahnen (510, 601), um die Daten mit der zweiten Bitbreite zu verarbeiten.</claim-text></claim-text></claim>
<claim id="c-de-01-0006" num="0006">
<claim-text>Verfahren nach Anspruch 1, wobei das Verfahren ferner eines von Folgendem umfasst:
<claim-text>Bewirken einer Abtastratenerhöhung durch mehrmaliges Kopieren eines Datenwerts von einer Speicherstelle der Zeilengruppe (203) über eine entsprechende Speicherstelle auf dem Blatt (204, 205); und</claim-text>
<claim-text>Bewirken einer Abtastratenverringerung durch Erzeugen eines zweiten Ausgabeblatts aus dem Blatt (204, 205), wobei das zweite Ausgabeblatt eine Pixelwertdichte aufweist, die geringer als die Pixelwertdichte des Blatts (204, 205) ist, wobei keine Daten verloren gehen, wenn der Inhalt der Zeilengruppe (203), die auf das Blatt (204, 205) und das zweite Ausgabeblatt abgebildet wird, verglichen wird.</claim-text></claim-text></claim>
<claim id="c-de-01-0007" num="0007">
<claim-text>Verfahren nach Anspruch 1, wobei das Verfahren ferner umfasst:<!-- EPO <DP n="29"> -->
<claim-text>Erkennen, dass die Verarbeitung auf den Schablonen (202) mehr Bildfläche als das Blatt (204, 205) benötigt;</claim-text>
<claim-text>Parsen mindestens eines weiteren Blatts aus der Zeilengruppe (203), das an das Blatt angrenzt; und</claim-text>
<claim-text>Laden des mindestens einen weiteren Blatts in einen Speicherbereich, der mit den Ausführungsbahnen (510, 601) gekoppelt ist.</claim-text></claim-text></claim>
<claim id="c-de-01-0008" num="0008">
<claim-text>Verfahren nach Anspruch 7, wobei der Speicherbereich das zweidimensionale Verschiebe-Array (306, 406, 602) ist.</claim-text></claim>
<claim id="c-de-01-0009" num="0009">
<claim-text>Verfahren nach Anspruch 1, wobei das Verfahren ferner umfasst: das Durchführen des Parsens durch Ausführen von Programmcode auf einem Prozessor und/oder Controller (1301).</claim-text></claim>
<claim id="c-de-01-0010" num="0010">
<claim-text>Maschinenlesbares Speichermedium, welches Programmcode enthält, der, wenn er durch einen Prozessor und/oder Controller verarbeitet wird, bewirkt, dass ein Verfahren nach einem der Ansprüche 1 bis 9 durchgeführt wird.</claim-text></claim>
<claim id="c-de-01-0011" num="0011">
<claim-text>Vorrichtung (1400), umfassend:<br/>
eine Blatterzeugerschaltung (103, 1300), die eine elektronische Schaltung umfasst, um:
<claim-text>von einem Zeilenpuffer (101_1 ... 101_M) eine Zeilengruppe (203) von Bilddaten zu empfangen, die mehrere Zeilen von Daten aus einem Rahmen (201) von Bilddaten einschließt, wobei die mehreren Zeilen zahlenmäßig ausreichend sind, um mehrere benachbarte überlappende Schablonen (202) zu umschließen;</claim-text>
<claim-text>die Zeilengruppe in ein Blatt kleinerer Größe (204, 205) zu parsen;</claim-text>
<claim-text>das Blatt (204, 205) in eine Datenberechnungseinheit (301, 401) eines zugeordneten Schablonenprozessors (102_1) zu laden, wobei die Datenberechnungseinheit eine zweidimensionale Verschiebe-Arraystruktur (306, 406, 602) aufweist, die mit einem Array (305, 405) von Ausführungsbahnen (510, 601) gekoppelt ist, wobei das Ausführungsbahn-Array (305, 405) und die Verschiebe-Arraystruktur (306, 406, 602) in ihrer Position relativ zueinander festgelegt sind, wobei der Schablonenprozessor die mehreren benachbarten überlappenden Schablonen (202) auf dem Blatt (204, 205) verarbeitet, wobei jede Ausführungsbahn (510, 601) dafür konfiguriert ist, ihre eigene Schablone zu verarbeiten, um einen Ausgabewert für diese Schablone zu erzeugen, und wobei die Ausgabewerte der Ausführungsbahnen jeweilige Werte in einem Ausgabeblatt von Bilddaten bilden; und</claim-text>
<claim-text>Empfangen des Ausgabeblatts aus Bilddaten von dem zugeordneten Schablonenprozessor (102_1).</claim-text></claim-text></claim>
<claim id="c-de-01-0012" num="0012">
<claim-text>Vorrichtung (1400) nach Anspruch 11, wobei die benachbarten überlappenden Schablonen (202) sich sowohl in horizontaler als auch in vertikaler Richtung erstrecken.<!-- EPO <DP n="30"> --></claim-text></claim>
<claim id="c-de-01-0013" num="0013">
<claim-text>Vorrichtung (1400) nach Anspruch 11, wobei die elektronische Schaltung ferner dazu dient:
<claim-text>Zeilengruppen (203) aus mehr als einem Kanal zu parsen;</claim-text>
<claim-text>mehr als ein Blatt (204, 205) aus dem mehr als einen Kanal zu parsen, um mindestens zwei Blätter aus unterschiedlichen Kanälen zu erzeugen;</claim-text>
<claim-text>die mindestens zwei Blätter in die Datenberechnungseinheit (301, 401) zu laden.</claim-text></claim-text></claim>
<claim id="c-de-01-0014" num="0014">
<claim-text>Vorrichtung (1400) nach Anspruch 11, wobei die elektronische Schaltung dazu dient:
<claim-text>eine Zeilengruppe (203) zu empfangen, deren Datenwerte die zweite Bitbreite aufweisen;</claim-text>
<claim-text>ein erstes und ein zweites Blatt aus der Zeilengruppe (203) zu erzeugen, wobei das erste Blatt Werte der ersten Größe aufweist und einen oberen Abschnitt der Datenwerte enthält, wobei das zweite Blatt Werte der ersten Größe aufweist und einen unteren Abschnitt der Datenwerte enthält;</claim-text>
<claim-text>das erste und das zweite Blatt in die Datenberechnungseinheit (301, 401) zu laden.</claim-text></claim-text></claim>
<claim id="c-de-01-0015" num="0015">
<claim-text>Vorrichtung (1400) nach Anspruch 11, wobei die elektronische Schaltung zu einem von Folgendem dient:
<claim-text>eine Abtastratenerhöhung durch mehrmaliges Kopieren eines Datenwerts von einer Speicherstelle der Zeilengruppe (203) über eine entsprechende Speicherstelle auf dem Blatt (204, 205) zu bewirken; und</claim-text>
<claim-text>eine Abtastratenverringerung durch Erzeugen eines zweiten Ausgabeblatts aus dem Blatt (204, 205) zu bewirken, wobei das zweite Ausgabeblatt eine Pixelwertdichte aufweist, die geringer als die Pixelwertdichte des Blatts (204, 205) ist, wobei keine Daten verloren gehen, wenn der Inhalt der Zeilengruppe (203), die auf das Blatt (204, 205) und das zweite Ausgabeblatt abgebildet wird, verglichen wird.</claim-text></claim-text></claim>
</claims>
<claims id="claims03" lang="fr"><!-- EPO <DP n="31"> -->
<claim id="c-fr-01-0001" num="0001">
<claim-text>Procédé, comprenant :
<claim-text>la réception, par un générateur de feuille (103_1) et à partir d'un tampon de ligne (101_1 ... 101_M), d'un groupe de ligne (203) de données d'images incluant plusieurs rangées de données provenant d'un cadre (201) de données d'image, lesdites plusieurs rangées étant en nombre suffisant pour comprendre plusieurs pochoirs superposés voisins (202) ;</claim-text>
<claim-text>l'analyse, par le générateur de feuille (103_1), dudit groupe de ligne (203) en une pluralité de feuilles de taille inférieure (204, 205) ; et, pour chaque feuille de la pluralité de feuilles :
<claim-text>le chargement, par le générateur de feuilles (103_1), de ladite feuille (204, 205) dans un processeur de pochoir (102-1) associé au générateur de feuille et comprenant une structure de réseau de déplacement en deux dimensions (306, 406, 602) couplé à un réseau (305, 405) de voies d'exécution (510, 601), le réseau de voie d'exécution (305, 405) et la structure de réseau de déplacement (306, 406, 602) étant fixés en position l'un par rapport à l'autre ;</claim-text>
<claim-text>l'exécution d'un code programme sur ledit réseau (305, 405) de voies d'exécution (510, 601) pour traiter lesdits plusieurs pochoirs superposés voisins (202) sur ladite feuille (204, 205), dans lequel chaque voie d'exécution (510, 601) traite son propre pochoir pour générer une valeur de sortie pour ce pochoir, et dans lequel les valeurs de sortie des voies d'exécution constituent des valeurs de pixels respectives dans une feuille de sortie de données d'image ; et</claim-text>
<claim-text>la réception, par le générateur de feuille (103_1), de la feuille de sortie de données d'image à partir du processeur de pochoir associé (102_1).</claim-text></claim-text></claim-text></claim>
<claim id="c-fr-01-0002" num="0002">
<claim-text>Procédé selon la revendication 1, dans lequel lesdits pochoirs superposés voisins (202) s'étendent dans les directions horizontale et verticale.</claim-text></claim>
<claim id="c-fr-01-0003" num="0003">
<claim-text>Procédé selon la revendication 1, comprenant en outre :
<claim-text>l'analyse de groupes de lignes (203) à partir de plus d'un canal ;</claim-text>
<claim-text>l'analyse de plus d'une feuille (204, 205) à partir de plus d'un canal pour créer au moins deux feuilles de canaux différents ;</claim-text>
<claim-text>le chargement desdites au moins deux feuilles dans ladite structure de réseau de déplacement en deux dimensions (306, 406, 602) ;</claim-text>
<claim-text>l'exécution de code programme sur ledit réseau (305, 405) de voies d'exécution (510, 601) pour traiter lesdits plusieurs pochoirs superposés voisins (202) simultanément sur lesdites au moins deux feuilles ;</claim-text>
<claim-text>dans lequel la structure de réseau de déplacement en deux dimensions (306, 406, 602) comprend une pluralité de couches, et dans lequel le chargement desdites au moins<!-- EPO <DP n="32"> --> deux couches dans ladite structure de réseau de déplacement en deux dimensions (306, 406, 602) comprend le chargement d'une première feuille présentant des données d'un premier canal du plus d'un canal dans une première couche de la pluralité de couches et le chargement d'une seconde feuille présentant des données provenant d'un second canal du plus d'un canal dans une seconde couche de la pluralité de couches.</claim-text></claim-text></claim>
<claim id="c-fr-01-0004" num="0004">
<claim-text>Procédé selon la revendication 1, comprenant en outre :
<claim-text>l'analyse d'un groupe de ligne (203) dont le cadre (201) est structuré comme un réseau présentant une caractéristique pluridimensionnelle à un emplacement de réseau du cadre (201) ;</claim-text>
<claim-text>l'analyse du groupe de ligne (203) dans plusieurs feuilles (204, 205) de sorte qu'il existe une feuille différente pour chacune des différentes dimensions de la caractéristique.</claim-text></claim-text></claim>
<claim id="c-fr-01-0005" num="0005">
<claim-text>Procédé selon la revendication 1, dans lequel le réseau de registre (306, 406, 602) contient des registres d'une première largeur binaire qui est inférieure à une seconde largeur binaire à laquelle les voies d'exécution (510, 601) sont capables de traiter des données, le procédé comprenant en outre :
<claim-text>la réception d'un groupe de ligne (203) dont les valeurs de données présentent la seconde largeur binaire ;</claim-text>
<claim-text>la création de première et seconde feuilles (204, 205) à partir du groupe de ligne, la première feuille présentant des valeurs de la première taille et contenant une partie supérieure des valeurs de données, la seconde feuille présentant des valeurs de la première taille contenant une partie inférieure des valeurs de données ;</claim-text>
<claim-text>le chargement des première et seconde feuilles dans le réseau de registre de changement (306, 406, 602) ;</claim-text>
<claim-text>le traitement simultané des première et seconde feuilles avec le réseau (305, 405) des voies d'exécution (510, 601) pour traiter les données à la seconde largeur binaire.</claim-text></claim-text></claim>
<claim id="c-fr-01-0006" num="0006">
<claim-text>Procédé selon la revendication 1, dans lequel le procédé comprend en outre une parmi :
<claim-text>la réalisation d'un échantillonnage ascendant en reproduisant une valeur de donnée d'un emplacement du groupe de ligne (203) plusieurs fois à un emplacement correspondant sur la feuille (204, 205) ; et</claim-text>
<claim-text>la réalisation d'un échantillonnage descendant en créant une seconde feuille de sortie à partir de la feuille (204, 205), la seconde feuille de sortie présentant une densité de valeurs de pixel qui est inférieure à la densité de valeurs de pixels de la feuille (204, 205), dans lequel aucune donnée n'est perdue si l'on compare le contenu du groupe de ligne (203) qui est cartographié sur la feuille (204, 205) et la seconde feuille de sortie.</claim-text></claim-text></claim>
<claim id="c-fr-01-0007" num="0007">
<claim-text>Procédé selon la revendication 1, dans lequel le procédé comprend en outre :<!-- EPO <DP n="33"> -->
<claim-text>la reconnaissance que le traitement sur les pochoirs (202) nécessite davantage de superficie d'image que la feuille (204, 205) ;</claim-text>
<claim-text>l'analyse d'au moins une feuille supplémentaire du groupe de ligne (203) qui avoisine la feuille ; et</claim-text>
<claim-text>le chargement de l'au moins une feuille supplémentaire dans un espace de stockage raccordé aux voies d'exécution (510, 601).</claim-text></claim-text></claim>
<claim id="c-fr-01-0008" num="0008">
<claim-text>Procédé selon la revendication 7, dans lequel l'espace de stockage est le réseau de déplacement en deux dimensions (306, 406, 602).</claim-text></claim>
<claim id="c-fr-01-0009" num="0009">
<claim-text>Procédé selon la revendication 1, dans lequel le procédé comprend en outre la réalisation de l'analyse en exécutant un code programme sur un processeur et/ou un système de commande (1301).</claim-text></claim>
<claim id="c-fr-01-0010" num="0010">
<claim-text>Support de stockage lisible sur une machine contenant un code programme qui, lorsqu'il est traité par un processeur et/ou un système de commande provoque la réalisation d'un procédé selon l'une quelconque des revendications 1 à 9.</claim-text></claim>
<claim id="c-fr-01-0011" num="0011">
<claim-text>Appareil (1400), comprenant :<br/>
un circuit générateur de feuille (103, 1300) comprenant un circuit électronique pour :
<claim-text>recevoir, d'un tampon de ligne (101_1... 101_M), un groupe de lignes (203) de données d'images incluant plusieurs rangées de données provenant d'un cadre (201) de données d'image, lesdites plusieurs rangées étant suffisantes en nombre pour comprendre plusieurs pochoirs superposés avoisinants (202) ;</claim-text>
<claim-text>analyser ledit groupe de ligne en une feuille de taille inférieure (204, 205) ;</claim-text>
<claim-text>charger ladite feuille (204, 205) dans une unité de calcul de données (301, 401) d'un processeur de pochoir associé (102_1), l'unité de calcul de données présentant une structure de réseau de déplacement en deux dimensions (306, 406, 602) couplée à un réseau (305, 405) de voies d'exécution (510, 601), le réseau de voies d'exécution (305, 405) et la structure de réseau de déplacement (306, 406, 602) étant fixés en position l'un par rapport à l'autre, le processeur de pochoirs traitant lesdits plusieurs pochoirs superposés avoisinants (202) sur ladite feuille (204, 205), dans lequel chaque voie d'exécution (510, 601) est configurée pour traiter son propre pochoir pour générer une valeur de sortie pour ce pochoir, et dans lequel les valeurs de sortie des voies d'exécution constituent des valeurs respectives dans une feuille de sortie de données d'image ; et</claim-text>
<claim-text>recevoir la feuille de sortie de données d'image du processeur de pochoirs associé (102_1).</claim-text></claim-text></claim>
<claim id="c-fr-01-0012" num="0012">
<claim-text>Appareil (1400) selon la revendication 11, dans lequel lesdits pochoirs superposés avoisinants (202) s'étendent à la fois dans les directions horizontale et verticale.<!-- EPO <DP n="34"> --></claim-text></claim>
<claim id="c-fr-01-0013" num="0013">
<claim-text>Appareil (1400) selon la revendication 11, dans lequel ledit circuit électronique vise en outre à :
<claim-text>analyser des groupes de ligne (203) à partir de plus d'un canal ;</claim-text>
<claim-text>analyser plus d'une feuille (204, 205) à partir de plus d'un canal pour créer au moins deux feuilles de canaux différents ;</claim-text>
<claim-text>charger lesdites au moins deux feuilles dans ladite unité de calcul de données (301, 401).</claim-text></claim-text></claim>
<claim id="c-fr-01-0014" num="0014">
<claim-text>Appareil (1400) selon la revendication 11, dans lequel le circuit électronique vise à :
<claim-text>recevoir un groupe de lignes (203) dont les valeurs de données présentent la seconde largeur binaire ;</claim-text>
<claim-text>créer des première et seconde feuilles à partir du groupe de ligne (203), la première feuille présentant des valeurs de la première taille et contenant une partie supérieure des valeurs de données, la seconde feuille présentant des valeurs de la première taille contenant une partie inférieure des valeurs de données ;</claim-text>
<claim-text>charger les première et seconde feuilles dans l'unité de calcul de données (301, 401).</claim-text></claim-text></claim>
<claim id="c-fr-01-0015" num="0015">
<claim-text>Appareil (1400) selon la revendication 11, dans lequel le circuit électronique est destiné à effectuer une opération parmi de :
<claim-text>la réalisation d'un échantillonnage ascendant en reproduisant une valeur de données à partir d'un emplacement du groupe de ligne (203) plusieurs fois à un emplacement correspondant sur la feuille (204, 205) ; et</claim-text>
<claim-text>la réalisation d'un échantillonnage descendant en créant une seconde feuille de sortie à partir de la feuille (204, 205), la seconde feuille de sortie présentant une densité de valeurs de pixels inférieure à la densité de valeurs de pixel de la feuille (204, 205), dans lequel, aucune donnée n'est perdue si l'on compare le contenu du groupe de ligne (203) qui est cartographié sur la feuille (204, 205) et la seconde feuille de sortie.</claim-text></claim-text></claim>
</claims>
<drawings id="draw" lang="en"><!-- EPO <DP n="35"> -->
<figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="165" he="183" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="36"> -->
<figure id="f0002" num="2a"><img id="if0002" file="imgf0002.tif" wi="162" he="179" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="37"> -->
<figure id="f0003" num="2b"><img id="if0003" file="imgf0003.tif" wi="163" he="110" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="38"> -->
<figure id="f0004" num="2c"><img id="if0004" file="imgf0004.tif" wi="148" he="117" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="39"> -->
<figure id="f0005" num="2d"><img id="if0005" file="imgf0005.tif" wi="148" he="118" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="40"> -->
<figure id="f0006" num="2e"><img id="if0006" file="imgf0006.tif" wi="165" he="117" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="41"> -->
<figure id="f0007" num="3a"><img id="if0007" file="imgf0007.tif" wi="161" he="213" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="42"> -->
<figure id="f0008" num="3b"><img id="if0008" file="imgf0008.tif" wi="109" he="200" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="43"> -->
<figure id="f0009" num="4"><img id="if0009" file="imgf0009.tif" wi="165" he="207" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="44"> -->
<figure id="f0010" num="5a"><img id="if0010" file="imgf0010.tif" wi="164" he="204" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="45"> -->
<figure id="f0011" num="5b"><img id="if0011" file="imgf0011.tif" wi="156" he="199" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="46"> -->
<figure id="f0012" num="5c"><img id="if0012" file="imgf0012.tif" wi="144" he="169" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="47"> -->
<figure id="f0013" num="5d"><img id="if0013" file="imgf0013.tif" wi="158" he="193" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="48"> -->
<figure id="f0014" num="5e"><img id="if0014" file="imgf0014.tif" wi="158" he="194" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="49"> -->
<figure id="f0015" num="5f"><img id="if0015" file="imgf0015.tif" wi="158" he="185" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="50"> -->
<figure id="f0016" num="5g"><img id="if0016" file="imgf0016.tif" wi="158" he="201" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="51"> -->
<figure id="f0017" num="5h"><img id="if0017" file="imgf0017.tif" wi="158" he="208" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="52"> -->
<figure id="f0018" num="5i"><img id="if0018" file="imgf0018.tif" wi="161" he="192" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="53"> -->
<figure id="f0019" num="5j"><img id="if0019" file="imgf0019.tif" wi="158" he="194" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="54"> -->
<figure id="f0020" num="5k"><img id="if0020" file="imgf0020.tif" wi="156" he="185" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="55"> -->
<figure id="f0021" num="6"><img id="if0021" file="imgf0021.tif" wi="148" he="221" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="56"> -->
<figure id="f0022" num="7"><img id="if0022" file="imgf0022.tif" wi="146" he="215" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="57"> -->
<figure id="f0023" num="8"><img id="if0023" file="imgf0023.tif" wi="144" he="191" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="58"> -->
<figure id="f0024" num="9"><img id="if0024" file="imgf0024.tif" wi="153" he="203" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="59"> -->
<figure id="f0025" num="10"><img id="if0025" file="imgf0025.tif" wi="135" he="209" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="60"> -->
<figure id="f0026" num="11"><img id="if0026" file="imgf0026.tif" wi="150" he="211" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="61"> -->
<figure id="f0027" num="12"><img id="if0027" file="imgf0027.tif" wi="151" he="107" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="62"> -->
<figure id="f0028" num="13"><img id="if0028" file="imgf0028.tif" wi="165" he="208" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="63"> -->
<figure id="f0029" num="14"><img id="if0029" file="imgf0029.tif" wi="158" he="215" img-content="drawing" img-format="tif"/></figure>
</drawings>
<ep-reference-list id="ref-list">
<heading id="ref-h0001"><b>REFERENCES CITED IN THE DESCRIPTION</b></heading>
<p id="ref-p0001" num=""><i>This list of references cited by the applicant is for the reader's convenience only. It does not form part of the European patent document. Even though great care has been taken in compiling the references, errors or omissions cannot be excluded and the EPO disclaims all liability in this regard.</i></p>
<heading id="ref-h0002"><b>Patent documents cited in the description</b></heading>
<p id="ref-p0002" num="">
<ul id="ref-ul0001" list-style="bullet">
<li><patcit id="ref-pcit0001" dnum="US2015086134A"><document-id><country>US</country><doc-number>2015086134</doc-number><kind>A</kind></document-id></patcit><crossref idref="pcit0001">[0007]</crossref></li>
<li><patcit id="ref-pcit0002" dnum="US2014164737A"><document-id><country>US</country><doc-number>2014164737</doc-number><kind>A</kind></document-id></patcit><crossref idref="pcit0002">[0008]</crossref></li>
</ul></p>
</ep-reference-list>
</ep-patent-document>
