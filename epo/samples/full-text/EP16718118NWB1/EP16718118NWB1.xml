<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE ep-patent-document PUBLIC "-//EPO//EP PATENT DOCUMENT 1.5.1//EN" "ep-patent-document-v1-5-1.dtd">
<!-- This XML data has been generated under the supervision of the European Patent Office -->
<ep-patent-document id="EP16718118B1" file="EP16718118NWB1.xml" lang="en" country="EP" doc-number="3286724" kind="B1" date-publ="20211006" status="n" dtd-version="ep-patent-document-v1-5-1">
<SDOBI lang="en"><B000><eptags><B001EP>ATBECHDEDKESFRGBGRITLILUNLSEMCPTIESILTLVFIROMKCYALTRBGCZEEHUPLSK..HRIS..MTNORS..SM..................</B001EP><B003EP>*</B003EP><B005EP>J</B005EP><B007EP>BDM Ver 2.0.12 (4th of August) -  2100000/0</B007EP></eptags></B000><B100><B110>3286724</B110><B120><B121>EUROPEAN PATENT SPECIFICATION</B121></B120><B130>B1</B130><B140><date>20211006</date></B140><B190>EP</B190></B100><B200><B210>16718118.9</B210><B220><date>20160408</date></B220><B240><B241><date>20170926</date></B241><B242><date>20191106</date></B242></B240><B250>en</B250><B251EP>en</B251EP><B260>en</B260></B200><B300><B310>201514694750</B310><B320><date>20150423</date></B320><B330><ctry>US</ctry></B330></B300><B400><B405><date>20211006</date><bnum>202140</bnum></B405><B430><date>20180228</date><bnum>201809</bnum></B430><B450><date>20211006</date><bnum>202140</bnum></B450><B452EP><date>20210706</date></B452EP></B400><B500><B510EP><classification-ipcr sequence="1"><text>G06T   1/60        20060101AFI20161102BHEP        </text></classification-ipcr></B510EP><B520EP><classifications-cpc><classification-cpc sequence="1"><text>G06F   9/30134     20130101 LI20180413BHEP        </text></classification-cpc><classification-cpc sequence="2"><text>G06F   9/3004      20130101 LI20180413BHEP        </text></classification-cpc><classification-cpc sequence="3"><text>G06F   9/30036     20130101 LI20180413BHEP        </text></classification-cpc><classification-cpc sequence="4"><text>G06F   9/30043     20130101 LI20180413BHEP        </text></classification-cpc><classification-cpc sequence="5"><text>G06T   1/60        20130101 LI20160610BHEP        </text></classification-cpc></classifications-cpc></B520EP><B540><B541>de</B541><B542>ZWEIDIMENSIONALE VERSCHIEBUNGSANORDNUNG FÜR EINEN BILDPROZESSOR</B542><B541>en</B541><B542>TWO DIMENSIONAL SHIFT ARRAY FOR IMAGE PROCESSOR</B542><B541>fr</B541><B542>RÉSEAU DE DÉCALAGE BIDIMENSIONNEL POUR PROCESSEUR D'IMAGE</B542></B540><B560><B561><text>US-A- 5 612 693</text></B561><B561><text>US-A1- 2011 153 925</text></B561><B561><text>US-A1- 2014 164 737</text></B561><B561><text>US-A1- 2015 086 134</text></B561><B562><text>CARDELLS-TORMO F ET AL: "Area-efficient 2-D shift-variant convolvers for FPGA-based digital image processing", PROC. IEEE WORKSHOP ON SIGNAL PROCESSING SYSTEM DESIGN AND IMPLEMENTATION, IEEE, 2 November 2005 (2005-11-02), pages 209-213, XP010882569, DOI: 10.1109/SIPS.2005.1579866 ISBN: 978-0-7803-9333-2</text></B562></B560></B500><B700><B720><B721><snm>SHACHAM, Ofer</snm><adr><str>1600 Amphitheatre Parkway</str><city>Mountain View, California 94043</city><ctry>US</ctry></adr></B721><B721><snm>REDGRAVE, Jason Rupert</snm><adr><str>1600 Amphitheatre Parkway</str><city>Mountain View, California 94043</city><ctry>US</ctry></adr></B721><B721><snm>MEIXNER, Albert</snm><adr><str>1600 Amphitheatre Parkway</str><city>Mountain View, California 94043</city><ctry>US</ctry></adr></B721><B721><snm>ZHU, Qiuling</snm><adr><str>1600 Amphitheatre Parkway</str><city>Mountain View, California 94043</city><ctry>US</ctry></adr></B721><B721><snm>FINCHELSTEIN, Daniel Frederic</snm><adr><str>1600 Amphitheatre Parkway</str><city>Mountain View, California 94043</city><ctry>US</ctry></adr></B721><B721><snm>PATTERSON, David</snm><adr><str>1600 Amphitheatre Parkway</str><city>Mountain View, California 94043</city><ctry>US</ctry></adr></B721><B721><snm>STARK, Donald</snm><adr><str>1600 Amphitheatre Parkway</str><city>Mountain View, California 94043</city><ctry>US</ctry></adr></B721></B720><B730><B731><snm>Google LLC</snm><iid>101696670</iid><irf>PM357705EP</irf><adr><str>1600 Amphitheatre Parkway</str><city>Mountain View, CA 94043</city><ctry>US</ctry></adr></B731></B730><B740><B741><snm>Suckling, Andrew Michael</snm><sfx>et al</sfx><iid>100037251</iid><adr><str>Marks &amp; Clerk LLP 
Fletcher House 
The Oxford Science Park 
Heatley Road</str><city>Oxford OX4 4GE</city><ctry>GB</ctry></adr></B741></B740></B700><B800><B840><ctry>AL</ctry><ctry>AT</ctry><ctry>BE</ctry><ctry>BG</ctry><ctry>CH</ctry><ctry>CY</ctry><ctry>CZ</ctry><ctry>DE</ctry><ctry>DK</ctry><ctry>EE</ctry><ctry>ES</ctry><ctry>FI</ctry><ctry>FR</ctry><ctry>GB</ctry><ctry>GR</ctry><ctry>HR</ctry><ctry>HU</ctry><ctry>IE</ctry><ctry>IS</ctry><ctry>IT</ctry><ctry>LI</ctry><ctry>LT</ctry><ctry>LU</ctry><ctry>LV</ctry><ctry>MC</ctry><ctry>MK</ctry><ctry>MT</ctry><ctry>NL</ctry><ctry>NO</ctry><ctry>PL</ctry><ctry>PT</ctry><ctry>RO</ctry><ctry>RS</ctry><ctry>SE</ctry><ctry>SI</ctry><ctry>SK</ctry><ctry>SM</ctry><ctry>TR</ctry></B840><B860><B861><dnum><anum>US2016026786</anum></dnum><date>20160408</date></B861><B862>en</B862></B860><B870><B871><dnum><pnum>WO2016171926</pnum></dnum><date>20161027</date><bnum>201643</bnum></B871></B870></B800></SDOBI>
<description id="desc" lang="en"><!-- EPO <DP n="1"> -->
<heading id="h0001"><b><u>Field of Invention</u></b></heading>
<p id="p0001" num="0001">The field of invention pertains generally to image processing, and, more specifically, to a two dimensional shift array for an image processor.</p>
<heading id="h0002"><b><u>Background</u></b></heading>
<p id="p0002" num="0002">Image processing typically involves the processing of pixel values that are organized into an array. Here, a spatially organized two dimensional array captures the two dimensional nature of images (additional dimensions may include time (e.g., a sequence of two dimensional images) and data type (e.g., colors). In a typical scenario, the arrayed pixel values are provided by a camera that has generated a still image or a sequence of frames to capture images of motion. Traditional image processors typically fall on either side of two extremes.</p>
<p id="p0003" num="0003">A first extreme performs image processing tasks as software programs executing on a general purpose processor or general purpose-like processor (e.g., a general purpose processor with vector instruction enhancements). Although the first extreme typically provides a highly versatile application software development platform, its use of finer grained data structures combined with the associated overhead (e.g., instruction fetch and decode, handling of on-chip and off-chip data, speculative execution) ultimately results in larger amounts of energy being consumed per unit of data during execution of the program code.</p>
<p id="p0004" num="0004">A second, opposite extreme applies fixed function hardwired circuitry to much larger blocks of data. The use of larger (as opposed to finer grained) blocks of data applied directly to custom designed circuits greatly reduces power consumption per unit of data. However, the use of custom designed fixed function circuitry generally results in a limited set of tasks that the processor is able to perform. As such, the widely versatile programming environment (that is associated with the first extreme) is lacking in the second extreme.</p>
<p id="p0005" num="0005">The paper titled "<nplcit id="ncit0001" npl-type="s"><text>Area-Efficient 2-D Shift-Variant Convolvers for FPGA-based Digital Image Processing" by Cardells-Tormo et al. published in the "Proceedings of the IEEE Workshop on Signal Processing System Design and Implementation, 2 November 2005</text></nplcit>" proposes several FPGA architectures for generating a moving window over a row-wise print path and criteria for choosing the optimum one for any design point. According to one proposed<!-- EPO <DP n="2"> --> architecture, data is read from an external memory, stored in a local memory and then transferred to a shift register.</p>
<p id="p0006" num="0006"><patcit id="pcit0001" dnum="US5612693A"><text>US 5,612,693</text></patcit> discloses a method for compressing data. Lempel-Ziv data compression is applied in the context of an exhaustive sliding window implementation using a large character history bit pattern memory. Shifted updating of the character history bit pattern memory is accomplished through a pointer system. Linear patterns of bits, derived by COPY function from the character history bit pattern memory or by bit wise AND logic combination of selected bit patterns, are circularly shifted in synchronism with new data characters using a toroidal bit shift register. The relatively long bit strings subject to shifting are converted to a matrix format, shifted with fewer affected bits and returned to a linear format.</p>
<p id="p0007" num="0007"><patcit id="pcit0002" dnum="US20110153925A1"><text>US 2011/0153925 A1 </text></patcit>discloses a memory controller that can determine a swizzling pattern between the memory controller and memory devices. The memory controller generates a swizzling map based on the determined swizzling pattern. The memory controller may internally swizzle data using the swizzling map before writing the data to memory so that the data appears in the correct order at the pins of the memory chip(s). On reads, the controller can internally de-swizzle the data before performing the error correction operations using the swizzling map.</p>
<p id="p0008" num="0008"><patcit id="pcit0003" dnum="US2015086134A"><text>US 2015/086134</text></patcit> proposes a convolution image processor includes a load and store unit, a shift register unit, and a mapping unit. The load and store unit is configured to load and store image pixel data and allow for unaligned access of the image pixel data. The shift register is configured to load and store at least a portion of the image pixel data from the load and store unit and concurrently provide access to each image pixel value in the portion of the image pixel data. The mapping unit is configured to generate a number of shifted versions of image pixel data and corresponding stencil data from the portion of the image pixel data, and concurrently perform one or more operations on each image pixel value in the shifted versions of the portion of the image pixel data and a corresponding stencil value in the corresponding stencil data.</p>
<p id="p0009" num="0009"><patcit id="pcit0004" dnum="US2014164737A"><text>US 2014/164737</text></patcit> proposes a method for executing instructions on a single-program, multiple-data processor system having a fixed number of execution lanes→→, including: scheduling a primary instruction for execution with a first wave of multiple data; assigning the first wave to a corresponding primary subset of the execution lanes; scheduling a secondary instruction having a second wave of multiple data, such that the second wave fits in lanes that are unused by the primary subset of lanes; assigning the second wave to a corresponding<!-- EPO <DP n="3"> --> secondary subset of the lanes; fetching the primary and secondary instructions; configuring the execution lanes such that the primary subset is responsive to the primary instruction and the secondary subset is simultaneously responsive to the secondary instruction; and simultaneously executing the primary and secondary instructions in the execution lanes.</p>
<p id="p0010" num="0010">A technology platform that provides for both highly versatile application software development opportunities combined with improved power efficiency per unit of data remains a desirable yet missing solution.</p>
<heading id="h0003"><u>Summary</u></heading>
<p id="p0011" num="0011">The present invention provides an apparatus according to claim 1; a method according to claim 9; and a machine readable medium according to claim 12.</p>
<p id="p0012" num="0012">According to a further aspect of the present disclosure, an apparatus is described. The apparatus includes means for shifting, in a same direction and number of locations, data from multiple contiguous locations within a two-dimensional shift register array structure to provide each of multiple different execution lanes within an execution lane array a new value within respective dedicated registers of the multiple different execution lanes. The different execution lanes are coupled to their respective dedicated registers at same respective locations of the execution lane array and the two-dimensional shift register array.<!-- EPO <DP n="4"> --></p>
<p id="p0013" num="0013">According to yet another aspect of the present disclosure, an apparatus is described. The apparatus includes an execution lane array coupled to a two dimensional shift register array structure. Locations in the execution lane array are coupled to same locations in the two-dimensional shift register array structure such that different execution lanes have different dedicated registers.</p>
<heading id="h0004"><b><u>List of Figures</u></b></heading>
<p id="p0014" num="0014">The following description and accompanying drawings are used to illustrate embodiments of the invention. In the drawings:
<ul id="ul0001" list-style="none" compact="compact">
<li><figref idref="f0001">Fig. 1</figref> shows an image processor hardware architecture;</li>
<li><figref idref="f0002">Figs. 2a</figref>, <figref idref="f0003">2b</figref>, <figref idref="f0004">2c</figref>, <figref idref="f0005">2d</figref> and <figref idref="f0006">2e</figref> depict the parsing of image data into a line group, the parsing of a line group into a sheet and the operation performed on a sheet with overlapping stencils;</li>
<li><figref idref="f0007">Fig. 3</figref> shows a stencil processor;</li>
<li><figref idref="f0008">Fig. 4</figref> shows a data computation unit within a stencil processor;</li>
<li><figref idref="f0009">Figs. 5a</figref>, <figref idref="f0010">5b</figref>, <figref idref="f0011">5c</figref>, <figref idref="f0012">5d</figref>, <figref idref="f0013">5e</figref>, <figref idref="f0014">5f</figref>, <figref idref="f0015">5g</figref>, <figref idref="f0016">5h</figref>, <figref idref="f0017">5i</figref>, <figref idref="f0018">5j</figref> and <figref idref="f0019">5k</figref> depict an example of the use of a two-dimensional shift array and an execution lane array to determine a pair of neighboring output pixel values with overlapping stencils;</li>
<li><figref idref="f0020">Fig. 6</figref> shows an embodiment of a unit cell for an integrated execution lane array and two-dimensional shift array;</li>
<li><figref idref="f0021">Fig. 7a</figref> depicts a first two dimensional register array structure interconnection scheme;</li>
<li><figref idref="f0022">Fig. 7b</figref> depicts a second two dimensional register array structure interconnection scheme;</li>
<li><figref idref="f0023">Fig. 8a</figref> depicts a first row or column of a two-dimensional register array structure;</li>
<li><figref idref="f0023">Fig. 8b</figref> depicts a second row or column of a two-dimensional register array structure;</li>
<li><figref idref="f0024">Fig. 8c</figref> depicts the row of <figref idref="f0023">Fig. 8b</figref> coupled to a memory unit;</li>
<li><figref idref="f0025">Fig. 8d</figref> shows a toroid structure for a register array structure;</li>
<li><figref idref="f0026">Fig. 8e</figref> shows a power conservation circuit;</li>
<li><figref idref="f0027">Fig. 9</figref> shows a computing system.</li>
</ul><!-- EPO <DP n="5"> --></p>
<heading id="h0005"><b><u>Detailed Description</u></b></heading>
<heading id="h0006"><i><u>a. image processor hardware architecture and operation</u></i></heading>
<p id="p0015" num="0015"><figref idref="f0001">Fig. 1</figref> shows an architecture 100 for an image processor implemented in hardware. The image processor may be targeted, for example, by a compiler that converts program code written for a virtual processor within a simulated environment into program code that is actually executed by the hardware processor. As observed in <figref idref="f0001">Fig. 1</figref>, the architecture 100 includes a plurality of line buffer units 101_1 through 101_M interconnected to a plurality of stencil processor units 102_1 through 102_N and corresponding sheet generator units 103_1 through 103_N through a network 104 (e.g., a network on chip (NOC) including an on chip switch network, an on chip ring network or other kind of network). In an example, any line buffer unit may connect to any sheet generator and corresponding stencil processor through the network 104.</p>
<p id="p0016" num="0016">Program code is compiled and loaded onto a corresponding stencil processor 102 to perform the image processing operations earlier defined by a software developer (program code may also be loaded onto the stencil processor's associated sheet generator 103, e.g., depending on design and implementation). In at least some instances an image processing pipeline may be realized by loading a first kernel program for a first pipeline stage into a first stencil processor 102_1, loading a second kernel program for a second pipeline stage into a second stencil processor 102_2, etc. where the first kernel performs the functions of the first stage of the pipeline, the second kernel performs the functions of the second stage of the pipeline, etc. and additional control flow methods are installed to pass output image data from one stage of the pipeline to the next stage of the pipeline.</p>
<p id="p0017" num="0017">In other configurations, the image processor may be realized as a parallel machine having two or more stencil processors 102_1, 102_2 operating the same kernel program code. For example, a highly dense and high data rate stream of image data may be processed by spreading frames across multiple stencil processors each of which perform the same function.</p>
<p id="p0018" num="0018">In yet other configurations, essentially any DAG of kernels may be loaded onto the hardware processor by configuring respective stencil processors with their own respective kernel<!-- EPO <DP n="6"> --> of program code and configuring appropriate control flow hooks into the hardware to direct output images from one kernel to the input of a next kernel in the DAG design.</p>
<p id="p0019" num="0019">As a general flow, frames of image data are received by a macro I/O unit 105 and passed to one or more of the line buffer units 101 on a frame by frame basis. A particular line buffer unit parses its frame of image data into a smaller region of image data, referred to as a "a line group", and then passes the line group through the network 104 to a particular sheet generator. A complete or "full" singular line group may be composed, for example, with the data of multiple contiguous complete rows or columns of a frame (for simplicity the present specification will mainly refer to contiguous rows). The sheet generator further parses the line group of image data into a smaller region of image data, referred to as a "sheet", and presents the sheet to its corresponding stencil processor.</p>
<p id="p0020" num="0020">In the case of an image processing pipeline or a DAG flow having a single input, generally, input frames are directed to the same line buffer unit 101_1 which parses the image data into line groups and directs the line groups to the sheet generator 103_1 whose corresponding stencil processor 102_1 is executing the code of the first kernel in the pipeline/DAG. Upon completion of operations by the stencil processor 102_1 on the line groups it processes, the sheet generator 103_1 sends output line groups to a "downstream" line buffer unit 101_2 (in some use cases the output line group may be sent back to the same line buffer unit 101_1 that earlier had sent the input line groups).</p>
<p id="p0021" num="0021">One or more "consumer" kernels that represent the next stage/operation in the pipeline/DAG executing on their own respective other sheet generator and stencil processor (e.g., sheet generator 103_2 and stencil processor 102_2) then receive from the downstream line buffer unit 101_2 the image data generated by the first stencil processor 102_1. In this manner, a "producer" kernel operating on a first stencil processor has its output data forwarded to a "consumer" kernel operating on a second stencil processor where the consumer kernel performs the next set of tasks after the producer kernel consistent with the design of the overall pipeline or DAG.</p>
<p id="p0022" num="0022">A stencil processor 102 is designed to simultaneously operate on multiple overlapping stencils of image data. The multiple overlapping stencils and internal hardware processing capacity of the stencil processor effectively determines the size of a sheet. Here, within a stencil<!-- EPO <DP n="7"> --> processor 102, arrays of execution lanes operate in unison to simultaneously process the image data surface area covered by the multiple overlapping stencils.</p>
<p id="p0023" num="0023">As will be described in more detail below, sheets of image data are loaded into a two-dimensional register array structure within the stencil processor 102. The use of sheets and the two-dimensional register array structure is believed to effectively provide for power consumption improvements by moving a large amount of data into a large amount of register space as, e.g., a single load operation with processing tasks performed directly on the data immediately thereafter by an execution lane array. Additionally, the use of an execution lane array and corresponding register array provide for different stencil sizes that are easily programmable/configurable.</p>
<p id="p0024" num="0024"><figref idref="f0002 f0003 f0004 f0005 f0006">Figs. 2a through 2e</figref> illustrate at a high level examples of both the parsing activity of a line buffer unit 101, the finer grained parsing activity of a sheet generator unit 103 as well as the stencil processing activity of the stencil processor 102 that is coupled to the sheet generator unit 103.</p>
<p id="p0025" num="0025"><figref idref="f0002">Fig. 2a</figref> depicts an example of an input frame of image data 201. <figref idref="f0002">Fig. 2a</figref> also depicts an outline of three overlapping stencils 202 (each having a dimension of 3 pixels x 3 pixels) that a stencil processor is designed to operate over. The output pixel that each stencil respectively generates output image data for is highlighted in solid black. For simplicity, the three overlapping stencils 202 are depicted as overlapping only in the vertical direction. It is pertinent to recognize that in actuality a stencil processor may be designed to have overlapping stencils in both the vertical and horizontal directions.</p>
<p id="p0026" num="0026">Because of the vertical overlapping stencils 202 within the stencil processor, as observed in <figref idref="f0002">Fig. 2a</figref>, there exists a wide band of image data within the frame that a single stencil processor can operate over. As will be discussed in more detail below, in an example, the stencil processors process data within their overlapping stencils in a left to right fashion across the image data (and then repeat for the next set of lines, in top to bottom order). Thus, as the stencil processors continue forward with their operation, the number of solid black output pixel blocks will grow right-wise horizontally. As discussed above, a line buffer unit 101 is responsible for parsing a line group of input image data from an incoming frame that is sufficient for the stencil processors to operate over for an extended number of upcoming cycles. An exemplary depiction of a line group is illustrated as a shaded region 203. In an example, the<!-- EPO <DP n="8"> --> line buffer unit 101 can comprehend different dynamics for sending/receiving a line group to/from a sheet generator. For example, according to one mode, referred to as "full group", the complete full width lines of image data are passed between a line buffer unit and a sheet generator. According to a second mode, referred to as "virtually tall", a line group is passed initially with a subset of full width rows. The remaining rows are then passed sequentially in smaller (less than full width) pieces.</p>
<p id="p0027" num="0027">With the line group 203 of the input image data having been defined by the line buffer unit and passed to the sheet generator unit, the sheet generator unit further parses the line group into finer sheets that are more precisely fitted to the hardware limitations of the stencil processor. More specifically, as will be described in more detail further below, in an example, each stencil processor consists of a two dimensional shift register array. The two dimensional shift register array essentially shifts image data "beneath" an array of execution lanes where the pattern of the shifting causes each execution lane to operate on data within its own respective stencil (that is, each execution lane processes on its own stencil of information to generate an output for that stencil). In an example, sheets are surface areas of input image data that "fill" or are otherwise loaded into the two dimensional shift register array.</p>
<p id="p0028" num="0028">As will be described in more detail below, in various embodiments, there are actually multiple layers of two dimensional register data that can be shifted on any cycle. For convenience, much of the present description will simply use the term "two-dimensional shift register" and the like to refer to structures that have one or more such layers of two-dimensional register data that can be shifted.</p>
<p id="p0029" num="0029">Thus, as observed in <figref idref="f0003">Fig. 2b</figref>, the sheet generator parses an initial sheet 204 from the line group 203 and provides it to the stencil processor (here, the sheet of data corresponds to the shaded region that is generally identified by reference number 204). As observed in <figref idref="f0004">Figs. 2c</figref> and <figref idref="f0005">2d</figref>, the stencil processor operates on the sheet of input image data by effectively moving the overlapping stencils 202 in a left to right fashion over the sheet. As of <figref idref="f0005">Fig. 2d</figref>, the number of pixels for which an output value could be calculated from the data within the sheet is exhausted (no other pixel positions can have an output value determined from the information within the sheet). For simplicity the border regions of the image have been ignored.</p>
<p id="p0030" num="0030">As observed in <figref idref="f0006">Fig. 2e</figref> the sheet generator then provides a next sheet 205 for the stencil processor to continue operations on. Note that the initial positions of the stencils as they<!-- EPO <DP n="9"> --> begin operation on the next sheet is the next progression to the right from the point of exhaustion on the first sheet (as depicted previously in <figref idref="f0005">Fig. 2d</figref>). With the new sheet 205, the stencils will simply continue moving to the right as the stencil processor operates on the new sheet in the same manner as with the processing of the first sheet.</p>
<p id="p0031" num="0031">Note that there is some overlap between the data of the first sheet 204 and the data of the second sheet 205 owing to the border regions of stencils that surround an output pixel location. The overlap could be handled simply by the sheet generator re-transmitting the overlapping data twice. In alternate implementations, to feed a next sheet to the stencil processor, the sheet generator may proceed to only send new data to the stencil processor and the stencil processor reuses the overlapping data from the previous sheet.</p>
<heading id="h0007"><i><u>b. stencil processor design and operation</u></i></heading>
<p id="p0032" num="0032"><figref idref="f0007">Fig. 3</figref> shows a stencil processor architecture 300. As observed in <figref idref="f0007">Fig. 3</figref>, the stencil processor includes a data computation unit 301, a scalar processor 302 and associated memory 303 and an I/O unit 304. The data computation unit 301 includes an array of execution lanes 305, a two-dimensional shift array structure 306 and separate random access memories 307 associated with specific rows or columns of the array.</p>
<p id="p0033" num="0033">The I/O unit 304 is responsible for loading "input" sheets of data received from the sheet generator into the data computation unit 301 and storing "output" sheets of data from the stencil processor into the sheet generator. In an example the loading of sheet data into the data computation unit 301 entails parsing a received sheet into rows/columns of image data and loading the rows/columns of image data into the two dimensional shift register structure 306 or respective random access memories 307 of the rows/columns of the execution lane array (described in more detail below). If the sheet is initially loaded into memories 307, the individual execution lanes within the execution lane array 305 may then load sheet data into the two-dimensional shift register structure 306 from the random access memories 307 when appropriate (e.g., as a load instruction just prior to operation on the sheet's data). Upon completion of the loading of a sheet of data into the register structure 306 (whether directly from a sheet generator or from memories 307), the execution lanes of the execution lane array 305 operate on the data and eventually "write back" finished data as a sheet directly back to the sheet generator, or, into the random access memories 307. If the later the I/O unit 304 fetches the data<!-- EPO <DP n="10"> --> from the random access memories 307 to form an output sheet which is then forwarded to the sheet generator.</p>
<p id="p0034" num="0034">The scalar processor 302 includes a program controller 309 that reads the instructions of the stencil processor's program code from scalar memory 303 and issues the instructions to the execution lanes in the execution lane array 305. In an example, a single same instruction is broadcast to all execution lanes within the array 305 to effect a SIMD-like behavior from the data computation unit 301. In an example, the instruction format of the instructions read from scalar memory 303 and issued to the execution lanes of the execution lane array 305 includes a very-long-instruction-word (VLIW) type format that includes more than one opcode per instruction. In a further example, the VLIW format includes both an ALU opcode that directs a mathematical function performed by each execution lane's ALU (which, as described below, in an example may specify more than one traditional ALU operation) and a memory opcode (that directs a memory operation for a specific execution lane or set of execution lanes).</p>
<p id="p0035" num="0035">The term "execution lane" refers to a set of one or more execution units capable of executing an instruction (e.g., logic circuitry that can execute an instruction). An execution lane can, in various examples, include more processor-like functionality beyond just execution units, however. For example, besides one or more execution units, an execution lane may also include logic circuitry that decodes a received instruction, or, in the case of more MIMD-like designs, logic circuitry that fetches and decodes an instruction. With respect to MIMD-like approaches, although a centralized program control approach has largely been described herein, a more distributed approach may be implemented in various alternative examples (e.g., including program code and a program controller within each execution lane of the array 305).</p>
<p id="p0036" num="0036">The combination of an execution lane array 305, program controller 309 and two dimensional shift register structure 306 provides a widely adaptable/configurable hardware platform for a broad range of programmable functions. For example, application software developers are able to program kernels having a wide range of different functional capability as well as dimension (e.g., stencil size) given that the individual execution lanes are able to perform a wide variety of functions and are able to readily access input image data proximate to any output array location.</p>
<p id="p0037" num="0037">Apart from acting as a data store for image data being operated on by the execution lane array 305, the random access memories 307 may also keep one or more look-up tables. In<!-- EPO <DP n="11"> --> various examples one or more scalar look-up tables may also be instantiated within the scalar memory 303.</p>
<p id="p0038" num="0038">A scalar look-up involves passing the same data value from the same look-up table from the same index to each of the execution lanes within the execution lane array 305. In various examples, the VLIW instruction format described above is expanded to also include a scalar opcode that directs a look-up operation performed by the scalar processor into a scalar look-up table. The index that is specified for use with the opcode may be an immediate operand or fetched from some other data storage location. Regardless, in an example, a look-up from a scalar look-up table within scalar memory essentially involves broadcasting the same data value to all execution lanes within the execution lane array 305 during the same clock cycle. Additional details concerning use and operation of look-up tables is provided further below.</p>
<p id="p0039" num="0039"><figref idref="f0008">Fig. 4</figref> shows a data computation component 401. As observed in <figref idref="f0008">Fig. 4</figref>, the data computation component 401 includes an array of execution lanes 405 that are logically positioned "above" a two-dimensional shift register array structure 406. As discussed above, in various examples, a sheet of image data provided by a sheet generator is loaded into the two-dimensional shift register 406. The execution lanes then operate on the sheet data from the register structure 406.</p>
<p id="p0040" num="0040">The execution lane array 405 and shift register structure 406 are fixed in position relative to one another. However, the data within the shift register array 406 shifts in a strategic and coordinated fashion to cause each execution lane in the execution lane array to process a different stencil within the data. As such, each execution lane determines the output image value for a different pixel in the output sheet being generated. From the architecture of <figref idref="f0008">Fig. 4</figref> it should be clear that overlapping stencils are not only arranged vertically but also horizontally as the execution lane array 405 includes vertically adjacent execution lanes as well as horizontally adjacent execution lanes.</p>
<p id="p0041" num="0041">Some notable architectural features of the data computation unit 401 include the shift register structure 406 having wider dimensions than the execution lane array 405. That is, there is a "halo" of registers 409 outside the execution lane array 405. Although the halo 409 is shown to exist on two sides of the execution lane array, depending on implementation, the halo may exist on less (one) or more (three or four) sides of the execution lane array 405. The halo 405 serves to provide "spill-over" space for data that spills outside the bounds of the execution lane<!-- EPO <DP n="12"> --> array 405 as the data is shifting "beneath" the execution lanes 405. As a simple case, a 5x5 stencil centered on the right edge of the execution lane array 405 will need four halo register locations further to the right when the stencil's leftmost pixels are processed. For ease of drawing, <figref idref="f0008">Fig. 4</figref> shows the registers of the right side of the halo as only having horizontal shift connections and registers of the bottom side of the halo as only having vertical shift connections when, in a nominal example, registers on either side (right, bottom) would have both horizontal and vertical connections.</p>
<p id="p0042" num="0042">Additional spill-over room is provided by random access memories 407 that are coupled to each row and/or each column in the array, or portions thereof (E.g., a random access memory may be assigned to a "region" of the execution lane array that spans 4 execution lanes row wise and 2 execution lanes column wise. For simplicity the remainder of the application will refer mainly to row and/or column based allocation schemes). Here, if an execution lane's kernel operations require it to process pixel values outside of the two-dimensional shift register array 406 (which some image processing routines may require) the plane of image data is able to further spill-over, e.g., from the halo region 409 into random access memory 407. For example, consider a 6X6 stencil where the hardware includes a halo region of only four storage elements to the right of an execution lane on the right edge of the execution lane array. In this case, the data would need to be shifted further to the right off the right edge of the halo 409 to fully process the stencil. Data that is shifted outside the halo region 409 would then spill-over to random access memory 407. Other applications of the random access memories 407 and the stencil processor of <figref idref="f0007">Fig. 3</figref> are provided further below.</p>
<p id="p0043" num="0043"><figref idref="f0009 f0010 f0011 f0012 f0013 f0014 f0015 f0016 f0017 f0018 f0019">Figs. 5a through 5k</figref> demonstrate a working example of the manner in which image data is shifted within the two dimensional shift register array "beneath" the execution lane array as alluded to above. As observed in <figref idref="f0009">Fig. 5a</figref>, the data contents of the two dimensional shift array are depicted in a first array 507 and the execution lane array is depicted by a frame 505. Also, two neighboring execution lanes 510 within the execution lane array are simplistically depicted. In this simplistic depiction 510, each execution lane includes a register R1 that can accept data from the shift register, accept data from an ALU output (e.g., to behave as an accumulator across cycles), or write output data into an output destination.</p>
<p id="p0044" num="0044">Each execution lane also has available, in a local register R2, the contents "beneath" it in the two dimensional shift array. Thus, R1 is a physical register of the execution lane while R2<!-- EPO <DP n="13"> --> is a physical register of the two dimensional shift register array. The execution lane includes an ALU that can operate on operands provided by R1 and/or R2. As will be described in more detail further below, in an embodiment the shift register is actually implemented with multiple (a "depth" of) storage/register elements per array location but the shifting activity is limited to one plane of storage elements (e.g., only one plane of storage elements can shift per cycle). <figref idref="f0009 f0010 f0011 f0012 f0013 f0014 f0015 f0016 f0017 f0018 f0019">Figs. 5a through 5k</figref> depict one of these deeper register locations as being used to store the resultant X from the respective execution lanes. For illustrative ease the deeper resultant register is drawn alongside rather than beneath its counterpart register R2.</p>
<p id="p0045" num="0045"><figref idref="f0009 f0010 f0011 f0012 f0013 f0014 f0015 f0016 f0017 f0018 f0019">Figs. 5a through 5k</figref> focus on the calculation of two stencils whose central position is aligned with the pair of execution lane positions 511 depicted within the execution lane array. For ease of illustration, the pair of execution lanes 510 are drawn as horizontal neighbors when in fact, according to the following example, they are vertical neighbors.</p>
<p id="p0046" num="0046">As observed initially in <figref idref="f0009">Fig. 5a</figref>, the execution lanes are centered on their central stencil locations. <figref idref="f0010">Fig. 5b</figref> shows the object code executed by both execution lanes. As observed in <figref idref="f0010">Fig. 5b</figref> the program code of both execution lanes causes the data within the shift register array to shift down one position and shift right one position. This aligns both execution lanes to the upper left hand corner of their respective stencils. The program code then causes the data that is located (in R2) in their respective locations to be loaded into R1.</p>
<p id="p0047" num="0047">As observed in <figref idref="f0011">Fig. 5c</figref> the program code next causes the pair of execution lanes to shift the data within the shift register array one unit to the left which causes the value to the right of each execution lane's respective position to be shifted into each execution lane' position. The value in R1 (previous value) is then added with the new value that has shifted into the execution lane's position (in R2). The resultant is written into R1. As observed in <figref idref="f0012">Fig. 5d</figref> the same process as described above for <figref idref="f0011">Fig. 5c</figref> is repeated which causes the resultant R1 to now include the value A+B+C in the upper execution lane and F+G+H in the lower execution lane. At this point both execution lanes have processed the upper row of their respective stencils. Note the spill-over into a halo region on the left side of the execution lane array (if one exists on the left hand side) or into random access memory if a halo region does not exist on the left hand side of the execution lane array.</p>
<p id="p0048" num="0048">As observed in <figref idref="f0013">Fig. 5e</figref>, the program code next causes the data within the shift register array to shift one unit up which causes both execution lanes to be aligned with the right edge of<!-- EPO <DP n="14"> --> the middle row of their respective stencils. Register R1 of both execution lanes currently includes the summation of the stencil's top row and the middle row's rightmost value. <figref idref="f0014">Figs. 5f</figref> and <figref idref="f0015">5g</figref> demonstrate continued progress moving leftwise across the middle row of both execution lane's stencils. The accumulative addition continues such that at the end of processing of <figref idref="f0015">Fig. 5g</figref> both execution lanes include the summation of the values of the top row and the middle row of their respective stencils.</p>
<p id="p0049" num="0049"><figref idref="f0016">Fig. 5h</figref> shows another shift to align each execution lane with its corresponding stencil's lowest row. <figref idref="f0017">Figs. 5i</figref> and <figref idref="f0018">5j</figref> show continued shifting to complete processing over the course of both execution lanes' stencils. <figref idref="f0019">Fig. 5k</figref> shows additional shifting to align each execution lane with its correct position in the data array and write the resultant thereto.</p>
<p id="p0050" num="0050">In the example of <figref idref="f0009 f0010 f0011 f0012 f0013 f0014 f0015 f0016 f0017 f0018 f0019">Figs 5a-5k</figref> note that the object code for the shift operations may include an instruction format that identifies the direction and magnitude of the shift expressed in (X, Y) coordinates. For example, the object code for a shift up by one location may be expressed in object code as SHIFT 0, +1. As another example, a shift to the right by one location may expressed in object code as SHIFT +1, 0. In various embodiments shifts of larger magnitude may also be specified in object code (e.g., SHIFT 0, +2). Here, if the 2D shift register hardware only supports shifts by one location per cycle, the instruction may be interpreted by the machine to require multiple cycle execution, or, the 2D shift register hardware may be designed to support shifts by more than one location per cycle. Embodiments of the later are described in more detail further below.</p>
<p id="p0051" num="0051"><figref idref="f0020">Fig.6</figref> shows another, more detailed depiction of the unit cell for the array execution lane and shift register structure (registers in the halo region do not include a corresponding execution lane). The execution lane and the register space associated with each location in the execution lane array is, in an embodiment, implemented by instantiating the circuitry observed in <figref idref="f0020">Fig.6</figref> at each node of the execution lane array. As observed in <figref idref="f0020">Fig.6</figref>, the unit cell includes an execution lane 601 coupled to a register file 602 consisting of four registers R2 through R5. During any cycle, the execution lane 601 may read from or write to any of registers R1 through R5. For instructions requiring two input operands the execution lane may retrieve both of operands from any of R1 through R5.</p>
<p id="p0052" num="0052">In an embodiment, the two dimensional shift register structure is implemented by permitting, during a single cycle, the contents of any of (only) one of registers R2 through R4 to<!-- EPO <DP n="15"> --> be shifted "out" to one of its neighbor's register files through output multiplexer 603, and, having the contents of any of (only) one of registers R2 through R4 replaced with content that is shifted "in" from a corresponding one if its neighbors through input multiplexers 604 such that shifts between neighbors are in a same direction (e.g., all execution lanes shift left, all execution lanes shift right, etc.). Although it may be common for a same register to have its contents shifted out and replaced with content that is shifted in on a same cycle, the multiplexer arrangement 603, 604 permits for different shift source and shift target registers within a same register file during a same cycle.</p>
<p id="p0053" num="0053">As depicted in <figref idref="f0020">Fig.6</figref> note that during a shift sequence an execution lane will shift content out from its register file 602 to each of its left, right, top and bottom neighbors. In conjunction with the same shift sequence, the execution lane will also shift content into its register file from a particular one of its left, right, top and bottom neighbors. Again, the shift out target and shift in source should be consistent with a same shift direction for all execution lanes (e.g., if the shift out is to the right neighbor, the shift in should be from the left neighbor).</p>
<p id="p0054" num="0054">Although in one embodiment the content of only one register is permitted to be shifted per execution lane per cycle, other embodiments may permit the content of more than one register to be shifted in/out. For example, the content of two registers may be shifted out/in during a same cycle if a second instance of the multiplexer circuitry 603, 604 observed in <figref idref="f0020">Fig.6</figref> is incorporated into the design of <figref idref="f0020">Fig.6</figref>. Of course, in embodiments where the content of only one register is permitted to be shifted per cycle, shifts from multiple registers may take place between mathematical operations by consuming more clock cycles for shifts between mathematical operations (e.g., the contents of two registers may be shifted between math ops by consuming two shift ops between the math ops).</p>
<p id="p0055" num="0055">If less than all the content of an execution lane's register files are shifted out during a shift sequence note that the content of the non shifted out registers of each execution lane remain in place (do not shift). As such, any non shifted content that is not replaced with shifted in content persists local to the execution lane across the shifting cycle. The memory unit ("M") observed in each execution lane is used to load/store data from/to the random access memory space that is associated with the execution lane's row and/or column within the execution lane array. Here, the M unit acts as a standard M unit in that it is often used to load/store data that cannot be loaded/stored from/to the execution lane's own register space. In various<!-- EPO <DP n="16"> --> embodiments, the primary operation of the M unit is to write data from a local register into memory, and, read data from memory and write it into a local register.</p>
<p id="p0056" num="0056">With respect to the ISA opcodes supported by the ALU unit of the hardware execution lane 601, in various embodiments, the mathematical opcodes supported by the hardware ALU are integrally tied with (e.g., substantially the same as) the mathematical opcodes supported by a virtual execution lane (e.g., ADD, SUB, MOV, MUL, MAD, ABS, DIV, SHL, SHR, MIN/MAX, SEL, AND, OR, XOR, NOT). As described just above, memory access instructions can be executed by the execution lane 601 to fetch/store data from/to their associated random access memory. Additionally the hardware execution lane 601 supports shift op instructions (right, left, up, down) to shift data within the two dimensional shift register structure. As described above, program control instructions are largely executed by the scalar processor of the stencil processor.</p>
<p id="p0057" num="0057"><figref idref="f0021">Fig. 7a</figref> depicts an embodiment of a "top down" view of the logical (and potentially physical) design of a two-dimensional register array structure. The "top-down" view of <figref idref="f0021">Fig. 7a</figref> essentially conforms to the unit cell design embodiment of <figref idref="f0020">Fig. 6</figref> in which each register file at a particular array location is coupled to the register file of its left, right, up and down neighboring unit cell location. That is, for example, as seen in <figref idref="f0021">Fig. 7a</figref>, register file A is coupled to register files B, C, D and E.</p>
<p id="p0058" num="0058"><figref idref="f0022">Fig. 7b</figref> depicts another embodiment of a "top-down" view of the logical (and potentially physical) design of a two-dimensional register array structure. As observed in <figref idref="f0022">Fig. 7b</figref>, unit cells are not only coupled to nearest vertical and horizontal neighbors, but also "second" nearest vertical and horizontal neighbors. For example, as observed in <figref idref="f0022">Fig. 7b</figref>, unit cell A is not only coupled to unit cells B, C, D and E but is also coupled to unit cells F, G, H and I. For ease of drawing and viewing, only unit cell A is depicted as having the full set of connections needed to have both nearest and second nearest neighbor coupling. Other than unit cell A, only every other unit cell shows second nearest neighbor coupling along any particular row or column (e.g., unit cell B does not depict any second nearest neighbor coupling). The reader will understand that a preferred embodiment would include the coupling of unit cell A for, e.g., all the unit cells within the core and sufficiently away from array edges to support second nearest neighbor coupling.<!-- EPO <DP n="17"> --></p>
<p id="p0059" num="0059">Having second nearest connection provides for faster propagation of the register values through the register array. For example, if a register value needs to be moved to a unit cell four locations away, the array structure of <figref idref="f0022">Fig. 7b</figref> can accomplish the move in two cycles whereas the array structure of <figref idref="f0022">Fig. 7b</figref> can accomplish the same move in only four cycles. Note that the embodiment of <figref idref="f0022">Fig. 7b</figref> also has nearest neighbor connections. Thus, the execution lane instruction set for the structure of <figref idref="f0022">Fig. 7b</figref> may be more expansive than the execution lane instruction set for the structure of <figref idref="f0021">Fig. 7a</figref> (the former having one-hop and two-hop MOV instructions whereas the lat<u>t</u>er only has one-hop MOV instructions).</p>
<p id="p0060" num="0060">It is pertinent to point out that the number and combination of different numbered hop movements and corresponding array structure embodiments may widely vary from embodiment to embodiment depending on the appropriate trade off balance between the need for rapid register value movement and the tolerance for array structure wiring density. Some embodiments may support nearest third or and/or fourth neighbor connections, others may not (in the case of nearest fourth neighbor connections, e.g., unit cell D would be directly coupled to unit cell J in <figref idref="f0022">Fig. 7b</figref>). Some embodiments may have only nearest neighbor connections and nearest third or farther connections, etc. Conceivably, more elaborate embodiments may even support diagonal connections (e.g., connecting unit cell A with unit cell K and its other three neighboring corner unit cells in <figref idref="f0022">Fig. 7b</figref>). Those of ordinary skill will recognize that any of the various, expanded connections amongst unit cells is readily accomplished by expanding the sources of the inputs to the input mux structure 604 and expanding the fan-out from the output mux structure 603 of <figref idref="f0020">Fig. 6</figref>.</p>
<p id="p0061" num="0061"><figref idref="f0023">Fig. 8a</figref> shows an exemplary logical arrangement of registers along a row or column within a two dimensional register array structure (for ease of drawing the register array only has dimensions of 8x8, whereas, in actual practice the dimensions may be much larger). Here, neighboring pixels in an array being processed will be located in numerically neighboring units cells (e.g., a pair of neighboring pixels in the array will be placed in unit cells 3 and 4 rather than 3 and 5). The logical design of <figref idref="f0023">Fig. 8a</figref> also includes a roll capability by coupling the first logical unit cell 1 to the last unit cell 8 through connection 801 (thus the execution lanes of the execution lane array may also include a roll opcode).</p>
<p id="p0062" num="0062">Problems may arise however, particularly in the case of arrays of large dimension, if the design of <figref idref="f0023">Fig. 8a</figref> not only represents the logical design but also represents the physical<!-- EPO <DP n="18"> --> design. If the approach of <figref idref="f0023">Fig. 8a</figref> also represents the physical design, connection 801 corresponds to an extremely long length wire as compared to the length of the other wires that connect unit cell pairs other than pair 1 and 8. This particular wire length outlier can cause circuit timing complications (by slowing down all shift times between all unit cells to be no less than the slowest 1&lt;-&gt;8 shift time, or, introducing complications that recognize more cycles between 1&lt;-&gt;8 shifts than shifts between any other neighboring unit cells).</p>
<p id="p0063" num="0063"><figref idref="f0023">Fig. 8b</figref> shows an improved physical design for a row or column of a register array structure having the logical design of <figref idref="f0023">Fig. 8a</figref>. Here, a physical design corresponds to actual layout of circuit structures as opposed to just logical connections (as with a logical design). As observed in <figref idref="f0023">Fig. 8b</figref>, the physical design amortizes the extra length required by the 1&lt;-&gt;8 connection amongst the other unit cell by imposing a toroid design in the logic of the layout. For example, although unit cell 1 is physically connected to unit cell 2 to preserve the logic design, unit cell 8 physically sits between them. The resultant is a maximum wire length between unit cells in the structure of <figref idref="f0023">Fig. 8b</figref> that is much shorter than the length of wire 801 in <figref idref="f0023">Fig. 8a</figref>. As such the timing complications of the structure of <figref idref="f0023">Fig. 8b</figref> avoid the timing complications of the structure of <figref idref="f0023">Fig. 8a</figref> mentioned above. In an example, a roll of register content between all unit cells can transpire within a single cycle.</p>
<p id="p0064" num="0064"><figref idref="f0024">Fig. 8c</figref> shows that the data bus structure between the sheet generator or a random access memory 802 (such as any of RAMs 407 of <figref idref="f0008">Fig. 4</figref>) and a row or column of the register array include a kind of swizzling structure 803 in order to preserve the correct logic connections to an array or row having a toroid physical layout. <figref idref="f0025">Fig. 8d</figref> shows another toroid structure that can implement 4-hop shifts where the maximum distance traveled by any register value is 4 unit cells. Here, it should be clear that another swizzling like data bus would exist between the registers of <figref idref="f0025">Fig. 8d</figref> and the sheet generator or RAM. As such, a feature of the implementation of a toroid physical layout is the existence of swizzling by a data bus that connects inputs that are arranged in logical order.</p>
<p id="p0065" num="0065"><figref idref="f0026">Fig. 8e</figref> shows special fan-out circuitry from the output multiplexer 804 of a unit cell of the shift array structure. Here, output multiplexer 804 can be viewed as akin to output multiplexer 603 of <figref idref="f0020">Fig. 6</figref>. As the shift array is designed to support more and more connections (one hop, two hop, etc.), the fan-out of the output multiplexer 804 grows. As the fan-out of the multiplexer 804 grows, power consumption may become more and more of an issue. <figref idref="f0026">Fig. 8e</figref><!-- EPO <DP n="19"> --> shows an output multiplexer 804 for a shift register array that fully supports both one hop and two connections. Here, without the presence of the logic gates observed in <figref idref="f0026">Fig. 8e</figref>, a new output at multiplexer 804 (e.g., a new shift out value) would be broadcast to eight different locations (left neighbor, right neighbor, ..., 2 hop bottom neighbor). Here, as is understood in the art, a change in data across a run length of wire in a logical circuit corresponds to "switching activity" which, in turn, consumes power.</p>
<p id="p0066" num="0066">The presence of the eight logic gates observed at the output of multiplexer 804 are designed to prevent any such data change except on the actual wire that corresponds to the shift direction. For example, if the shift direction is one-hop to the right, only the gate that is coupled to the immediate right neighbor will permit the output of the multiplexer 804 to pass. All other logic gates will prevent the data value from propagating to the other nodes (where the shift value is not needed) and reduce power consumption of the shift operation in the process.</p>
<heading id="h0008"><b><i><u>c. implementation embodiments</u></i></b></heading>
<p id="p0067" num="0067">It is pertinent to point out that the various image processor architecture features described above are not necessarily limited to image processing in the traditional sense and therefore may be applied to other applications that may (or may not) cause the image processor to be re-characterized. For example, if any of the various image processor architecture features described above were to be used in the creation and/or generation and/or rendering of animation as opposed to the processing of actual camera images, the image processor may be characterized as a graphics processing unit. Additionally, the image processor architectural features described above may be applied to other technical applications such as video processing, vision processing, image recognition and/or machine learning. Applied in this manner, the image processor may be integrated with (e.g., as a co-processor to) a more general purpose processor (e.g., that is or is part of a CPU of computing system), or, may be a standalone processor within a computing system.</p>
<p id="p0068" num="0068">The hardware design embodiments discussed above may be embodied within a semiconductor chip and/or as a description of a circuit design for eventual targeting toward a semiconductor manufacturing process. In the case of the later, such circuit descriptions may take of the form of higher/behavioral level circuit descriptions (e.g., a VHDL description) or lower level circuit description (e.g., a register transfer level (RTL) description, transistor level description or mask description) or various combinations thereof. Circuit descriptions are<!-- EPO <DP n="20"> --> typically embodied on a computer readable storage medium (such as a CD-ROM or other type of storage technology).</p>
<p id="p0069" num="0069">From the preceding sections is pertinent to recognize that an image processor as described above may be embodied in hardware on a computer system (e.g., as part of a handheld device's System on Chip (SOC) that processes data from the handheld device's camera). In cases where the image processor is embodied as a hardware circuit, note that the image data that is processed by the image processor may be received directly from a camera. Here, the image processor may be part of a discrete camera, or, part of a computing system having an integrated camera. In the case of the later the image data may be received directly from the camera or from the computing system's system memory (e.g., the camera sends its image data to system memory rather than the image processor). Note also that many of the features described in the preceding sections may be applicable to a graphics processor unit (which renders animation).</p>
<p id="p0070" num="0070"><figref idref="f0027">Fig. 9</figref> provides an exemplary depiction of a computing system. Many of the components of the computing system described below are applicable to a computing system having an integrated camera and associated image processor (e.g., a handheld device such as a smartphone or tablet computer). Those of ordinary skill will be able to easily delineate between the two.</p>
<p id="p0071" num="0071">As observed in <figref idref="f0027">Fig. 9</figref>, the basic computing system may include a central processing unit 901 (which may include, e.g., a plurality of general purpose processing cores 915_1 through 915_N and a main memory controller 1417 disposed on a multi-core processor or applications processor), system memory 902, a display 903 (e.g., touchscreen, flat-panel), a local wired point-to-point link (e.g., USB) interface 904, various network I/O functions 905 (such as an Ethernet interface and/or cellular modem subsystem), a wireless local area network (e.g., WiFi) interface 906, a wireless point-to-point link (e.g., Bluetooth) interface 907 and a Global Positioning System interface 908, various sensors 909_1 through 909_N, one or more cameras 910, a battery 911, a power management control unit 912, a speaker and microphone 913 and an audio coder/decoder 914.</p>
<p id="p0072" num="0072">An applications processor or multi-core processor 950 may include one or more general purpose processing cores 915 within its CPU 901, one or more graphical processing units 916, a memory management function 1417 (e.g., a memory controller), an I/O control function 918 and an image processing unit 919. The general purpose processing cores 915 typically<!-- EPO <DP n="21"> --> execute the operating system and application software of the computing system. The graphics processing units 916 typically execute graphics intensive functions to, e.g., generate graphics information that is presented on the display 903. The memory control function 1417 interfaces with the system memory 902 to write/read data to/from system memory 902. The power management control unit 912 generally controls the power consumption of the system 900.</p>
<p id="p0073" num="0073">The image processing unit 919 may be implemented according to any of the image processing unit embodiments described at length above in the preceding sections. Alternatively or in combination, the IPU 919 may be coupled to either or both of the GPU 916 and CPU 901 as a co-processor thereof. Additionally, in various embodiments, the GPU 916 may be implemented with any of the image processor features described at length above.</p>
<p id="p0074" num="0074">Each of the touchscreen display 903, the communication interfaces 904 - 907, the GPS interface 908, the sensors 909, the camera 910, and the speaker/microphone codec 913, 914 all can be viewed as various forms of I/O (input and/or output) relative to the overall computing system including, where appropriate, an integrated peripheral device as well (e.g., the one or more cameras 910). Depending on implementation, various ones of these I/O components may be integrated on the applications processor/multi-core processor 950 or may be located off the die or outside the package of the applications processor/multi-core processor 950.</p>
<p id="p0075" num="0075">In an embodiment one or more cameras 910 includes a depth camera capable of measuring depth between the camera and an object in its field of view. Application software, operating system software, device driver software and/or firmware executing on a general purpose CPU core (or other functional block having an instruction execution pipeline to execute program code) of an applications processor or other processor may perform any of the functions described above.</p>
<p id="p0076" num="0076">Embodiments of the invention may include various processes as set forth above. The processes may be embodied in machine-executable instructions. The instructions can be used to cause a general-purpose or special-purpose processor to perform certain processes. Alternatively, these processes may be performed by specific hardware components that contain hardwired logic for performing the processes, or by any combination of programmed computer components and custom hardware components.</p>
<p id="p0077" num="0077">Elements of the present invention may also be provided as a machine-readable medium for storing the machine-executable instructions. The machine-readable medium may<!-- EPO <DP n="22"> --> include, but is not limited to, floppy diskettes, optical disks, CD-ROMs, and magneto-optical disks, FLASH memory, ROMs, RAMs, EPROMs, EEPROMs, magnetic or optical cards, propagation media or other type of media/machine-readable medium suitable for storing electronic instructions. For example, the present invention may be downloaded as a computer program which may be transferred from a remote computer (e.g., a server) to a requesting computer (e.g., a client) by way of data signals embodied in a carrier wave or other propagation medium via a communication link (e.g., a modem or network connection).</p>
<p id="p0078" num="0078">In the foregoing specification, the invention has been described with reference to specific exemplary embodiments thereof. It will, however, be evident that various modifications and changes may be made thereto without departing from the scope of the invention as set forth in the appended claims. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense.</p>
</description>
<claims id="claims01" lang="en"><!-- EPO <DP n="23"> -->
<claim id="c-en-01-0001" num="0001">
<claim-text>An apparatus, comprising:
<claim-text>an execution lane array (305, 405) coupled to a two-dimensional shift register array structure (306, 406),</claim-text>
<claim-text>wherein the execution lane array (305, 405) is an array of execution lanes (510, 601),</claim-text>
<claim-text>wherein the execution lane array (305, 405) is configured to simultaneously operate on multiple overlapping stencils of image data loaded into the two-dimensional shift register array structure (306, 406),</claim-text>
<claim-text>wherein each execution lane (510,610) in the execution lane array (305, 405) comprises a first register (R1), the first register (R1) being a physical register of the execution lane (510,610);</claim-text>
<claim-text>wherein each execution lane (510,610) has a location in the execution lane array (305, 405) and is coupled to a register file (602) at a same location in the two-dimensional shift register array structure (306, 406), the register file including at least a second shift register (R2), being a physical register of the two-dimensional shift register array structure (306, 406), such that different execution lanes (510, 601) of the execution lane array (305, 405) have different dedicated registers (R2);</claim-text>
<claim-text>wherein each execution lane (510,610) may read from or write to any of its first register (R1) and its dedicated register(s) (R2);</claim-text>
<claim-text>and wherein an execution lane is configured to shift content from its coupled register file to a register file coupled to a logically neighbouring execution lane and to shift content into its coupled register file from a register file coupled to a logically neighbouring execution lane such that content shifts between logically neighbouring execution lanes are in a same direction.</claim-text></claim-text></claim>
<claim id="c-en-01-0002" num="0002">
<claim-text>The apparatus of claim 1 wherein the two-dimensional shift register array structure (306, 406) includes coupling between logical locations in the two-dimensional shift register array structure (306, 406) that are at least one of two, three and four locations apart.</claim-text></claim>
<claim id="c-en-01-0003" num="0003">
<claim-text>The apparatus of claim 1 wherein the dimensions of the two-dimensional register array structure (306, 406) are larger than the dimensions of the execution lane array (305, 405) such that a halo region (409) exists outside the execution lane array (305, 405).</claim-text></claim>
<claim id="c-en-01-0004" num="0004">
<claim-text>The apparatus of claim 1 wherein a pair of logically neighboring array locations in the two-dimensional register array structure (306, 406) have a physical array location between their respective physical locations.</claim-text></claim>
<claim id="c-en-01-0005" num="0005">
<claim-text>The apparatus of claim 4 wherein the physical array imposes a toroid structure.<!-- EPO <DP n="24"> --></claim-text></claim>
<claim id="c-en-01-0006" num="0006">
<claim-text>The apparatus of claim 4 wherein the two-dimensional register array structure (306, 406) couples a last logical location to a first logical location to support a roll operation.</claim-text></claim>
<claim id="c-en-01-0007" num="0007">
<claim-text>The apparatus of claim 4 wherein the two-dimensional register array structure (306, 406) is coupled to a random access memory (307, 407) by way of a swizzled data bus (803).</claim-text></claim>
<claim id="c-en-01-0008" num="0008">
<claim-text>The apparatus of any of claims 1 to 7, wherein the apparatus is a computing system (900), and further comprises:
<claim-text>a plurality of processing cores (915);</claim-text>
<claim-text>a memory controller (1417) coupled to the plurality of processing cores (915), the memory controller coupled to a system memory;</claim-text>
<claim-text>an image processor (919), wherein the image processor (919) includes the execution lane array (305, 405).</claim-text></claim-text></claim>
<claim id="c-en-01-0009" num="0009">
<claim-text>A computer-implemented method, comprising:
<claim-text>shifting, in a same direction and number of locations, image data from multiple contiguous locations within a two-dimensional shift register array structure (306, 406) to provide each of multiple different execution lanes (510, 601) within an execution lane array (305, 405) a new value within respective dedicated registers of the multiple different execution lanes (510, 601), each execution lane (510,610) in the execution lane array (305, 405) comprising a first register (R1), the first register (R1) being a physical register of the execution lane (510,610), and each execution lane (510,610) having a location in the execution lane array and being coupled to a register file (602) at a same location in the two-dimensional shift register array structure (306, 406), the register file including at least a second shift register (R2) being a physical register of the two-dimensional shift register array structure (306, 406) such that different execution lanes (510, 601) of the execution lane array (305, 405) have different dedicated registers (R2),</claim-text>
<claim-text>wherein the execution lane array (305, 405) is an array of execution lanes (510, 601),</claim-text>
<claim-text>wherein the execution lane array (305, 405) simultaneously operates on multiple overlapping stencils of image data loaded into the two-dimensional shift register array structure (306, 406);</claim-text>
<claim-text>and wherein an execution lane is configured to shift content from its coupled register file to a register file coupled to a logically neighbouring execution lane and to shift content into its coupled register file from a register file coupled to a logically neighbouring execution lane, such that content shifts between logically neighbouring execution lanes are in the same direction.</claim-text><!-- EPO <DP n="25"> --></claim-text></claim>
<claim id="c-en-01-0010" num="0010">
<claim-text>The method of claim 9 wherein shifting image data comprises shifting image data for a number of logical locations that is any of one location, two locations, three location, and four locations.</claim-text></claim>
<claim id="c-en-01-0011" num="0011">
<claim-text>The method of claim 9 further comprising performing a roll of data within the two-dimensional register array structure (306, 406).</claim-text></claim>
<claim id="c-en-01-0012" num="0012">
<claim-text>A machine readable medium containing a description of a circuit, wherein the circuit comprises:
<claim-text>an execution lane array (305, 405) coupled to a two-dimensional shift register array structure (306, 406),</claim-text>
<claim-text>wherein the execution lane array (305, 405) is an array of execution lanes (510, 601),</claim-text>
<claim-text>wherein the execution lane array (305, 405) is configured to simultaneously operate on multiple overlapping stencils of image data loaded into the two-dimensional shift register array structure (306, 406),</claim-text>
<claim-text>wherein each execution lane (510,610) in the execution lane array (305, 405) comprises a first register (R1), the first register (R1) being a physical register of the execution lane (510,610);</claim-text>
<claim-text>wherein each execution lane (510,610) has a location in the execution lane array (305, 405) and is coupled to a register file (602) at a same location in the two-dimensional shift register array structure (306, 406), the register file including at least a second shift register (R2), being a physical register of the two-dimensional shift register array structure (306, 406), such that different execution lanes (510, 601) of the execution lane array (305, 405) have different dedicated registers (R2);</claim-text>
<claim-text>wherein each execution lane (510,610) may read from or write to any of its first register (R1) and its dedicated register(s) (R2);</claim-text>
<claim-text>and wherein an execution lane is configured to shift content from its coupled register file to a register file coupled to a logically neighbouring execution lane and to shift content into its coupled register file from a register file coupled to a logically neighbouring execution lane such that content shifts between logically neighbouring execution lanes are in a same direction.</claim-text></claim-text></claim>
<claim id="c-en-01-0013" num="0013">
<claim-text>The machine readable medium of claim 12 wherein the two-dimensional shift register array structure (306, 406) includes coupling between logical locations in the two-dimensional shift register array structure (306, 406) that are at least one of two, three and four locations apart.</claim-text></claim>
</claims>
<claims id="claims02" lang="de"><!-- EPO <DP n="26"> -->
<claim id="c-de-01-0001" num="0001">
<claim-text>Vorrichtung, umfassend:
<claim-text>ein Ausführungsbahnen-Array (305, 405), das mit einer zweidimensionalen Schieberegister-Arraystruktur (306, 406) gekoppelt ist,</claim-text>
<claim-text>worin das Ausführungsbahnen-Array (305, 405) ein Array von Ausführungsbahnen (510, 601) ist,</claim-text>
<claim-text>worin das Ausführungsbahnen-Array (305, 405) dafür konfiguriert ist, gleichzeitig auf mehreren überlappenden Schablonen von Bilddaten zu arbeiten, die in die zweidimensionale Schieberegister-Arraystruktur (306, 406) geladen sind,</claim-text>
<claim-text>worin jede Ausführungsbahn (510, 610) in dem Ausführungsbahnen-Array (305, 405) ein erstes Register (R1) umfasst, wobei das erste Register (R1) ein physisches Register der Ausführungsbahn (510, 610) ist;</claim-text>
<claim-text>worin jede Ausführungsbahn (510, 610) eine Speicherstelle in dem Ausführungsbahnen-Array (305, 405) hat und mit einer Registerdatei (602) an einer gleichen Speicherstelle in der zweidimensionalen Schieberegister-Arraystruktur (306, 406) gekoppelt ist, wobei die Registerdatei mindestens ein zweites Schieberegister (R2) einschließt, das ein physisches Register der zweidimensionalen Schieberegister-Arraystruktur (306, 406) ist, sodass unterschiedliche Ausführungsbahnen (510, 601) des Ausführungsbahnen-Arrays (305, 405) unterschiedliche fest zugeordnete Register (R2) haben;</claim-text>
<claim-text>worin jede Ausführungsbahn (510, 610) aus irgendeinem ihres ersten Registers (R1) und ihres/r fest zugeordneten Register(s) (R2) lesen oder in eines davon schreiben kann;</claim-text>
<claim-text>und worin eine Ausführungsbahn dafür konfiguriert ist, den Inhalt aus ihrer gekoppelten Registerdatei in eine Registerdatei zu verschieben, die mit einer logisch benachbarten Ausführungsbahn gekoppelt ist, und Inhalt aus einer Registerdatei, die mit einer logisch benachbarten Ausführungsbahn gekoppelt ist, in ihre gekoppelte Registerdatei zu verschieben, sodass Inhaltsverschiebungen zwischen logisch benachbarten Ausführungsbahnen in einer gleichen Richtung erfolgen.</claim-text></claim-text></claim>
<claim id="c-de-01-0002" num="0002">
<claim-text>Vorrichtung nach Anspruch 1, worin die zweidimensionale Schieberegister-Arraystruktur (306, 406) eine Kopplung zwischen logischen Speicherstellen in der zweidimensionalen Schieberegister-Arraystruktur (306, 406), die mindestens eines von zwei, drei und vier Speicherstellen voneinander entfernt sind, einschließt.</claim-text></claim>
<claim id="c-de-01-0003" num="0003">
<claim-text>Vorrichtung nach Anspruch 1, worin die Abmessungen der zweidimensionalen Schieberegister-Arraystruktur (306, 406) größer sind als die Abmessungen des Ausführungsbahnen-Arrays (305, 405), sodass ein Halo-Bereich (409) außerhalb des Ausführungsbahnen-Arrays (305, 405) existiert.</claim-text></claim>
<claim id="c-de-01-0004" num="0004">
<claim-text>Vorrichtung nach Anspruch 1, worin ein Paar von logisch benachbarten Array-Speicherstellen in der zweidimensionalen Schieberegister-Arraystruktur (306, 406) eine<!-- EPO <DP n="27"> --> physische Array-Speicherstelle zwischen ihren jeweiligen physischen Speicherstellen aufweist.</claim-text></claim>
<claim id="c-de-01-0005" num="0005">
<claim-text>Vorrichtung nach Anspruch 4, worin das physische Array eine Toroid-Struktur vorschreibt.</claim-text></claim>
<claim id="c-de-01-0006" num="0006">
<claim-text>Vorrichtung nach Anspruch 4, worin die zweidimensionale Schieberegister-Arraystruktur (306, 406) eine letzte logische Speicherstelle mit einer ersten logischen Speicherstelle koppelt, um eine Rolloperation zu unterstützen.</claim-text></claim>
<claim id="c-de-01-0007" num="0007">
<claim-text>Vorrichtung nach Anspruch 4, worin die zweidimensionale Schieberegister-Arraystruktur (306, 406) mittels eines verdrillten Datenbusses (803) mit einem Direktzugriffsspeicher (307, 407) gekoppelt ist.</claim-text></claim>
<claim id="c-de-01-0008" num="0008">
<claim-text>Vorrichtung nach einem der Ansprüche 1 bis 7, worin die Vorrichtung ein Computersystem (900) ist und ferner umfasst:
<claim-text>eine Vielzahl von Rechenkernen (915);</claim-text>
<claim-text>einen Speichercontroller (1417), der mit der Vielzahl von Verarbeitungskernen (915) gekoppelt ist, wobei der Speichercontroller mit einem Systemspeicher gekoppelt ist;</claim-text>
<claim-text>einen Bildprozessor (919), worin der Bildprozessor (919) das Ausführungsbahnen-Array (305, 405) einschließt.</claim-text></claim-text></claim>
<claim id="c-de-01-0009" num="0009">
<claim-text>Computerimplementiertes Verfahren, umfassend:
<claim-text>Verschieben von Bilddaten aus mehreren zusammenhängenden Speicherstellen innerhalb einer zweidimensionalen Schieberegister-Arraystruktur (306, 406) in einer gleichen Richtung und um eine gleiche Anzahl von Speicherstellen, um jeder von mehreren unterschiedlichen Ausführungsbahnen (510, 601) innerhalb eines Ausführungsbahnen-Arrays (305, 405) einen neuen Wert innerhalb jeweiliger fest zugeordneter Register der mehreren unterschiedlichen Ausführungsbahnen (510, 601) bereitzustellen, wobei jede Ausführungsbahn (510, 610) in dem Ausführungsbahnen-Array (305, 405) ein erstes Register (R1) umfasst, wobei das erste Register (R1) ein physisches Register der Ausführungsbahn (510, 610) ist, und jede Ausführungsbahn (510, 610) eine Speicherstelle in dem Ausführungsbahnen-Array hat und mit einer Registerdatei (602) an einer gleichen Speicherstelle in der zweidimensionalen Schieberegister-Arraystruktur (306, 406) gekoppelt ist, wobei die Registerdatei mindestens ein zweites Schieberegister (R2) einschließt, das ein physisches Register der zweidimensionalen Schieberegister-Arraystruktur (306, 406) ist, sodass unterschiedliche Ausführungsbahnen (510, 601) des Ausführungsbahnen-Arrays (305, 405) unterschiedliche fest zugeordnete Register (R2) haben,</claim-text>
<claim-text>worin das Ausführungsbahnen-Array (305, 405) ein Array von Ausführungsbahnen (510, 601) ist,<!-- EPO <DP n="28"> --></claim-text>
<claim-text>worin das Ausführungsbahnen-Array (305, 405) gleichzeitig auf mehreren überlappenden Schablonen von Bilddaten arbeitet, die in die zweidimensionale Schieberegister-Arraystruktur (306, 406) geladen sind;</claim-text>
<claim-text>und worin eine Ausführungsbahn dafür konfiguriert ist, Inhalt aus ihrer gekoppelten Registerdatei in eine Registerdatei zu verschieben, die mit einer logisch benachbarten Ausführungsbahn gekoppelt ist, und Inhalt aus einer Registerdatei, die mit einer logisch benachbarten Ausführungsbahn gekoppelt ist, in ihre gekoppelte Registerdatei zu verschieben, sodass Inhaltsverschiebungen zwischen logisch benachbarten Ausführungsbahnen in einer gleichen Richtung erfolgen.</claim-text></claim-text></claim>
<claim id="c-de-01-0010" num="0010">
<claim-text>Verfahren nach Anspruch 9, worin das Verschieben von Bilddaten umfasst: Verschieben von Bilddaten um eine Anzahl von logischen Speicherstellen, die eines von einer Speicherstelle, zwei Speicherstellen, drei Speicherstellen und vier Speicherstellen ist.</claim-text></claim>
<claim id="c-de-01-0011" num="0011">
<claim-text>Verfahren nach Anspruch 9, ferner umfassend: Durchführen eines Rollens von Daten innerhalb der zweidimensionalen Register-Arraystruktur (306, 406).</claim-text></claim>
<claim id="c-de-01-0012" num="0012">
<claim-text>Maschinenlesbares Medium, das eine Beschreibung einer Schaltung enthält, worin die Schaltung umfasst:
<claim-text>ein Ausführungsbahnen-Array (305, 405), das mit einer zweidimensionalen Schieberegister-Arraystruktur (306, 406) gekoppelt ist,</claim-text>
<claim-text>worin das Ausführungsbahnen-Array (305, 405) ein Array von Ausführungsbahnen (510, 601) ist,</claim-text>
<claim-text>worin das Ausführungsbahnen-Array (305, 405) dafür konfiguriert ist, gleichzeitig auf mehreren überlappenden Schablonen von Bilddaten zu arbeiten, die in die zweidimensionale Schieberegister-Arraystruktur (306, 406) geladen sind,</claim-text>
<claim-text>worin jede Ausführungsbahn (510, 610) in dem Ausführungsbahnen-Array (305, 405) ein erstes Register (R1) umfasst, wobei das erste Register (R1) ein physisches Register der Ausführungsbahn (510, 610) ist;</claim-text>
<claim-text>worin jede Ausführungsbahn (510, 610) eine Speicherstelle in dem Ausführungsbahnen-Array (305, 405) hat und mit einer Registerdatei (602) an einer gleichen Speicherstelle in der zweidimensionalen Schieberegister-Arraystruktur (306, 406) gekoppelt ist, wobei die Registerdatei mindestens ein zweites Schieberegister (R2) einschließt, das ein physisches Register der zweidimensionalen Schieberegister-Arraystruktur (306, 406) ist, sodass unterschiedliche Ausführungsbahnen (510, 601) des Ausführungsbahnen-Arrays (305, 405) unterschiedliche fest zugeordnete Register (R2) haben;</claim-text>
<claim-text>worin jede Ausführungsbahn (510, 610) aus einem ihres ersten Registers (R1) und ihres/r fest zugeordneten Register(s) (R2) lesen oder in eines davon schreiben kann;</claim-text>
<claim-text>und worin eine Ausführungsbahn dafür konfiguriert ist, Inhalt aus ihrer gekoppelten Registerdatei in eine Registerdatei zu verschieben, die mit einer logisch benachbarten<!-- EPO <DP n="29"> --> Ausführungsbahn gekoppelt ist, und Inhalt aus einer Registerdatei, die mit einer logisch benachbarten Ausführungsbahn gekoppelt ist, in ihre gekoppelte Registerdatei zu verschieben, sodass Inhaltsverschiebungen zwischen logisch benachbarten Ausführungsbahnen in einer gleichen Richtung erfolgen.</claim-text></claim-text></claim>
<claim id="c-de-01-0013" num="0013">
<claim-text>Maschinenlesbares Medium nach Anspruch 12, worin die zweidimensionale Schieberegister-Arraystruktur (306, 406) eine Kopplung zwischen logischen Speicherstellen in der zweidimensionalen Schieberegister-Arraystruktur (306, 406) einschließt, die mindestens eine von zwei, drei und vier Speicherstellen voneinander entfernt sind.</claim-text></claim>
</claims>
<claims id="claims03" lang="fr"><!-- EPO <DP n="30"> -->
<claim id="c-fr-01-0001" num="0001">
<claim-text>Appareil, comprenant :
<claim-text>un réseau de voie d'exécution (305, 405) raccordé à une structure de réseau de registre de décalage bidimensionnel (306, 406),</claim-text>
<claim-text>dans lequel le réseau de voie d'exécution (305, 405) est un réseau de voies d'exécution (510, 601) ;</claim-text>
<claim-text>dans lequel le réseau de voie d'exécution (305, 405) est configuré pour travailler simultanément sur de multiples pochoirs superposés de données d'image chargées dans la structure de réseau de registre de décalage bidimensionnel (306, 406) ;</claim-text>
<claim-text>dans lequel chaque voie d'exécution (510, 610) dans le réseau de voies d'exécution (305, 405) comprend un premier registre (R1), le premier registre (R1) étant un registre physique de la voie d'exécution (510, 610) ;</claim-text>
<claim-text>dans lequel chaque voie d'exécution (510, 610) présente un emplacement dans le réseau de voies d'exécution (305, 405) et est couplée à un fichier de registre (602) au même emplacement dans la structure de réseau de registre de décalage bidimensionnel (306, 406), le fichier de registre incluant au moins un second registre de décalage (R2), qui est un registre physique de la structure de réseau de registre de décalage bidimensionnel (306, 406), de sorte que différentes voies d'exécution (510, 601) du réseau de voies d'exécution (305, 405) présentent des registres dédiés différents (R2) ;</claim-text>
<claim-text>dans lequel chaque voie d'exécution (510, 610) peut lire depuis ou écrire sur n'importe lequel de son premier registre (R1) et de son/ses registre(s) dédié(s) (R2) ;</claim-text>
<claim-text>et dans lequel une voie d'exécution est configurée pour déplacer le contenu de son fichier de registre couplé vers un fichier de registre couplé à une voie d'exécution logiquement voisine et pour déplacer un contenu dans son fichier de registre couplé depuis un fichier de registre couplé vers une voie d'exécution logiquement voisine, de sorte que les décalages de contenu entre des voies d'exécution logiquement voisines se fassent dans une même direction.</claim-text></claim-text></claim>
<claim id="c-fr-01-0002" num="0002">
<claim-text>Appareil selon la revendication 1, dans lequel la structure de réseau de registre de décalage bidimensionnel (306, 406) inclut le couplage entre des emplacements logiques dans la structure de réseau de registre de décalage bidimensionnel (306, 406), qui sont espacés d'au moins un de deux, trois et quatre emplacements.</claim-text></claim>
<claim id="c-fr-01-0003" num="0003">
<claim-text>Appareil selon la revendication 1, dans lequel les dimensions de la structure de réseau de registre de décalage bidimensionnel (306, 406) sont plus importantes que les dimensions du réseau de voie d'exécution (305, 405) de sorte qu'une région de halo (409) existe hors du réseau de voie d'exécution (305, 405).</claim-text></claim>
<claim id="c-fr-01-0004" num="0004">
<claim-text>Appareil selon la revendication 1, dans lequel une paire d'emplacements de réseau logiquement voisins dans la structure de réseau de registre de décalage bidimensionnel<!-- EPO <DP n="31"> --> (306, 406) présentent un emplacement de réseau physique entre leurs emplacements physiques respectifs.</claim-text></claim>
<claim id="c-fr-01-0005" num="0005">
<claim-text>Appareil selon la revendication 4, dans lequel le réseau physique impose une structure toroïde.</claim-text></claim>
<claim id="c-fr-01-0006" num="0006">
<claim-text>Appareil selon la revendication 4, dans lequel la structure de réseau de registre de décalage bidimensionnel (306, 406) relie un dernier emplacement logique à un premier emplacement logique afin de soutenir une opération de roulement.</claim-text></claim>
<claim id="c-fr-01-0007" num="0007">
<claim-text>Appareil selon la revendication 4, dans lequel la structure de réseau de registre de décalage bidimensionnel (306, 406) est couplée à une mémoire vive (307, 407) par le biais d'un bus de données mélangées (803).</claim-text></claim>
<claim id="c-fr-01-0008" num="0008">
<claim-text>Appareil selon l'une quelconque des revendications 1 à 7, dans lequel l'appareil est un système informatique (900) et il comprend en outre :
<claim-text>une pluralité de cœurs de traitement (915) ;</claim-text>
<claim-text>un contrôleur de mémoire (1417) raccordé à la pluralité de cœurs de traitement (915), le contrôleur de mémoire étant raccordé à une mémoire système ;</claim-text>
<claim-text>un processeur d'image (919), dans lequel le processeur d'image (919) inclut le réseau de voie d'exécution (305, 405).</claim-text></claim-text></claim>
<claim id="c-fr-01-0009" num="0009">
<claim-text>Procédé appliqué sur ordinateur, comprenant :
<claim-text>le décalage, dans une même direction et d'un même nombre d'emplacements, de données d'image de multiples emplacements contigus dans une structure de réseau de registre de décalage bidimensionnel (306, 406) afin de fournir à chacune des multiples voies d'exécution différentes (510, 601) dans un réseau de voies d'exécution (305, 405) une nouvelle valeur dans des registres dédiés respectifs des multiples voies d'exécution différentes (510, 601), chaque voie d'exécution (510, 610), dans le réseau de voies d'exécution (305, 405) comprenant un premier registre (R1), le premier registre (R1) étant un registre physique de la voie d'exécution (510, 610), et chaque voie d'exécution (510, 610) étant dotée d'un emplacement dans le réseau de voies d'exécution et étant couplée à un fichier de registre (602) au même emplacement dans la structure de réseau de registre de décalage bidimensionnel (306, 406), le fichier de registre incluant au moins un second registre de décalage (R2) qui est un registre physique de la structure de réseau de registre de décalage bidimensionnel (306, 406) de sorte que différentes voies d'exécution (510, 601) du réseau de voies d'exécution (305, 405) présentent des registres dédiés différents (R2) ;</claim-text>
<claim-text>dans lequel le réseau de voie d'exécution (305, 405) est un réseau de voies d'exécution (510, 601) ;</claim-text>
<claim-text>dans lequel le réseau de voie d'exécution (305, 405) travaille simultanément sur de multiples pochoirs superposés de données d'image chargées dans la structure de réseau de registre de décalage bidimensionnel (306, 406) ;<!-- EPO <DP n="32"> --></claim-text>
<claim-text>et dans lequel une voie d'exécution est configurée pour déplacer du contenu de son fichier de registre couplé à un fichier de registre couplé à une voie d'exécution logiquement voisine et pour déplacer du contenu dans son fichier de registre couplé depuis un fichier de registre couplé à une voie d'exécution logiquement voisine, de sorte que les décalages de contenu entre des voies d'exécution logiquement voisines se fassent dans la même direction.</claim-text></claim-text></claim>
<claim id="c-fr-01-0010" num="0010">
<claim-text>Procédé selon la revendication 9, dans lequel le décalage de données d'image comprend le décalage de données d'image pour un certain nombre d'emplacements logiques qui sont n'importe lequel parmi un emplacement, deux emplacements, trois emplacements et quatre emplacements.</claim-text></claim>
<claim id="c-fr-01-0011" num="0011">
<claim-text>Procédé selon la revendication 9, comprenant en outre la réalisation d'un roulement de données dans la structure de réseau de registre bidimensionnel (306, 406).</claim-text></claim>
<claim id="c-fr-01-0012" num="0012">
<claim-text>Support lisible sur une machine contenant une description d'un circuit, dans lequel le circuit comprend :
<claim-text>un réseau de voies d'exécution (305, 405) couplé à une structure de réseau de registre de décalage bidimensionnel (306, 406),</claim-text>
<claim-text>dans lequel le réseau de voies d'exécution (305, 405) est un réseau de voies d'exécution (510, 601) ;</claim-text>
<claim-text>dans lequel le réseau de voies d'exécution (305, 405) est configuré pour fonctionner simultanément sur de multiples pochoirs superposés de données d'image chargées dans la structure de réseau de registre de décalage bidimensionnel (306, 406) ;</claim-text>
<claim-text>dans lequel chaque voie d'exécution (510, 610) dans le réseau de voies d'exécution (305, 405) comprend un premier registre (R1), le premier registre (R1) étant un registre physique de la voie d'exécution (510, 610) ;</claim-text>
<claim-text>dans lequel chaque voie d'exécution (510, 610) présente un emplacement dans le réseau de voies d'exécution (305, 405) et est couplée à un fichier de registre (602) au même emplacement dans la structure de réseau de registre de décalage bidimensionnel (306, 406), le fichier de registre incluant au moins un second registre de décalage (R2), qui est un registre physique de la structure de réseau de registre de décalage bidimensionnel (306, 406), de sorte que différentes voies d'exécution (510, 601) du réseau de voies d'exécution (305, 405) présentent des registres dédiés différents (R2) ;</claim-text>
<claim-text>dans lequel chaque voie d'exécution (510, 610) peut lire depuis ou écrire sur n'importe lequel de son premier registre (R1) et de son/ses registre(s) dédié(s) (R2) ;</claim-text>
<claim-text>et dans lequel une voie d'exécution est configurée pour déplacer le contenu de son fichier de registre couplé à un fichier de registre couplé à une voie d'exécution logiquement voisine et pour déplacer un contenu dans son fichier de registre couplé depuis un fichier de registre couplé à une voie d'exécution logiquement voisine de sorte que les décalages de<!-- EPO <DP n="33"> --> contenu entre des voies d'exécution logiquement voisines se fassent dans une même direction.</claim-text></claim-text></claim>
<claim id="c-fr-01-0013" num="0013">
<claim-text>Support lisible sur une machine selon la revendication 12, dans lequel la structure de réseau de registre de décalage bidimensionnel (306, 406) inclut le couplage entre des emplacements logiques dans la structure de réseau de registre de décalage bidimensionnel (306, 406) qui sont espacés d'au moins un de deux, trois et quatre emplacements.</claim-text></claim>
</claims>
<drawings id="draw" lang="en"><!-- EPO <DP n="34"> -->
<figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="158" he="175" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="35"> -->
<figure id="f0002" num="2a"><img id="if0002" file="imgf0002.tif" wi="136" he="157" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="36"> -->
<figure id="f0003" num="2b"><img id="if0003" file="imgf0003.tif" wi="145" he="103" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="37"> -->
<figure id="f0004" num="2c"><img id="if0004" file="imgf0004.tif" wi="130" he="102" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="38"> -->
<figure id="f0005" num="2d"><img id="if0005" file="imgf0005.tif" wi="130" he="102" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="39"> -->
<figure id="f0006" num="2e"><img id="if0006" file="imgf0006.tif" wi="145" he="102" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="40"> -->
<figure id="f0007" num="3"><img id="if0007" file="imgf0007.tif" wi="149" he="198" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="41"> -->
<figure id="f0008" num="4"><img id="if0008" file="imgf0008.tif" wi="161" he="202" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="42"> -->
<figure id="f0009" num="5a"><img id="if0009" file="imgf0009.tif" wi="157" he="190" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="43"> -->
<figure id="f0010" num="5b"><img id="if0010" file="imgf0010.tif" wi="148" he="191" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="44"> -->
<figure id="f0011" num="5c"><img id="if0011" file="imgf0011.tif" wi="152" he="178" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="45"> -->
<figure id="f0012" num="5d"><img id="if0012" file="imgf0012.tif" wi="152" he="186" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="46"> -->
<figure id="f0013" num="5e"><img id="if0013" file="imgf0013.tif" wi="152" he="186" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="47"> -->
<figure id="f0014" num="5f"><img id="if0014" file="imgf0014.tif" wi="152" he="178" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="48"> -->
<figure id="f0015" num="5g"><img id="if0015" file="imgf0015.tif" wi="152" he="192" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="49"> -->
<figure id="f0016" num="5h"><img id="if0016" file="imgf0016.tif" wi="152" he="195" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="50"> -->
<figure id="f0017" num="5i"><img id="if0017" file="imgf0017.tif" wi="152" he="180" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="51"> -->
<figure id="f0018" num="5j"><img id="if0018" file="imgf0018.tif" wi="152" he="186" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="52"> -->
<figure id="f0019" num="5k"><img id="if0019" file="imgf0019.tif" wi="150" he="177" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="53"> -->
<figure id="f0020" num="6"><img id="if0020" file="imgf0020.tif" wi="142" he="213" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="54"> -->
<figure id="f0021" num="7a"><img id="if0021" file="imgf0021.tif" wi="128" he="159" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="55"> -->
<figure id="f0022" num="7b"><img id="if0022" file="imgf0022.tif" wi="159" he="174" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="56"> -->
<figure id="f0023" num="8a,8b"><img id="if0023" file="imgf0023.tif" wi="130" he="212" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="57"> -->
<figure id="f0024" num="8c"><img id="if0024" file="imgf0024.tif" wi="144" he="204" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="58"> -->
<figure id="f0025" num="8d"><img id="if0025" file="imgf0025.tif" wi="120" he="206" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="59"> -->
<figure id="f0026" num="8e"><img id="if0026" file="imgf0026.tif" wi="157" he="197" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="60"> -->
<figure id="f0027" num="9"><img id="if0027" file="imgf0027.tif" wi="144" he="207" img-content="drawing" img-format="tif"/></figure>
</drawings>
<ep-reference-list id="ref-list">
<heading id="ref-h0001"><b>REFERENCES CITED IN THE DESCRIPTION</b></heading>
<p id="ref-p0001" num=""><i>This list of references cited by the applicant is for the reader's convenience only. It does not form part of the European patent document. Even though great care has been taken in compiling the references, errors or omissions cannot be excluded and the EPO disclaims all liability in this regard.</i></p>
<heading id="ref-h0002"><b>Patent documents cited in the description</b></heading>
<p id="ref-p0002" num="">
<ul id="ref-ul0001" list-style="bullet">
<li><patcit id="ref-pcit0001" dnum="US5612693A"><document-id><country>US</country><doc-number>5612693</doc-number><kind>A</kind></document-id></patcit><crossref idref="pcit0001">[0006]</crossref></li>
<li><patcit id="ref-pcit0002" dnum="US20110153925A1"><document-id><country>US</country><doc-number>20110153925</doc-number><kind>A1</kind></document-id></patcit><crossref idref="pcit0002">[0007]</crossref></li>
<li><patcit id="ref-pcit0003" dnum="US2015086134A"><document-id><country>US</country><doc-number>2015086134</doc-number><kind>A</kind></document-id></patcit><crossref idref="pcit0003">[0008]</crossref></li>
<li><patcit id="ref-pcit0004" dnum="US2014164737A"><document-id><country>US</country><doc-number>2014164737</doc-number><kind>A</kind></document-id></patcit><crossref idref="pcit0004">[0009]</crossref></li>
</ul></p>
<heading id="ref-h0003"><b>Non-patent literature cited in the description</b></heading>
<p id="ref-p0003" num="">
<ul id="ref-ul0002" list-style="bullet">
<li><nplcit id="ref-ncit0001" npl-type="s"><article><author><name>CARDELLS-TORMO et al.</name></author><atl>Area-Efficient 2-D Shift-Variant Convolvers for FPGA-based Digital Image Processing</atl><serial><sertitle>Proceedings of the IEEE Workshop on Signal Processing System Design and Implementation</sertitle><pubdate><sdate>20051102</sdate><edate/></pubdate></serial></article></nplcit><crossref idref="ncit0001">[0005]</crossref></li>
</ul></p>
</ep-reference-list>
</ep-patent-document>
