<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE ep-patent-document PUBLIC "-//EPO//EP PATENT DOCUMENT 1.5.1//EN" "ep-patent-document-v1-5-1.dtd">
<!-- This XML data has been generated under the supervision of the European Patent Office -->
<ep-patent-document id="EP16176717B1" file="EP16176717NWB1.xml" lang="en" country="EP" doc-number="3264667" kind="B1" date-publ="20211006" status="n" dtd-version="ep-patent-document-v1-5-1">
<SDOBI lang="en"><B000><eptags><B001EP>ATBECHDEDKESFRGBGRITLILUNLSEMCPTIESILTLVFIROMKCYALTRBGCZEEHUPLSK..HRIS..MTNORS..SM..................</B001EP><B005EP>J</B005EP><B007EP>BDM Ver 2.0.12 (4th of August) -  2100000/0</B007EP></eptags></B000><B100><B110>3264667</B110><B120><B121>EUROPEAN PATENT SPECIFICATION</B121></B120><B130>B1</B130><B140><date>20211006</date></B140><B190>EP</B190></B100><B200><B210>16176717.3</B210><B220><date>20160628</date></B220><B240><B241><date>20160628</date></B241><B242><date>20200130</date></B242></B240><B250>en</B250><B251EP>en</B251EP><B260>en</B260></B200><B400><B405><date>20211006</date><bnum>202140</bnum></B405><B430><date>20180103</date><bnum>201801</bnum></B430><B450><date>20211006</date><bnum>202140</bnum></B450><B452EP><date>20210510</date></B452EP></B400><B500><B510EP><classification-ipcr sequence="1"><text>H04L   9/00        20060101AFI20210419BHEP        </text></classification-ipcr><classification-ipcr sequence="2"><text>G09C   1/00        20060101ALI20210419BHEP        </text></classification-ipcr></B510EP><B520EP><classifications-cpc><classification-cpc sequence="1"><text>H04L   9/003       20130101 LI20161213BHEP        </text></classification-cpc><classification-cpc sequence="2"><text>G09C   1/00        20130101 FI20180518BHEP        </text></classification-cpc><classification-cpc sequence="3"><text>H04L2209/046       20130101 LA20180518BHEP        </text></classification-cpc><classification-cpc sequence="4"><text>H04L2209/12        20130101 LA20180518BHEP        </text></classification-cpc></classifications-cpc></B520EP><B540><B541>de</B541><B542>VERFAHREN ZUM SCHUTZ EINER SUBSTITUTIONSOPERATION GEGEN EINE SEITENKANALANALYSE</B542><B541>en</B541><B542>A METHOD FOR PROTECTING A SUBSTITUTION OPERATION AGAINST A SIDE-CHANNEL ANALYSIS</B542><B541>fr</B541><B542>PROCÉDÉ DE PROTECTION D'UNE OPÉRATION DE SUBSTITUTION CONTRE UNE ANALYSE DE CANAUX AUXILIAIRES</B542></B540><B560><B561><text>EP-A1- 1 601 132</text></B561><B561><text>US-A1- 2005 259 814</text></B561><B561><text>US-A1- 2011 055 591</text></B561></B560></B500><B700><B720><B721><snm>WURCKER, Antoine</snm><adr><str>ESHARD
5 rue Laurent Fignon</str><city>33140 Villenave d' Ornon</city><ctry>FR</ctry></adr></B721><B721><snm>CLAVIER, Christophe</snm><adr><str>Le bourg de Lastours</str><city>87800 Rilhac Lastours</city><ctry>FR</ctry></adr></B721></B720><B730><B731><snm>ESHARD</snm><iid>101603968</iid><irf>100977EP</irf><adr><str>Technopole Bordeaux Montesquieu 
1 Allée Jean Rostand</str><city>33650 Martillac</city><ctry>FR</ctry></adr></B731></B730><B740><B741><snm>de Roquemaurel, Bruno</snm><sfx>et al</sfx><iid>100954449</iid><adr><str>OMNIPAT 
24 Place des Martyrs de la Résistance</str><city>13100 Aix en Provence</city><ctry>FR</ctry></adr></B741></B740></B700><B800><B840><ctry>AL</ctry><ctry>AT</ctry><ctry>BE</ctry><ctry>BG</ctry><ctry>CH</ctry><ctry>CY</ctry><ctry>CZ</ctry><ctry>DE</ctry><ctry>DK</ctry><ctry>EE</ctry><ctry>ES</ctry><ctry>FI</ctry><ctry>FR</ctry><ctry>GB</ctry><ctry>GR</ctry><ctry>HR</ctry><ctry>HU</ctry><ctry>IE</ctry><ctry>IS</ctry><ctry>IT</ctry><ctry>LI</ctry><ctry>LT</ctry><ctry>LU</ctry><ctry>LV</ctry><ctry>MC</ctry><ctry>MK</ctry><ctry>MT</ctry><ctry>NL</ctry><ctry>NO</ctry><ctry>PL</ctry><ctry>PT</ctry><ctry>RO</ctry><ctry>RS</ctry><ctry>SE</ctry><ctry>SI</ctry><ctry>SK</ctry><ctry>SM</ctry><ctry>TR</ctry></B840></B800></SDOBI>
<description id="desc" lang="en"><!-- EPO <DP n="1"> -->
<heading id="h0001">TECHNICAL FIELD</heading>
<p id="p0001" num="0001">The present invention relates to a method and device for protecting a circuit or a program against side channel analyses aiming to discover the value of a secret data handled by the circuit or program, and in particular a secret key used by an encryption or decryption algorithm to transform a message.</p>
<p id="p0002" num="0002">The present invention relates in particular to smart card integrated circuits or to hardware cryptographic components integrated onto mother boards of computers and other electronic and IT equipment (USB drives, TV decoders, game consoles, etc.) implementing a cryptographic algorithm such as AES (Advanced Encryption Standard). The present invention also relates to programs implementing such an algorithm, provided for being executed in a secure or non-secured environment.</p>
<p id="p0003" num="0003">More generally the present invention relates to circuits and software implementing an operation combining two data which are required to be kept hidden.</p>
<heading id="h0002">BACKGROUND</heading>
<p id="p0004" num="0004">Circuits implementing cryptographic algorithms can comprise a central processing unit (CPU), and possibly a circuit dedicated to cryptographic computing, for example a cryptographic coprocessor. These circuits may comprise thousands of logic gates that switch differently according to the operations executed. These switching operations create short variations in current consumption, for example of a few nanoseconds, and those variations can be measured. In particular, CMOS-type integrated circuits comprise logic gates that only consume current when they switch, i.e. when a logic node changes its state to 1 or to 0. Therefore, the current consumption depends on the data handled by the central processing unit and on its various peripherals: memory, data and address buses, cryptographic coprocessor, etc.<!-- EPO <DP n="2"> --></p>
<p id="p0005" num="0005">Furthermore, certain software programs using encryption or obfuscation techniques, such as the White-box Cryptography technique, may integrate secret data in such a way that it is very difficult to determine them by reverse engineering. Certain software programs may also receive a secret data from outside through a secure communication channel.</p>
<p id="p0006" num="0006">Such circuits may be subjected to so-called side channel-analysis attacks based on observing their current consumption, or their magnetic or electromagnetic radiation. Such attacks aim to discover secret data, in particular encryption keys. Current side channel attacks implement statistical analysis methods such as SPA ("Single Power Analysis"), DPA ("Differential Power Analysis"), CPA ("Correlation Power Analysis") or EMA ("ElectroMagnetic Analysis"). The SPA analysis (ref. [1]) normally only requires the acquisition of a single current consumption trace. It aims to obtain information about the activity of the integrated circuit by observing the part of the consumption trace corresponding to a cryptographic computation, since the current trace varies according to the operations executed and the data handled. Software may also undergo such side channel attacks during their execution by a circuit.</p>
<p id="p0007" num="0007">DPA (ref. [2]) and CPA (ref. [3]) analyses enable the key of an encryption algorithm to be found by acquiring numerous circuit consumption traces and by statistically analyzing these traces to find the target information. They are based on the premise that the consumption of a CMOS-type integrated circuit varies when a bit changes from 0 to 1 in a register or on a bus, and does not vary when a bit remains equal to 0, remains equal to 1 or changes from 1 to 0 (discharge of a stray capacitance of a MOS transistor). Alternatively, it can be considered that the consumption of a CMOS-type integrated circuit varies when a bit changes from 0 to 1 or changes from 1 to 0 and does not vary when a bit remains equal to 0 or remains equal to 1. This second hypothesis enables the conventional "Hamming distance" or "Hamming weight" functions to be used in order to develop a consumption model that does not require knowledge of the structure of the integrated circuit in order to be applicable. The DPA analysis involves amplifying this consumption difference thanks to statistical processing on numerous consumption traces, aiming to highlight a<!-- EPO <DP n="3"> --> measurement difference between two families of consumption traces distinguished according to formulated hypotheses.</p>
<p id="p0008" num="0008">The CPA analysis (ref. [3]) is based on a linear current consumption model and involves computing a correlation coefficient between, firstly, the consumption points measured that form the captured consumption traces and, secondly, an estimated consumption value computed from the linear consumption model and a hypothesis on the data to be discovered that is handled by the microcircuit and on the value of the encryption key.</p>
<p id="p0009" num="0009">The electromagnetic analysis (EMA) is based on the principle that an integrated circuit may send information in the form of near or far field electromagnetic radiation. Given that transistors and the wires connecting them emit electromagnetic signals when their state changes, these signals can be treated like the current consumption variation signals by an analysis such as one or other of the SPA, DPA and CPA analyses. An example of application of this analysis was made by Jean-Jacques Quisquater in 2001 (ref [4]).</p>
<p id="p0010" num="0010">Other side channel analyses exist, such as "Template analysis" (ref. [5]) and "Mutual Information Analysis" (MIA) (ref. [6]). All of the above-mentioned analyses are based on a time alignment of all the analyzed traces. In other words, all the measurements performed at a given time, for example from the time the execution of a command is activated by the circuit, must correspond to the same data handled by the algorithm.</p>
<p id="p0011" num="0011">The patent application N° <patcit id="pcit0001" dnum="FR1651443"><text>FR16 51443 filed by the Applicant on February 22, 2016</text></patcit> discloses a method for analysing traces representative of the activity of a circuit when the latter successively executes an operation on different input data. This method comprises extracting a part of each trace, and generating a histogram from each extracted trace part, by counting an occurrence number of each possible value appearing in each of the extracted parts of these traces. Partial results of the operation are then computed by applying the operation to each input data and to each possible value of a part of a secret key involved in the operation. Then, the method identifies for each possible part value of the secret key, all the input data which provide the same partial result. For each possible part value of the secret key, the occurrence numbers in the histograms, corresponding to the identified input data and the part value of the secret key are then added. The part of the<!-- EPO <DP n="4"> --> secret key can be determined by subjecting the added occurrence numbers to a statistical analysis. The statistical analysis assumes that if a value related to the secret key has leaked in the extracted parts of the traces, it can be highlighted by the added occurrence numbers.</p>
<p id="p0012" num="0012">It may be desirable to propose a protection for an integrated circuit or a software program against one or more of these side-channel analyses. To this purpose, it is known to mask a sensitive data using a random value, by combining the sensitive data with a randomly chosen mask by Exclusive OR (XOR) operations. For example, the following operation: <maths id="math0001" num=""><math display="block"><mi mathvariant="normal">C</mi><mo>=</mo><mi mathvariant="normal">A</mi><mo>⊕</mo><mi mathvariant="normal">B</mi><mo>,</mo></math><img id="ib0001" file="imgb0001.tif" wi="21" he="5" img-content="math" img-format="tif"/></maths> with A and B representing sensitive data, and "⊕" representing the XOR operator can be protected using mask values U and V randomly chosen: <maths id="math0002" num=""><math display="block"><msup><mi mathvariant="normal">A</mi><mo>′</mo></msup><mo>=</mo><mi mathvariant="normal">A</mi><mo>⊕</mo><mi mathvariant="normal">U</mi><mo>,</mo></math><img id="ib0002" file="imgb0002.tif" wi="22" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0003" num=""><math display="block"><msup><mi mathvariant="normal">B</mi><mo>′</mo></msup><mo>=</mo><mi mathvariant="normal">B</mi><mo>⊕</mo><mi mathvariant="normal">V</mi><mo>,</mo></math><img id="ib0003" file="imgb0003.tif" wi="21" he="5" img-content="math" img-format="tif"/></maths> <maths id="math0004" num=""><math display="block"><msup><mi mathvariant="normal">C</mi><mo>′</mo></msup><mo>=</mo><msup><mi mathvariant="normal">A</mi><mo>′</mo></msup><mo>⊕</mo><msup><mi mathvariant="normal">B</mi><mo>′</mo></msup><mo>=</mo><mi mathvariant="normal">C</mi><mo>⊕</mo><mi mathvariant="normal">U</mi><mo>⊕</mo><mi mathvariant="normal">V</mi><mo>,</mo></math><img id="ib0004" file="imgb0004.tif" wi="46" he="5" img-content="math" img-format="tif"/></maths> Therefore the resultant data C is protected as being not directly present in the computing unit performing its computation, but it can be deduced from the masked data C' and the mask values U and V, using the following equation: <maths id="math0005" num=""><math display="block"><mi mathvariant="normal">C</mi><mo>=</mo><msup><mi mathvariant="normal">C</mi><mo>′</mo></msup><mo>⊕</mo><mi mathvariant="normal">U</mi><mo>⊕</mo><mi mathvariant="normal">V</mi><mo>.</mo></math><img id="ib0005" file="imgb0005.tif" wi="29" he="5" img-content="math" img-format="tif"/></maths></p>
<p id="p0013" num="0013">According to other known protection methods, independent operations are performed in a random order and/or dummy operations are added in order to prevent analyses requiring a temporal alignment of operations of a data processing to analyze. Such methods appears to be efficient against a first order version of the above-described analyses, but not against a second order version of some of these analyses methods combining two analyses of distinct parts of a data processing and a correlating results of these two analyses.</p>
<p id="p0014" num="0014">The patent applications <patcit id="pcit0002" dnum="US2005259814A"><text>US 2005/259814</text></patcit> and <patcit id="pcit0003" dnum="EP1601132A"><text>EP 1 601 132</text></patcit> disclose countermeasures for protecting a substitution operation involving a substitution table S, by using a masked substitution table S' wherein each entry S[x] of the substitution table is masked using a respective random number r[x] (S'[x] = S[x]⊕r[x]). The patent application <patcit id="pcit0004" dnum="US2011055591A"><text>US 2011/055591</text></patcit> discloses another countermeasure for protecting a conversion operation using a table S by transferring the table into another table T such that<!-- EPO <DP n="5"> --> T[A⊕X] = S(M'⊕A)⊕Z, for all possible values of mask A, where M' is an input value masked by mask X, and Z is a randomly selected mask. However, these countermeasures does not resist to the above statistical analysis disclosed by the Applicant.</p>
<p id="p0015" num="0015">Therefore it is desirable to provide a protection method which is efficient against two-order known side-channel analyses.</p>
<heading id="h0003">SUMMARY</heading>
<p id="p0016" num="0016">A method is described for executing by a circuit an operation applied to an input data comprising at least one word. The method may include: generating an input set comprising data obtained by combining by Exclusive OR "XOR" operations the input data with each of first mask parameters in a first mask set, each first mask parameter in the first mask set comprising at least one word, the words in the first mask set having a same size and forming a first word subset comprising a single word from each first mask parameter of the first mask set and a same number of occurrences of all possible values of the words; applying the operation to each data in the input set to generate an output set comprising all data resulting from the application of the operation to one of the data in the input set, and providing the output set as an output of the operation, an output data resulting from applying the operation to the input data, being obtained by applying XOR operations to any one of the data in the output set and to a respective second mask parameter in a second mask set, each second mask parameter in the second mask set comprising at least one word, the words in the second mask set having a same size and forming a second word subset comprising a single word from each second mask parameter of the second mask set and a same number of occurrences of all possible values of the words.</p>
<p id="p0017" num="0017">According to an embodiment, the first mask set is generated using a random permutation function.</p>
<p id="p0018" num="0018">According to an embodiment, the operation is a substitution operation whereby an output data is selected in an input substitution table using the input data as an index, the method comprising: using masked substitution tables generated from the input substitution table and comprising one masked substitution table for each of the first mask parameters in the first mask set; and for each first mask parameter in the first mask set, selecting<!-- EPO <DP n="6"> --> one of the masked substitution table corresponding to the first mask parameter, and selecting a first data in the selected masked substitution table, using as an index a second data corresponding to the first mask parameter in the input set, the output set comprising all the first data selected in one of the masked substitution tables.</p>
<p id="p0019" num="0019">According to an embodiment, the masked substitution tables are generated by: generating the first mask set; generating a second mask set comprising a number of second mask parameters equal to the number of values in the input substitution table, each second mask parameter having a same number of occurrences in the second mask set; selecting once each mask parameter respectively in the first and second mask sets to form mask pairs, each comprising one of the first mask parameters and one of the second mask parameters; generating for each mask pair one of the masked substitution table, the generation of each of the masked substitution tables comprising: selecting each data in the input substitution table, and for each selected data: computing a masked data by applying XOR operations to the selected data and to the second mask parameter of the mask pair, computing a masked index by applying XOR operations to the first mask parameter of the mask pair and to an original index, and storing the masked data in the masked substitution table, the selected data being selected at the original index and the masked data being stored at the masked index, or the selected data being selected at the masked index and the masked data being stored at the original index.</p>
<p id="p0020" num="0020">According to an embodiment, the first and second mask parameters of each mask pair are identical, or the second mask set is deduced from the first mask set using a bijective function, combined or not with a shift function applied to ranks of the first mask parameters in the first mask set, or the second mask set is generated using a random permutation function, or the second mask set is generated so that a combination by XOR operations of each of the first mask parameters in the first mask set with a corresponding second mask parameter in the second mask set produces a third mask set comprising third mask parameters, each third mask parameter in the third mask set comprising at least one word, the words in the third mask set having a same size and forming a third word subset comprising a single word from each third mask parameter of the third mask set and a same number of<!-- EPO <DP n="7"> --> occurrences of all possible values of a word having the size of the words in the third word subset.</p>
<p id="p0021" num="0021">According to an embodiment, the values in the masked substitution tables are determined in a random order and/or stored in randomly selected positions in the masked substitution tables.</p>
<p id="p0022" num="0022">According to an embodiment, the computations of the data in the output set are performed in a random order and/or stored in randomly selected positions in the output set.</p>
<p id="p0023" num="0023">According to an embodiment, the method comprises detecting in the output set a computation error by: detecting two identical data in the output set; or applying XOR operations to each data in the output set and to a corresponding mask parameter in the first or second mask set, and searching in results of the XOR operations for a data different from an expected output data; or by combining together by XOR operations all the output data in the output set, the result of the combination being equal to zero when no computation error occurred.</p>
<p id="p0024" num="0024">Embodiments may also relate to a method for encrypting or decrypting an input data according to a cryptographic algorithm comprising a substitution operation, wherein the substitution operation is performed according to the above-defined method.</p>
<p id="p0025" num="0025">According to an embodiment, the cryptographic algorithm conforms with the Advanced Encryption Standard "AES" algorithm, the method comprising: generating an input set by applying XOR operations to each word of the input data, to each mask parameter of the first mask set, and to a word of a secret key corresponding the word of the input data; performing several intermediate rounds, each comprising: applying the substitution operation to each word in the input set, computing a masked round output set by applying XOR operations to each word of a round output set, to a respective mask parameter of the first mask set and to a respective mask parameter of the second mask set, and using the masked round output set as an input set for a next round; performing a last round comprising applying the substitution operation to each word in the input set; and providing an output set in which each word is masked by a respective mask parameter of the second mask set.<!-- EPO <DP n="8"> --></p>
<p id="p0026" num="0026">According to an embodiment, the first and second mask sets are generated so that a third mask set resulting from a combination by XOR operations of each mask parameter of the first mask set with a corresponding mask parameter of the second mask set, comprises only one occurrence of all possible values of a word of the input data.</p>
<p id="p0027" num="0027">According to an embodiment, the method comprises generating a random permutation of a number of elements corresponding to a number of words in the input set, using the permutation to select the words in an input set of an operation of the cryptographic algorithm, and applying the operation to the words of the input set in an order defined by the permutation.</p>
<p id="p0028" num="0028">According to an embodiment, a new random permutation is generated: during a first round of the cryptographic algorithm, and/or at each round of the cryptographic algorithm, and/or at a last round of the cryptographic algorithm, and/or before each operation of the cryptographic algorithm.<!-- EPO <DP n="9"> --></p>
<p id="p0029" num="0029">Embodiments may also relate to a circuit comprising a processor and configured to implement the above-defined methods.</p>
<p id="p0030" num="0030">According to an embodiment, the circuit comprises one circuit performing a substitution operation, for each masked substitution table.</p>
<p id="p0031" num="0031">According to an embodiment, the circuit comprises a coprocessor.</p>
<p id="p0032" num="0032">Embodiments may also relate to a device comprising a circuit asa above-defined, arranged on a medium.</p>
<p id="p0033" num="0033">Embodiments may also relate to a computer program product loadable into a computer memory and comprising code portions which, when carried out by a computer, configure the computer to carry out the steps of the methods as above-defined.</p>
<heading id="h0004">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p0034" num="0034">The method and/or device may be better understood with reference to the following drawings and description. Non-limiting and non-exhaustive descriptions are described with the following drawings. In the figures, like referenced signs may refer to like parts throughout the different figures unless otherwise specified.
<ul id="ul0001" list-style="none" compact="compact">
<li><figref idref="f0001">Figure 1</figref> represents a conventional architecture of a secure circuit;</li>
<li><figref idref="f0001">Figure 2</figref> is a block diagram of a circuit protected according to one embodiment;</li>
<li><figref idref="f0002">Figures 3 and 4</figref> are block diagrams of data illustrating a method for protecting data, according to different embodiments;</li>
<li><figref idref="f0003">Figure 5</figref> is a flowchart of a method for protecting data, according to one embodiment;</li>
<li><figref idref="f0003">Figure 6</figref> is a block diagram of data illustrating an operation protected according to one embodiment;</li>
<li><figref idref="f0004">Figure 7</figref> is a flowchart of an operation protected according to one embodiment;</li>
<li><figref idref="f0004">Figures 8A, 8B, 8C</figref> are block diagrams of substitution tables, illustrating a method for protecting a substitution table, according to various embodiments;</li>
<li><figref idref="f0005">Figures 9 and 10</figref> are flowcharts of a method for generating a protected substitution table, according to different embodiments;<!-- EPO <DP n="10"> --></li>
<li><figref idref="f0006">Figure 11</figref> is a flowchart of a substitution operation protected according to one embodiment;</li>
<li><figref idref="f0007">Figure 12</figref> is a block diagram of an AES encryption circuit protected according to one embodiment;</li>
<li><figref idref="f0008">Figure 13</figref> is a block diagram of a conventional mix column operation in the AES encryption algorithm,</li>
<li><figref idref="f0008">Figure 14</figref> is a block diagram of an AES mix column circuit of a protected AES encryption circuit, according to one embodiment;</li>
<li><figref idref="f0009">Figure 15</figref> is a flowchart of an XOR operation protected according to one embodiment;</li>
<li><figref idref="f0009">Figure 16</figref> represents a protected circuit, according to one embodiment.</li>
</ul></p>
<heading id="h0005">DETAILED DESCRIPTION</heading>
<p id="p0035" num="0035"><figref idref="f0001">Figure 1</figref> represents an example of a secure integrated circuit CT, for example arranged on a portable medium HD such as a plastic card or any other medium, or in a terminal such as a mobile terminal. The integrated circuit comprises a microprocessor PRC, an input/output circuit IOC, memories M1, M2, M3 coupled to the microprocessor by a data and address bus and, optionally, a cryptographic computation coprocessor CP1 or arithmetic accelerator, and a random number generator RGN. The memories can comprise a volatile memory M1, for example of RAM type ("Random Access Memory") containing volatile application data, a non-volatile memory M2, for example an EEPROM or Flash memory, containing non-volatile data and application programs, and possibly a read-only memory M3 (or ROM memory) containing the operating system of the microprocessor and constant data. The operating system can be also stored in the non-volatile memory.</p>
<p id="p0036" num="0036">The communication interface circuit IOC may be of contact type, for example according to the ISO/IEC 7816 standard, of contactless type by inductive coupling, for example according to the ISO/IEC 14443A/B or ISO/IEC 13693 standard, of contactless type by electrical coupling (UHF interface circuit), or of both contact and contactless type. The interface circuit IOC may also be coupled through a specific interface, to another circuit such as an NFC controller, or a main circuit of a terminal such as a mobile terminal or a connected object.<!-- EPO <DP n="11"> --></p>
<p id="p0037" num="0037">In some embodiments, the integrated circuit CT may be configured to execute operations of encrypting, decrypting or signing messages that are sent to it, by means of a cryptographic function. These cryptographic operations can be carried out by the processor PRC of the circuit CT or partially or totally entrusted by the processor PRC to the coprocessor CP1.</p>
<p id="p0038" num="0038">It is proposed here to protect an operation, e.g. an operation in a cryptographic algorithm against side channel analyses. In this context, the operation receives an input data, and provides an output data as a function of the value of the input data. A protection according to one embodiment involves executing the operation to be protected for all the data of an input set of data, each data in the input set comprising at least one word, the words in the input set having the same size and forming a word subset or column comprising a single word from each data in the input set and a same number of occurrences of all the possible words in relation with the size of the words. Thus the input set comprises the input data required to be processed by the operation. The result provided by the operation is an output set of data in which each data comprises at least one word, the words in the output set having the same size and forming a word subset or column comprising a single word from each data in the output set and the same number of occurrences of all the possible words in relation with the size of the words.</p>
<p id="p0039" num="0039">In the following, "word" designates a group of bits in a data, and "word column" designates a subset in a data set comprising a single word from all data in the data set, all the words in the word column having the same size. The words forming a word column are not necessary aligned, i.e. do not necessary comprises the same bit positions in the data of the data set.</p>
<p id="p0040" num="0040"><figref idref="f0001">Figure 2</figref> represents a circuit CT1 receiving an input data X to be processed and serially performing several operations OP1, OP2, ... OPn applied to the input data X. According to an embodiment, the circuit CT1 comprises several circuits OC each serially performing the operations OP1, OP2, ... OPn. Each circuit OC receives the input data X and a respective input mask parameter u of an input mask parameter set. Thus the circuit CT1 comprises MX+1 circuits OC respectively receiving masks equal to 0, 1 ... MX, MX representing the greatest possible value of the mask parameter u when considering the size in bits of the mask parameter. Each circuit OC<!-- EPO <DP n="12"> --> comprises a circuit XG applying Exclusive OR operations (XOR) to the input data X and to the mask parameter u (=0 or 1, ... or MX). In each circuit OC, the data X ⊕ u (u = 0, ... MX) provided by the circuit XG of the circuit OC is applied to an input of the operation OP1 of the circuit OC. The operations OP1-OPn are such that: <maths id="math0006" num="(1)"><math display="block"><mi>OPn</mi><mfenced separators=""><mo>…</mo><mi>OP2</mi><mfenced separators=""><mi>OP1</mi><mfenced separators=""><mi mathvariant="normal">X</mi><mo>⊕</mo><mi mathvariant="normal">u</mi></mfenced></mfenced><mo>…</mo></mfenced><mo>=</mo><mi>CX</mi><mo>⊕</mo><mi mathvariant="normal">v</mi><mfenced><mi mathvariant="normal">u</mi></mfenced><mo>,</mo></math><img id="ib0006" file="imgb0006.tif" wi="109" he="5" img-content="math" img-format="tif"/></maths> where "⊕" represents the XOR operator, v(u) represents an output mask parameter depending on the input mask parameter u and CX is the result of the operations OP1-OPn applied to the input data X: <maths id="math0007" num="(2)"><math display="block"><mi>CX</mi><mo>=</mo><mi>OPn</mi><mfenced separators=""><mo>…</mo><mi>OP2</mi><mfenced separators=""><mi>OP1</mi><mfenced><mi mathvariant="normal">X</mi></mfenced></mfenced><mo>…</mo></mfenced></math><img id="ib0007" file="imgb0007.tif" wi="110" he="5" img-content="math" img-format="tif"/></maths> Thus each circuit OC provides an output data equal to CX⊕v(u) (u=0, 1, ..., or MX). Therefore, the circuit CT1 provides an output set PCX comprising the output data CX⊕v(0), CX⊕v(1), ... CX⊕v(u), ... CX⊕v(MX). The operations OP1-OPn can be adapted such that the output data corresponding to the input data X⊕u provided by the operations OP1-OPn is equal to CX⊕v(u) for each value of the mask parameter u (0-MX) and the set of output mask parameters v(u) with u=0 to MX, comprises a same number of occurrences of all possible values when considering the size of the output masks parameters v(u). Each output mask parameter v(u) can be equal to the corresponding input mask parameter u. According to an embodiment, the computations of the output data in the output set PCX may be performed in a random order, and/or stored in a random order. In this way, the different values of the mask parameter u are respectively applied to the circuits OC in a random order. Thus the circuit OC of rank k in the circuit CT1 receives an input mask parameter u = U[k], U being a mask set generated by random permutation of all possible numbers between 0 and MX. In a same way, the circuit OC of rank 0 in the circuit CT1 receives a mask parameter U[0], and the circuit OC of rank MX in the circuit CT1 receives an input mask parameter U[MX].</p>
<p id="p0041" num="0041">In addition, the circuits OC are independent from each other and the computation of each of the data CX⊕v(u) of the output set PCX is independent from the computations of the other data of the output set. Therefore the operations OP1-OPn in all the circuits OC can be performed in any order, provided that the order of the operations within each circuit OC is respected.<!-- EPO <DP n="13"> --></p>
<p id="p0042" num="0042">Unlike the protections of prior art involving hiding the operation to be protected in a flood of identical operations applied to random data and thus uncorrelated from the required input data of the operation to be protected, the idea here is to execute the operation on other data not chosen randomly. Indeed, such other data are correlated with the required input data insofar as the input set formed of such other data and of the required data to be processed is such that each data in the input set comprises at least one word, the words in the input set having the same size and forming a word subset or column comprising a single word from each data in the input set and a same number of occurrences of all possible values of one word in relation the word size. The words forming a word column are not necessary aligned, i.e. do not necessary comprises the same bit positions in the data of the data set.. Since the processed input data are not randomly chosen, statistical analyses cannot extract a signal reflecting the processing of the required input data from a signal including a random part. The different mask parameters could have unpredictable positions in the mask set, but known by the circuit performing the operation.</p>
<p id="p0043" num="0043">It could be observed that if the circuit CT1 performing the operations OP1-OPn undergoes an error such as one caused by a successful fault injection, the value of at least one word of the data in the output set PX is changed. If only one word is changed, each word rank of the data in the output set does not comprise all possible values of the words, but comprises two identical words, the word having a changed value having necessary the value of another word in the same word rank in the output set. Thus such a fault injection can be detected by looking for two data in the output set having a same value. If two data are changed, the fault injection would not be detected only when the values of these two data are swapped, which has a very low probability of occurrence. Thanks to the property of the XOR operation, an error can be easily detected by combining together by XOR operations all the output data in the output set PCX, the result of this combination being equal to zero when the output set comprises at least one word column comprising all possible values of the words with a same number of occurrences. Another way to detect a fault injection is to add each word in the output set with the corresponding mask parameter by XOR operations.<!-- EPO <DP n="14"> --> The results of the XOR operations should all be equal to a word of the expected output data of the operation.</p>
<p id="p0044" num="0044"><figref idref="f0002">Figure 3</figref> represents an example of the input data X1 which is combined by the operation XG of the circuits OC with a mask set U comprising mask parameters U[0..MX], MX being an index having the greatest possible value of the input data X1 taking into account the size in bit number of the data X1. The result provided by the operation XG is an output set PX1, for example arranged in a table, comprising the data P1[0], P1[1], ... P1[m], ... P1[MX], where each data P1[m] is equal to X1 ⊕ U[m]. The data in the output set PX1 can be arranged and/or computed in a random order.</p>
<p id="p0045" num="0045"><figref idref="f0002">Figure 4</figref> represents another example of an input data X2 comprising several words X2[0], X2[1], ... X2[b], ... X2[BX]. According to an embodiment, each word of the input data X2 is combined by the operation XG of the circuits OC with a respective mask parameter U[0], ... U[MX] of the mask set U, where each mask parameters U[0], ... U[MX] has the size of one word, and the index MX corresponds to the greatest possible value of one word of the input data X2 or of the mask parameters U[m], taking into account the size in bit number of each of these words. The result provided by the operation XG is an output set PX2, for example arranged in a table PX2[0..MX,0..BX] comprising data P2[m,b] = X2[b]⊕U[m], where m varies between 0 and MX and b varies between 0 and BX. The data in the output set PX2 can be arranged and/or computed in a random order.</p>
<p id="p0046" num="0046"><figref idref="f0003">Figure 5</figref> represents steps S1 to S8 of a procedure for generating the input set PX2 from the input data P2 comprising BX+1 words to be applied to the operation XG of the circuits OC, according to one embodiment. Steps S1 to S7 are first successively carried out. At step S1, the input data X2 is provided to the procedure. At step S2, two permutations U and PM in the form of tables are generated randomly using a random permutation generation function RNP receiving extremum values 0 and MX for the permutation U and 0 and KX for the permutation PM. The permutation U comprises MX+1 values between 0 and MX, where MX+1 = 2<sup>P</sup>, P being the number of bits of each of the words X2[b] forming the input data X2. The permutation PM comprises (MX+1)(BX+1) values between 0 and the maximum value KX equal to (MX+1)(BX+1)-1. At step S3, an index k is initialized to zero (0). At step S4, indexes m and b are computed from the<!-- EPO <DP n="15"> --> index k by considering that the permutation PM is a two-entry table comprising rows of BX+1 elements and columns of MX+1 elements. Thus the index m can be computed as being the integer part INT() of the division of the value PM[k] by (BX+1), and the index b can be computed as being the difference between the value PM[k] and the product of the index m by (BX+1). Step S5 computes the table elements P2 of the two-entry table PX2. Each table element P2[m,b] at indexes m and b is set to the result X2[b]⊕ U[m] of XOR operations applied to the words X2[b] and U[m]. Thanks to the use of the random permutation PM, the words P2[m,b] are computed in a random order and arranged in the table PX2 also in a random order. At step S6, the index k is incremented by one (1). At step S7, the index k is compared with the maximum value KX. If the index k is greater than the value KX, step S8 is carried out, otherwise steps S5 to S7 are again carried out for a new iteration. At step S8, the input set PX2 is completely defined and provided as output of steps S1 to S7.</p>
<p id="p0047" num="0047">The generation and use of the permutation PM can be omitted if the data in the table PX2 can be computed and/or stored in a deterministic order. In addition, the large and costly permutation PM can be replaced by two permutations of MX+1 elements and BX+1, respectively, the elements of which are read within two nested loops, one for selecting an element of a first one of the two permutations and, one for selection an element of the other one of the two permutations.</p>
<p id="p0048" num="0048">The operations OP1-OPn can comprise an operation combining the input data X1 to another data by XOR operations. <figref idref="f0003">Figure 6</figref> illustrates an example of one operation OPk of the operations OP1-OPn, combining with each other data X3 and X4. The data X3 results from a previous operation among the operations XG, OP1-OPn, and thus has the form of an output set PX3 (like the output set PX2) comprising words P3[0,0], ... P3[MX,BX]. The data X4 has the same size as the data X3, and thus comprises words X4[0], ... X4[b], ..., X4[BX]. The result provided by the operation OPk is an output set PX5, for example arranged in a two-entry table, comprising the data P5[m,b], where m varies between 0 and MX and b varies between 0 and BX. Thus each output data P5[m,b] is equal to OPk(P3[m,b], X4[b]). The data in the output set PX5 can be arranged and/or computed in a random order. The operation OPk is for example an XOR operation.<!-- EPO <DP n="16"> --></p>
<p id="p0049" num="0049"><figref idref="f0004">Figure 7</figref> represents steps S11 to S18 of a procedure for generating the output set PX5 resulting from the application of an operation to the output set PX3 and the data X4, according to one embodiment. Steps S11 to S17 are first successively carried out. At step S11, the output set PX3 and the input data X4 comprising BX+1 words are input. At step S12, a permutation PM in the form of a table is randomly generated using the function RNP, the permutation PM comprising (MX+1)(BX+1) values between 0 and a maximum value KX=(MX+1)(BX+1)-1, where MX+1 = 2<sup>P</sup>, P being the number of bits of each of the words X4[b] forming the input data X4. At step S13, an index k is initialized to zero (0). At step S14, indexes m and b are computed from the index k by considering that the permutation PM is a two-entry table comprising rows of BX+1 elements and columns of MX+1 elements. Thus the index m can be computed as being the integer part of the division of the value PM[k] by (BX+1), and the index b can be computed as being the difference between the value PM[k] and the product of the index m by (BX+1). Step S15 computes output data P5[m,b] of the output set PX5 in the form of a two-entry table. Each output data P5[m,b] at indexes m and b is set to the result OPk(P3[m,b],X4[b]) of the operation OPk applied to the words P3[m,b] and X4[b]. Thanks to the use of the permutation PM, the output data P5[m,b] in the table PX5 are computed in a random order and arranged in the table PX5 also in a random order. At step S16, the index k is incremented by one (1). At step S17, the index k is compared with the maximum value KX. If the index k is greater than the value KX, step S18 is carried out, otherwise steps S15 to S17 are again carried out for a new iteration. At step S18, the output set PX5 is completely defined and provided as output of steps S11 to S17.</p>
<p id="p0050" num="0050">In the example of step S15 in <figref idref="f0004">Figure 7</figref>, the operation OPk is an XOR operation. Thus the output data P5[m,b] in the output set PX5 are equal to P3[m,b], ⊕X4[b], for each indexes m (= 0..MX), and for each index b (= 0..BX). It can be observed that each data P5[m] (of size BX+1) in the output set PX5 is the result of the operation P3[m]⊕X4 where P3[m] = X1⊕U[m]. If CX1 = X1⊕X4, then P5[m] = X1⊕X4⊕U[m] = CX1⊕U[m]. Therefore the mask U[m] applied to the input value X1 can be retained throughout the computations performed by the operations OPi in the circuits OC. The<!-- EPO <DP n="17"> --> operation OPk can be any other operation than XOR, provided that this operation is performed bitwise and is reversible or bijective.</p>
<p id="p0051" num="0051">Here again, it is not necessary to compute the data in the table PX5 in a random order or to store them in a random order. In such cases, the use of the permutation PM is not mandatory.</p>
<p id="p0052" num="0052">It may be further desirable to have among the operations OPi a substitution operation using a substitution or lookup table. Such a substitution operation receives an input data, and provides an output data read in the table using the input data as an index. According to an embodiment, a masked substitution table SBM is computed using the following equation: <maths id="math0008" num="(3)"><math display="block"><mi>SBM</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">i</mi><mo>⊕</mo><mi mathvariant="normal">U</mi></mfenced><mo>=</mo><mi>SB</mi><mfenced open="[" close="]"><mi mathvariant="normal">i</mi></mfenced><mo>⊕</mo><mi mathvariant="normal">V</mi><mo>,</mo></math><img id="ib0008" file="imgb0008.tif" wi="109" he="5" img-content="math" img-format="tif"/></maths> where SB is the substitution or lookup table, i is an index for selecting a value SB[i] in the table SB and U and V are input and output masks respectively. <figref idref="f0004">Figure 8A</figref> represents the substitution table SB and the masked table SBM derived from the table SB by applying equation (2) to each value SB[i] in the table SB. Thus, the result of the substitution operation applied to a masked input data D⊕U is an output data masked by the known output mask V. As illustrated in <figref idref="f0004">Figure 8B</figref>, the masked substitution table SBM can also be obtained by applying the following equation: <maths id="math0009" num="(4)"><math display="block"><mi>SBM</mi><mfenced open="[" close="]"><mi mathvariant="normal">i</mi></mfenced><mo>=</mo><mi>SB</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">i</mi><mo>⊕</mo><mi mathvariant="normal">U</mi></mfenced><mo>⊕</mo><mi mathvariant="normal">V</mi><mo>,</mo></math><img id="ib0009" file="imgb0009.tif" wi="109" he="5" img-content="math" img-format="tif"/></maths> to each value SB[i] of the substitution table SB.</p>
<p id="p0053" num="0053">Therefore, the expected output data CX1 can be deduced from the output data provided by the circuit OC processing the masked input data X⊕ U. However the output data CX1 cannot be deduced from the output data provided by the other circuits OC since in these other circuits, the input data applied to the substitution operation is not combined with the mask parameter U used to generate the mask substitution table according to equation (3) or (4).</p>
<p id="p0054" num="0054">According to an embodiment, a masked substitution table SBM[u] is computed for each circuit OC, such that: <maths id="math0010" num="(5)"><math display="block"><mi>SBM</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">u</mi><mo>,</mo><mi mathvariant="normal">D</mi><mo>⊕</mo><mi mathvariant="normal">u</mi></mfenced><mo>=</mo><mi>SB</mi><mfenced open="[" close="]"><mi mathvariant="normal">D</mi></mfenced><mo>⊕</mo><mi mathvariant="normal">v</mi><mfenced><mi mathvariant="normal">u</mi></mfenced><mo>,</mo></math><img id="ib0010" file="imgb0010.tif" wi="110" he="5" img-content="math" img-format="tif"/></maths> for each value of the mask parameter u (0 ... n), where v(u) is a mask parameter corresponding to the value of the mask parameter u, such that v(u1)≠v(u2) for all mask parameters u1, u2 with u1≠u2. Therefore, each output data of the substitution operation performed by the circuits OC is<!-- EPO <DP n="18"> --> equal to the output data CX masked by the mask parameter v(u) (= CX⊕ v(u)). The substitution table SB and the masked substitution table SBM are represented in <figref idref="f0004">Figure 8C</figref>. The substitution table SB is a single-entry table comprising MX+1 values SB[0], SB[1], ... SB[MX]. The masked substitution table SBM is a two-entry table comprising one single-entry table SBM[u] of the size of the table SB for each mask value u. Thus the masked substitution table SBM comprises MX+1 single-entry tables of the size of the table SB.</p>
<p id="p0055" num="0055"><figref idref="f0005">Figure 9</figref> represents steps S21 to S30 of a procedure for computing a masked substitution table SBM from the substitution table SB, according to one embodiment. Steps S21 to S27 are first successively carried out. At step S21, the substitution table SB is input. At step S22, two permutations U and V in the form of tables are randomly generated using the function RNP. The permutations U and V comprise MX+1 values between 0 and MX, where MX+1 is the amount of values in the table SB. At steps S23 and S24, respectively, indexes i and j are initialized to zero (0). Step S25 computes the table values SBM[i,j] of the two-entry table SBM. Each table value SBM[i,j] at indexes i and j is set to the result SB[j⊕U[i]]⊕V[i] of XOR operations applied to the data SB[j⊕U[i]] and V[i]. At step S26, the index j is incremented by one (1). At step S27, the index j is compared with the maximum value MX. If the index j is greater than the value MX, step S28 is carried out, otherwise steps S25 to S27 are again carried out for a new iteration. At step S28, the index i is incremented by one (1). At step S29, the index i is compared with the maximum value MX. If the index i is greater than the value MX, step S30 is carried out, otherwise steps S24 to S27 are again carried out for a new iteration. At step S30, the masked table SBM is completely defined and provided as output of steps S21 to S29. Thus each column i of the masked table SBM corresponds to the substitution table SB masked using a particular couple of masks (U[i], V[i]).</p>
<p id="p0056" num="0056"><figref idref="f0005">Figure 10</figref> represents steps S31 to S38 of a procedure for computing the masked substitution table SBM from the substitution table SB, according to another embodiment. Steps S31 to S37 are first successively carried out. At step S31, the substitution table SB is input. At step S32, three permutations U, V and PM in the form of tables are randomly generated using the function RNP. The permutations U and V comprise MX+1 values between 0 and MX, where MX+1 is the amount of values in the table SB. The<!-- EPO <DP n="19"> --> permutation PM comprises (MX+1)(MX+1) values between 0 and a maximum value KX equal to (MX+1)(MX+1)-1. At step S33, an index k is initialized to zero (0). At step S34, indexes i and j are computed from the index k by considering that the permutation PM is a two-entry table comprising rows of MX+1 elements and columns of MX+1 elements. Thus the index i can be computed as being the integer part of the division of the value PM[k] by (MX+1), and the index j can be computed as being the difference between the value PM[k] and the product of the index i by (MX+1). Step S35 computes the table values SBM[i,j] randomly selected in the table SBM, using the random permutation PM. Each value SBM[i,j] at indexes i and j in the table SBM is set to the result SB[[j⊕U[i]]⊕V[i] of an XOR operation applied to the data SB[j⊕U[i]] and V[i], the mask parameters U[i] and V[i] being also randomly selected in the tables U and V since the indexes i and j are defined using the permutation PM. At step S36, the index k is incremented by one (1). At step S37, the index k is compared with the maximum value KX. If the index k is greater than the value KX, step S38 is carried out, otherwise steps S35 to S37 are again carried out for a new iteration. At step S38, the masked table SBM is completely defined and provided as output of steps S31 to S37.</p>
<p id="p0057" num="0057">It should be observed that in a process comprising the procedures of <figref idref="f0003">Figures 5</figref> and <figref idref="f0005">9 or 10</figref>, a single permutation U is generated and used at steps S5 and S25 or S35.</p>
<p id="p0058" num="0058"><figref idref="f0006">Figure 11</figref> represents steps S41 to S48 of a procedure performing a protected substitution operation, using the masked substitution table SBM, according to one embodiment. Steps S41 to S47 are first successively carried out. At step S41 the masked substitution table SBM and a protected data in the form of an input set PX6 are input. The input set PX6 comprises words P6[0,0], ... P6[MX,BX]. At step S42, one permutation PM in the form of a table is randomly generated using the function RNP. The permutation PM comprises (MX+1)(BX+1) values between 0 and the maximum value KX equal to (MX+1)(BX+1)-1. At step S43, an index k is initialized to zero (0). At step S44, indexes m and b are computed as in step S4. Step S45 computes the output data P7[m,b] randomly selected in the output set PX7, using the random permutation PM. Each output data P7[m,b] at indexes m and b is set to the value of the element SBM[m,P6[m,b]] selected in the table SBM[m] at<!-- EPO <DP n="20"> --> an index defined by the output data P6[m,b] selected in the table PX6 at indexes m and b. At step S46, the index k is incremented by one (1). At step S47, the index k is compared with the maximum value KX. If the index k is greater than the value KX, step S48 is carried out, otherwise steps S44 to S47 are again carried out for a new iteration. At step S48, the output set PX7 is completely defined and provided as output of steps S41 to S47.</p>
<p id="p0059" num="0059">According to an embodiment, the number of the possible masked substitution tables SBM obtained from a same substitution table SB, is reduced by choosing identical tables for the mask tables U and V. Thus the equations (3) and (4) become: <maths id="math0011" num="(6)"><math display="block"><mi>SBM</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">D</mi><mo>⊕</mo><mi mathvariant="normal">U</mi></mfenced><mo>=</mo><mi>SB</mi><mfenced open="[" close="]"><mi mathvariant="normal">D</mi></mfenced><mo>⊕</mo><mi mathvariant="normal">U</mi><mo>,</mo></math><img id="ib0011" file="imgb0011.tif" wi="109" he="5" img-content="math" img-format="tif"/></maths> and <maths id="math0012" num="(7)"><math display="block"><mi>SBM</mi><mfenced open="[" close="]"><mi mathvariant="normal">D</mi></mfenced><mo>=</mo><mi>SB</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">D</mi><mo>⊕</mo><mi mathvariant="normal">U</mi></mfenced><mo>⊕</mo><mi mathvariant="normal">U</mi><mo>,</mo></math><img id="ib0012" file="imgb0012.tif" wi="109" he="5" img-content="math" img-format="tif"/></maths> The operations performed at steps S25 and S35 become: <maths id="math0013" num="(8)"><math display="block"><mi>SBM</mi><mfenced open="[" close="]"><mi mathvariant="normal">i</mi><mi mathvariant="normal">j</mi></mfenced><mo>=</mo><mi>SB</mi><mfenced open="[" close="]" separators=""><mi mathvariant="normal">j</mi><mo>⊕</mo><mi mathvariant="normal">U</mi><mfenced open="[" close="]"><mi mathvariant="normal">i</mi></mfenced></mfenced><mo>⊕</mo><mi mathvariant="normal">U</mi><mfenced open="[" close="]"><mi mathvariant="normal">i</mi></mfenced></math><img id="ib0013" file="imgb0013.tif" wi="109" he="5" img-content="math" img-format="tif"/></maths> In this way, the number of possible masked substitution tables is reduced by a factor (MX+1), which enables all the possible masked tables to be precomputed and stored in a memory, instead of being computed and stored each time new mask tables U and V are generated.</p>
<p id="p0060" num="0060">It turns out that the generation of a random permutation has a non-negligible cost in terms of amount of required computation operations. According to one embodiment, the generation of one of the permutations U and V at steps S22, S32 is avoided by computing the values of the mask table V as a function of the values of the mask U, or inversely. For example each value V[m] of the mask table V is chosen equal to U[m]⊕K, K being a constant parameter which may be randomly chosen when the mask table U is generated. According to another example, each value V[m] is chosen equal to U[m⊕K1]⊕K2, K1, K2 being constant parameters which may be randomly chosen when the mask table U is generated. The mask table V can also be randomly generated and the mask table U determined in a same way as a function of the values in the table V.</p>
<p id="p0061" num="0061">It should be noted that in some applications the number of different values in the substitution table SB can be smaller than its number of values. Thus each value in the table SB has a same number of occurrences greater than one. In such a case, the mask table V is generated so as to comprise the same number of occurrences of the same values in the table SB.<!-- EPO <DP n="21"> --></p>
<p id="p0062" num="0062">All the operations performed in the AES (Advanced Encryption Standard) algorithm either implemented by software or in hardware can be protected using the procedures previously disclosed. The architecture presented in <figref idref="f0001">Figure 2</figref> can be applied to AES algorithm. <figref idref="f0007">Figure 12</figref> represents a cryptographic calculation circuit OC1 as an example of the circuit OC in the <figref idref="f0001">Figure 2</figref>, the OC1 implementing the AES algorithm for encrypting a data. For further details about the AES, the document "<nplcit id="ncit0001" npl-type="s"><text>Advanced Encryption Standard FIPS PUB 197" published on 26th November 2001</text></nplcit> can be referred to. The cryptographic calculation circuit OC1 is comprised in a circuit CT2 comprising several cryptographic calculation circuits OC1, each receiving a data X1 to be processed and a mask parameter index m, and supplying a resultant data CX1 combined by XOR operations with a mask parameter V[m] corresponding to the mask parameter index m.</p>
<p id="p0063" num="0063">The circuit OC1 comprises circuits XG1, XG2, XG3 performing XOR operations, a substitute calculation circuit SBB, a row-based circular permutation calculation circuit SHR, a multiplexer MUX and a column-based permutation calculation circuit MXC. The circuits SBB, SHR, and MXC are compliant with the AES. The circuit XG1 receives both the data X1 to be encrypted and a derived key KT[0] at an index 0 in a round key table KT supplied to the circuit OC1. The output of the circuit XG1 is processed by the circuits SBB and SHR. The output of the circuit SHR is transmitted by the multiplexer MUX to the circuit MXC at rounds 0 to R-1 of the AES algorithm, and at a last round R, to the circuit XG3 receiving at another input a last derived key KT[R] at an index R in the round key table KT. At the rounds 0 to R-1, the output of the circuit MXC is processed by the circuit XG2 receiving a derived key KT[r] (r = 1, ..., R-1) read in the table KT. The output of the circuit XG2 is processed by the circuits SBB and SHR. When a certain number (R-1) of calculation rounds are performed (10, 12 or 14, in accordance with the AES) by the chain comprising the circuits SBB, SHR, MXC, XG2, the multiplexer MUX is actuated to provide the output of the circuit SHR to the input of the circuit XG3 which provides the output data CX1.</p>
<p id="p0064" num="0064">During a first calculation round, the data X1 is processed by the circuit XG1 which adds to it the first derived key KT[0] by XOR operations. The circuit XG1 provides the resulting data X1⊕K[0] which is successively<!-- EPO <DP n="22"> --> processed by the circuits SBB, SHR, MXC and XG2. Then the circuit XG2 combines the data provided by the circuit MXC with a derived key KT[r] (r = 1, ..., R-1). The circuits SBB, SHR, MXC and XG2 are successively activated for several rounds of the AES algorithm. The circuits SBB, SHR and XG3 are activated at a last round R of the AES algorithm. At each round j, a round key KT[r] (r = 0, ..., R) is read in the table KT.</p>
<p id="p0065" num="0065">The substitute calculation circuit SBB is generally implemented using a substitution table receiving an input data used as an index to select an output data in the substitution table. The substitution table comprises 256 bytes, and each byte of the data to be processed by the circuit SBB is used as an index to select a byte in the substitution table. The permutation calculation circuit SHR can be placed before the substitute calculation circuit SBB.</p>
<p id="p0066" num="0066">According to one embodiment, the circuit OC1 comprises circuits XG4 and XG5 performing XOR operations with mask parameters U[m] and U[m] ⊕V[m] respectively (with m = 0, ... MX). The circuit XG4 receives the mask table U[0..MX] comprising MX+1 mask parameters having the size of one word (e.g. one byte), and the input data X1[0..BX] of BX+1 words (16 bytes, BX = 15) of the size of the mask parameters, and performs XOR operations with the mask parameters U[m] for each word of the size of the mask parameter included in the input data X1. The circuit XG4 provides to the circuit XG1 a masked input data, noted X1⊕U[m] for each value of the index m. Thus, the circuit XG4 can implement the steps S1 to S8 of <figref idref="f0003">Figure 5</figref>, XOR operations being performed for each mask parameter U[m] in the mask table U[0..MX], a randomly selected permutation of 256 values between 0 and 255. The result provided by the circuit XG4 to the circuit XG1 is the output set PX10 having the form of the output set PX2[0..MX,0..BX] (<figref idref="f0002">Figures 4</figref>, <figref idref="f0003">5</figref>). The operation performed by the circuits XG1, XG2 and XG3 is realized according to <figref idref="f0003">Figure 6</figref>, by executing the steps S11 to S18 (<figref idref="f0004">Figure 7</figref>). The input set of the circuit XG1 is the output set PX10 provided by the circuit XG4, and having the form of the input set PX3 in <figref idref="f0004">Figure 7</figref>. The input data X4 in <figref idref="f0004">Figure 7</figref> is the round key KT[0,0..BX] for the circuit XG1, the round key KT[r,0..BX] (r = 1, ... R-1) for the circuit XG2, and the round key KT[R,0..BX] for the circuit XG3, each round key in the table KT comprising BX+1 bytes. The circuit XG1<!-- EPO <DP n="23"> --> provides an output set PX20[0..MX,0..BX] having the form of the output set PX5[0..MX,0..BX] (<figref idref="f0004">Figure 7</figref>).</p>
<p id="p0067" num="0067">The substitution table provided to the circuit SBB is the two-entry table SBM[0..MX,0..MX] generated by executing the steps of <figref idref="f0005">Figure 9 or 10</figref>, and obtained with the masks tables U and V, the mask table U being the same as the one input to the circuit XG4. The operation performed by the circuit SBB comprises the steps S41 to S48 as disclosed in <figref idref="f0006">Figure 11</figref>, in which the input set PX6 is the output set PX20 provided by the circuit XG1. The circuit SBB provides an output set PX3j (PX30 for the round 0) in the form of the output set PX7[0..MX,0..BX] (<figref idref="f0006">Figure 11</figref>).</p>
<p id="p0068" num="0068">The circuit SHR is designed to process separately each data PX3j[m,0..BX] (m = 0, ... MX) in the output set PX3j. The circuit SHR provides an output set PX4j[0..MX,0..BX] comprising a table PX4j[m,0..BX] for each value (0 to MX) of the index m. The circuit MXC provides an output set PX5j[0..MX,0..BX].</p>
<p id="p0069" num="0069"><figref idref="f0008">Figure 13</figref> represents the circuit MXC. The circuit MXC combines an output data X6 of the circuit SHR with a coefficient matrix MC of 4x4 elements. To this purpose, the output data X6 is organized into a matrix format of 4x4 elements x0 to x15, each of these elements corresponding to the bytes of the data X6 which is encoded on 128 bits. The elements of the matrix X6 are combined together by XOR operation circuit XG6 with the elements of the matrix MC to produce a resultant matrix TR of 4x4 elements where each element has the following form: <maths id="math0014" num="(9)"><math display="block"><mi mathvariant="normal">a</mi><mo>⋅</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mi mathvariant="normal">i</mi><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">b</mi><mo>⋅</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mi mathvariant="normal">i</mi><mo>+</mo><mn>1</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">c</mi><mo>⋅</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mi mathvariant="normal">i</mi><mo>+</mo><mn>2</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">d</mi><mo>⋅</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mi mathvariant="normal">i</mi><mo>+</mo><mn>3</mn><mo>&gt;</mo><mo>,</mo></math><img id="ib0014" file="imgb0014.tif" wi="109" he="5" img-content="math" img-format="tif"/></maths> where a, b, c, d (= 1, 2 or 3) are the elements of one line of the matrix MC and i is equal to 0, 4, 8 and 12. According to AES, the operation 2·x is performed by using the operation LS1(x) if x is lower than 128 (when the most significant bit (MSB) of x equals 0) and the operation LS1(x)⊕0x1B if x is greater or equal to 128 (when the MSB of x equals 1), LS1(x) representing a shift to the left by one bit in the byte x. The operation 3·x is performed using the operation 2·x⊕x.</p>
<p id="p0070" num="0070">Since each byte b of the input data X6 is represented by one table PX4j[0..MX,b], the circuit MXC performs 3x16 XOR operations for each byte in the output set PX4j. One more XOR operations may be necessary to<!-- EPO <DP n="24"> --> perform the operation 3·x. However in some implementations of AES algorithm, the operations 2·x and 3·x are implemented by lookup tables.</p>
<p id="p0071" num="0071">As illustrated in <figref idref="f0008">Figure 14</figref>, the XOR operations for computing an element of the matrix TR as disclosed in <figref idref="f0008">Figure 13</figref> is performed within each table PX4j[m] and these operations provides a table PX5j[m] for each table PX4j[m].</p>
<p id="p0072" num="0072">Also care is to be taken with the order of the operations, when performing the operations of the circuit MXC to keep the masks on the data, since each byte x'&lt;j&gt; is masked by a same mask v (=V[m], x'&lt;j&gt; = x&lt;j&gt;⊕v). The operations of the equation (9) are performed by applying the following property: <maths id="math0015" num="(10)"><math display="block"><mi mathvariant="normal">a</mi><mfenced separators=""><mi mathvariant="normal">x</mi><mo>⊕</mo><mi mathvariant="normal">v</mi></mfenced><mo>=</mo><mi>ax</mi><mo>⊕</mo><mi>av</mi><mo>,</mo><mspace width="1ex"/><mi>with</mi><mspace width="1ex"/><mi mathvariant="normal">a</mi><mo>=</mo><mn>2</mn><mspace width="1ex"/><mi>or</mi><mspace width="1ex"/><mi mathvariant="normal">3</mi><mo>.</mo></math><img id="ib0015" file="imgb0015.tif" wi="112" he="5" img-content="math" img-format="tif"/></maths> Thus: <maths id="math0016" num="(11)"><math display="block"><mtable><mtr><mtd><mrow><mi mathvariant="normal">A</mi><mo>=</mo><mn>2</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>0</mn><mo>&gt;</mo><mo>⊕</mo><mn>3</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>1</mn><mo>&gt;</mo><mo>⊕</mo><mn>2</mn><mi mathvariant="normal">v</mi><mo>⊕</mo><mn>3</mn><mi mathvariant="normal">v</mi><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>'</mo><mo>&lt;</mo><mn>2</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>'</mo><mo>&lt;</mo><mn>3</mn><mo>&gt;</mo></mrow></mtd></mtr><mtr><mtd><mrow><mo>=</mo><mn>2</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>0</mn><mo>&gt;</mo><mo>⊕</mo><mn>3</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>1</mn><mo>&gt;</mo><mo>⊕</mo><mn>2</mn><mi mathvariant="normal">v</mi><mo>⊕</mo><mn>2</mn><mi mathvariant="normal">v</mi><mo>⊕</mo><mi mathvariant="normal">v</mi><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>'</mo><mo>&lt;</mo><mn>2</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>'</mo><mo>&lt;</mo><mn>3</mn><mo>&gt;</mo></mrow></mtd></mtr><mtr><mtd><mrow><mo>=</mo><mn>2</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>0</mn><mo>&gt;</mo><mo>⊕</mo><mn>3</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>1</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">v</mi><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>2</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">v</mi><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>'</mo><mo>&lt;</mo><mn>3</mn><mo>&gt;</mo></mrow></mtd></mtr><mtr><mtd><mrow><mo>=</mo><mn>2</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>0</mn><mo>&gt;</mo><mo>⊕</mo><mn>3</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>1</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>2</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>'</mo><mo>&lt;</mo><mn>3</mn><mo>&gt;</mo></mrow></mtd></mtr></mtable></math><img id="ib0016" file="imgb0016.tif" wi="131" he="26" img-content="math" img-format="tif"/></maths> Therefore, at this step of the computations, the mask v is removed, which can form a leakage exploitable by a side-channel analysis to determine the data x, even if the mask v reappears when the last XOR operation is performed: <maths id="math0017" num="(12)"><math display="block"><mi mathvariant="normal">A</mi><mo>=</mo><mfenced separators=""><mn>2</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>0</mn><mo>&gt;</mo><mo>⊕</mo><mn>3</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>1</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>2</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>3</mn><mo>&gt;</mo></mfenced><mo>⊕</mo><mi mathvariant="normal">v</mi><mo>.</mo></math><img id="ib0017" file="imgb0017.tif" wi="112" he="5" img-content="math" img-format="tif"/></maths> In contrast, if the computation of element A is performed in the following order: <maths id="math0018" num="(13)"><math display="block"><mi mathvariant="normal">A</mi><mo>=</mo><mn>2</mn><mi mathvariant="normal">x</mi><mo>'</mo><mo>&lt;</mo><mn>0</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>'</mo><mo>&lt;</mo><mn>2</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>'</mo><mo>&lt;</mo><mn>3</mn><mo>&gt;</mo><mo>⊕</mo><mn>3</mn><mi mathvariant="normal">x</mi><mo>'</mo><mo>&lt;</mo><mn>1</mn><mo>&gt;</mo><mo>,</mo></math><img id="ib0018" file="imgb0018.tif" wi="112" he="5" img-content="math" img-format="tif"/></maths> we obtain: <maths id="math0019" num="(14)"><math display="block"><mtable><mtr><mtd><mrow><mi mathvariant="normal">A</mi><mo>=</mo><mn>2</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>0</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>2</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>'</mo><mo>&lt;</mo><mn>3</mn><mo>&gt;</mo><mo>⊕</mo><mn>3</mn><mi mathvariant="normal">x</mi><mo>'</mo><mo>&lt;</mo><mn>1</mn><mo>&gt;</mo><mo>⊕</mo><mn>2</mn><mi mathvariant="normal">v</mi><mo>⊕</mo><mi mathvariant="normal">v</mi></mrow></mtd></mtr><mtr><mtd><mrow><mo>=</mo><mn>2</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>0</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>2</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>3</mn><mo>&gt;</mo><mo>⊕</mo><mn>3</mn><mi mathvariant="normal">x</mi><mo>'</mo><mo>&lt;</mo><mn>1</mn><mo>&gt;</mo><mo>⊕</mo><mn>3</mn><mi mathvariant="normal">v</mi><mo>⊕</mo><mi mathvariant="normal">v</mi></mrow></mtd></mtr><mtr><mtd><mrow><mo>=</mo><mn>2</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>0</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>2</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>3</mn><mo>&gt;</mo><mo>⊕</mo><mn>3</mn><mi mathvariant="normal">x</mi><mo>'</mo><mo>&lt;</mo><mn>1</mn><mo>&gt;</mo><mo>⊕</mo><mn>2</mn><mi mathvariant="normal">v</mi><mo>⊕</mo><mi mathvariant="normal">v</mi><mo>⊕</mo><mi mathvariant="normal">v</mi></mrow></mtd></mtr><mtr><mtd><mrow><mo>=</mo><mn>2</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>0</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>2</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>3</mn><mo>&gt;</mo><mo>⊕</mo><mn>3</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>1</mn><mo>&gt;</mo><mo>⊕</mo><mn>2</mn><mi mathvariant="normal">v</mi><mo>⊕</mo><mn>3</mn><mi mathvariant="normal">v</mi></mrow></mtd></mtr><mtr><mtd><mrow><mo>=</mo><mn>2</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>0</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>2</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>3</mn><mo>&gt;</mo><mo>⊕</mo><mn>3</mn><mi mathvariant="normal">x</mi><mo>&lt;</mo><mn>1</mn><mo>&gt;</mo><mo>⊕</mo><mi mathvariant="normal">v</mi><mo>.</mo></mrow></mtd></mtr></mtable></math><img id="ib0019" file="imgb0019.tif" wi="132" he="32" img-content="math" img-format="tif"/></maths> Therefore, when performing the XOR operations in the order of the coefficients a, b, c, d equal to (2 1 1 3), the result of each XOR operation is always masked. The orders (1 2 1 3), (3 1 1 2) and (1 3 1 2) also maintain the masking after each XOR operation. It should also be observed that the<!-- EPO <DP n="25"> --> mask v applied to the input data is kept in the output data of the operation performed by the circuit MXC.</p>
<p id="p0073" num="0073">In <figref idref="f0007">Figure 12</figref>, The circuit XG2 provides an output set PX6j[0..MX,0..BX] having the form of the output set PX5[0..MX,0..BX] (<figref idref="f0004">Figure 7</figref>). The circuit XG5 is connected in series and interposed between circuits XG2 and SBB. The circuit XG5 receives the output set PX6j from the circuit XG2 and at another input the mask table W=U⊕V resulting from the combination of the tables U and V by XOR operations. Thus each value W[m] in the table W is equal to the XOR sum U[m]⊕V[m] of the values U[m] and V[m] selected at index m in the mask tables U and V. The table W can be computed as soon as the masks tables U and V are generated. By a suitable choice of the permutations U and V, each word column of the table W can comprise a same number of occurrences of all possible values of a word having the size of the words of the masks parameters U[m] and V[m].</p>
<p id="p0074" num="0074">According to an embodiment, one or several pairs (U0, V0) of mask tables U0 and V0 are stored in the circuit CT1, each pair (U0, V0) being tested as providing a table W comprising mask parameters W[m] = U0[m]⊕ V0[m]) and at least one word column comprising the same number of occurrences of all possible values of the words. The circuit CT1 is configured to derive pairs of mask tables (U2, V2) as follows: <maths id="math0020" num="(15)"><math display="block"><mtable columnalign="left"><mtr><mtd><mi>U2</mi><mfenced open="[" close="]"><mi mathvariant="normal">m</mi></mfenced><mo>=</mo><mi>PM</mi><mfenced separators=""><mi>U1</mi><mfenced open="[" close="]"><mi mathvariant="normal">m</mi></mfenced><mo>⊕</mo><mi>UR</mi></mfenced></mtd></mtr><mtr><mtd><mi>V2</mi><mfenced open="[" close="]"><mi mathvariant="normal">m</mi></mfenced><mo>=</mo><mi>PM</mi><mfenced separators=""><mi>V1</mi><mfenced open="[" close="]"><mi mathvariant="normal">m</mi></mfenced><mo>⊕</mo><mi>VR</mi></mfenced><mo>,</mo><mrow><mspace width="1ex"/><mi>for</mi><mspace width="1ex"/><mi>each</mi><mspace width="1ex"/><mi>index</mi><mspace width="1ex"/><mi mathvariant="normal">m</mi></mrow><mo>,</mo></mtd></mtr></mtable></math><img id="ib0020" file="imgb0020.tif" wi="112" he="12" img-content="math" img-format="tif"/></maths> or <maths id="math0021" num="(16)"><math display="block"><mtable columnalign="left"><mtr><mtd><mi>U2</mi><mfenced open="[" close="]"><mi mathvariant="normal">m</mi></mfenced><mo>=</mo><mi>PM</mi><mfenced separators=""><mi>U1</mi><mfenced open="[" close="]"><mi mathvariant="normal">m</mi></mfenced><mo>⊕</mo><mi>UR</mi></mfenced></mtd></mtr><mtr><mtd><mi>V2</mi><mfenced open="[" close="]"><mi mathvariant="normal">m</mi></mfenced><mo>=</mo><mi>PM</mi><mfenced separators=""><mi>V1</mi><mfenced open="[" close="]"><mi mathvariant="normal">m</mi></mfenced></mfenced><mo>⊕</mo><mi>VR</mi><mo>,</mo><mrow><mspace width="1ex"/><mi>for</mi><mspace width="1ex"/><mi>each</mi><mspace width="1ex"/><mi>index</mi><mspace width="1ex"/><mi mathvariant="normal">m</mi></mrow><mo>,</mo></mtd></mtr></mtable></math><img id="ib0021" file="imgb0021.tif" wi="112" he="12" img-content="math" img-format="tif"/></maths> where UR and VR are random words of the size of any of the masks parameters U[m] or V[m], U1 and V1 are previously computed tables obtained by the equations (15) or (16), or equal to U0 and V0 respectively, and PM is a randomly selected permutation applied to the elements of the tables U1 and V1. It can be proved that each pair (U2, V2) computed using the equation (15) or (16) has the property of providing a table W comprising a word column comprising the same number of occurrences of all possible values of the words.</p>
<p id="p0075" num="0075">The circuit XG5 provides an output set PX2j to the circuit SBB. The circuit XG5 can implement steps S51 to S58 represented in <figref idref="f0009">Figure 15</figref>. The<!-- EPO <DP n="26"> --> steps S51 to S58 perform application of a mask table W[0..MX] to an input set PX8[0..MX,0..BX], according to one embodiment. Steps S51 to S57 are first successively carried out. At step S51, the mask table W and a protected data having the form of the input set PX8 are input. The input set PX8 comprises words P8[0,0], ... P8[MX,BX] and the mask table comprises masks parameters W[0], ... W[MX]. At step S52, a permutation PM in the form of a table is randomly generated using the function RNP, the permutation PM comprising (MX+1)(BX+1) values between 0 and a maximum value KX=(MX+1)(BX+1)-1, where MX+1 is the number of values in the table PX8 and MX is the greatest value in this table. At step S53, an index k is initialized to zero (0). At step S54, indexes m and b are computed as in step S4. Step S55 computes the output word P9[m,b] at indexes m and b in the output set PX9 by combining by XOR operations the input word P8[m,b] at indexes m and b randomly selected in the input set PX8 with the mask parameter W[m] at index m randomly selected in the mask table W, using the random permutation PM (P9[m,b] = P8[m,b]⊕W[m]). At step S56, the index k is incremented by one (1). At step S57, the index k is compared with the maximum value KX. If the index k is greater than the value KX, step S58 is carried out, otherwise steps S54 to S57 are again carried out for a new iteration. At step S58, the output set PX9 is completely defined and provided as output of steps S51 to S57.</p>
<p id="p0076" num="0076">Therefore the output set PX2j provided by the circuit XG5 comprises words P9[m,b] masked with the mask parameters W[m] = U[m]⊕V[m] (m = 0, .. MX). Since the data in the output set PX6j are already masked with the masks parameters V[m] applied by the circuit SBB, these masks are removed by the circuit XG5. Thus the data set PX2j comprises data only masked by the mask parameters U[m], and thus the data set PX2j is ready to be further processed by the circuit SBB.</p>
<p id="p0077" num="0077">At a last round R, the circuit SBB provides an output set PX3R[0..MX,0..BX] in which each element PX3R[m,b] is masked by a mask V[m] of the mask table V. The circuit XG3 applies the round key KT[R,0..BX] to the output set PX4R according to the procedure of <figref idref="f0004">Figure 7</figref>, and provides an output set PX7R[0..MX,0..BX] in the form of a two-entry table in which each element at indexes m and b is equal to CX1[b]⊕V[m] and corresponds to an input data X1[b]⊕U[m] at the output of the circuit XG4. Therefore, the<!-- EPO <DP n="27"> --> output data CX1[0..BX] processed by each of the circuits OC1 can be deduced from each row m (=0, ... MX) in the output set PX7R by applying the mask V[m] to the data PX7R[m,0..BX].</p>
<p id="p0078" num="0078">It should be noted that all the data processed by the processing chain comprising the circuits SBB, SHR, MXC, XG2, XG5 and XG3, are always masked by either the parameter U or the parameter V. Thus this processing chain forms a protected area in the circuit OC1. The circuit OC1 can be implemented by software with the same level of protection, since this protection depends on masking operations which can be implemented by either hardware or software without a reduction of the protection level. The circuit OC1 can be implemented either by software executed by the processor PRC or the coprocessor CP1, or by hardware for example implemented in the coprocessor CP1.</p>
<p id="p0079" num="0079">According to another embodiment, the circuit XG3 can be configured to output only the output data CX1.</p>
<p id="p0080" num="0080">According to another embodiment, the masks parameters U[m] can be added to the round key KT[0] instead of the input data X1. The mask parameters W[m] could also be added to the round keys KT[1] to KT[R-1], and the mask parameters V[m] could also be added to the round key KT[R]. Thus a transformed round key table resulting from the above computations can be precomputed from the table KT, and the circuits XG4 and XG5 can be removed from the circuit OC1. Therefore, the protection method can be implemented in a circuit performing AES encryption or decryption without having to modify the circuit.</p>
<p id="p0081" num="0081">According to another embodiment, the circuit XG5 can be omitted, and a new masked substitution table SBM generated at each round according to the procedure of <figref idref="f0005">Figure 10</figref>, using the mask table V as an input mask table U. Accordingly, only another output mask table V and a new permutation PM should be generated at step S32.</p>
<p id="p0082" num="0082">As an alternative of generating a permutation PM at each of the steps S12, S32, S42 and S52 in the circuit OC1, the permutation PM can be generated only once at each round performed by the circuit OC1, or only once in step S2 for the first round and at step S12 or S32 for the last round. Also in one or several of the steps S2, S12, S32, S42 and S52, the generation of the permutation PM can be replaced by the generation of two<!-- EPO <DP n="28"> --> permutations, one being used for the index m or i, and the other for the index b or j.</p>
<p id="p0083" num="0083">The decryption operation according to AES algorithm comprises substantially the same operations as the encryption operation. Therefore, the previously described method for protecting a sequence of operations can be applied to protect a program or a circuit implementing the AES decryption operation. More particularly, an AES decryption circuit comprises circuits performing XOR operations with keys derived from the secret key SK, an inverse substitute calculation circuit, an inverse row-based circular permutation calculation circuit, an inverse column-based permutation calculation circuit, and the same key round table KT. The method previously disclosed can be applied to each operation performed by the decryption operation. The inverse column-based permutation calculation circuit also computes data having the following form: <maths id="math0022" num=""><math display="block"><mi>ax</mi><mo>&lt;</mo><mi mathvariant="normal">i</mi><mo>&gt;</mo><mo>⊕</mo><mi>bx</mi><mo>&lt;</mo><mi mathvariant="normal">i</mi><mo>+</mo><mn>1</mn><mo>&gt;</mo><mo>⊕</mo><mi>cx</mi><mo>&lt;</mo><mi mathvariant="normal">i</mi><mo>+</mo><mn>2</mn><mo>&gt;</mo><mo>⊕</mo><mi>dx</mi><mo>&lt;</mo><mi mathvariant="normal">i</mi><mo>+</mo><mn>3</mn><mo>&gt;</mo><mo>,</mo></math><img id="ib0022" file="imgb0022.tif" wi="73" he="5" img-content="math" img-format="tif"/></maths> where the group of coefficients (a, b, c, d) is equal to permutations of (9, 11, 13, 14). These coefficients allow the XOR operations to be computed in any order without removing the mask, and the resulting data keeps the same mask as the input data.</p>
<p id="p0084" num="0084">According to one embodiment, several words may be computed at a same time in a hardware architecture comprising wider buses than the size of the data to be processed by the operation, such as 32-bit or 64-bit since XOR operations are bitwise. In a 32-bit architecture, four bytes of the output data can be computed at the same time, and in a 64-bit architecture, eight bytes can be computed at the same time. Thus in the <figref idref="f0003">Figures 5</figref>, <figref idref="f0004">7</figref>, <figref idref="f0006">11</figref> and <figref idref="f0009">15</figref>, several iterations of the loop based on the index b can be grouped by processing several words in a same iteration. For example, in <figref idref="f0003">Figure 5</figref>, several or all of the computations at step S5 for b=0 to BX can be performed in a single operation by concatenating the mask value U[m] with itself several times to form a word of the size of the data P2[m,0..BX], as follows: <maths id="math0023" num="(17)"><math display="block"><mi mathvariant="normal">P</mi><mn>2</mn><mfenced open="[" close="]" separators=""><mi mathvariant="normal">m</mi><mo>,</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>BX</mi></mfenced><mo>=</mo><mi mathvariant="normal">X</mi><mn>2</mn><mfenced open="[" close="]" separators=""><mn>0</mn><mo>.</mo><mo>.</mo><mi>BX</mi></mfenced><mo>⊕</mo><mi mathvariant="normal">U</mi><mfenced open="[" close="]"><mi mathvariant="normal">m</mi></mfenced><mo>/</mo><mo>/</mo><mi mathvariant="normal">U</mi><mfenced open="[" close="]"><mi mathvariant="normal">m</mi></mfenced><mo>/</mo><mo>/</mo><mi>..</mi><mo>/</mo><mo>/</mo><mi mathvariant="normal">U</mi><mfenced open="[" close="]"><mi mathvariant="normal">m</mi></mfenced><mo>,</mo></math><img id="ib0023" file="imgb0023.tif" wi="124" he="5" img-content="math" img-format="tif"/></maths> "//" representing the concatenation operator of binary words.</p>
<p id="p0085" num="0085">In a same way, the computations performed at step S55 in <figref idref="f0009">Figure 15</figref> can be performed as follows: <maths id="math0024" num="(18)"><math display="block"><mi mathvariant="normal">P</mi><mn>9</mn><mfenced open="[" close="]" separators=""><mi mathvariant="normal">m</mi><mo>,</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>BX</mi></mfenced><mo>=</mo><mi mathvariant="normal">P</mi><mn>8</mn><mfenced open="[" close="]" separators=""><mi mathvariant="normal">m</mi><mo>,</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>BX</mi></mfenced><mo>⊕</mo><mi mathvariant="normal">U</mi><mfenced open="[" close="]"><mi mathvariant="normal">m</mi></mfenced><mo>/</mo><mo>/</mo><mi mathvariant="normal">U</mi><mfenced open="[" close="]"><mi mathvariant="normal">m</mi></mfenced><mo>/</mo><mo>/</mo><mi>..</mi><mo>/</mo><mo>/</mo><mi mathvariant="normal">U</mi><mfenced open="[" close="]"><mi mathvariant="normal">m</mi></mfenced><mo>,</mo></math><img id="ib0024" file="imgb0024.tif" wi="124" he="5" img-content="math" img-format="tif"/></maths><!-- EPO <DP n="29"> --></p>
<p id="p0086" num="0086">Here again, it could be also observed that if the circuit CT2 performing the AES operations undergoes an error such as one caused by a successful fault injection, the value of at least one word in the output set PX6R[0..MX] is changed. If only one word is changed, a word column m of the output set no longer comprises all possible values of an output word and comprises two identical words, the changed word having necessarily the value of another word in the output set. Thus such a fault injection can be detected by looking for two words in a column m of the output set having a same value. If two words are changed in a same column of the output, the fault injection would not be detected only when the values of these two words are swapped, which has a very low probability of occurrence. Thanks to the property of the XOR operation, an error can be easily detected by combining together by XOR operations all the words in each column m of the output set, the result of this combination being equal to zero when the column m of the output set comprises all possible values of an output word with a same number of occurrences.</p>
<p id="p0087" num="0087">It should be noted that the protection method previously disclosed may be applied only to some operations performed in the AES algorithm which would be detected as vulnerable to side channel analyses. For example, the protection method can be applied only to the first and last rounds of the AES algorithm, from which sensitive data could leak, or only to the substitution operations.</p>
<p id="p0088" num="0088">More generally, the protection method previously disclosed can be applied to other encryption algorithms, implemented either by software or in hardware, and comprising XOR operations combining sensitive data, such as ARIA (ref. [7]). The ARIA algorithm processes 128-bit data divided in 16 bytes and is performed by round, each round comprising a round key addition by XOR operations, a substitution step using two precomputed substitution tables and their inverses and a diffusion step. The substitution step processes byte per byte the input data combined with the round key, and the diffusion step applies 16 different XOR combinations to the 16 bytes of the data provided by the substitution step. In each of these combinations, seven bytes of the data are added by XOR operations.</p>
<p id="p0089" num="0089"><figref idref="f0009">Figure 16</figref> represents an integrated circuit CT3 arranged on a portable medium HD such as a plastic card, and implementing one of the protection methods previously described, according to one embodiment. The integrated<!-- EPO <DP n="30"> --> circuit comprises the same units as the integrated circuit CT described above in connection with <figref idref="f0001">Figure 1</figref>, and differs from the latter in that the coprocessor CP1 is replaced with a coprocessor CP2 implementing one and/or the other protection methods described above, for example in the form of the circuit CT1 or CT2. Therefore, according to one embodiment, the coprocessor CP2 is configured to provide output set of resulting data, rather than a single data of a cryptographic operation, each output set including the expected result of the cryptographic operation, the output set being such that all data in the output set have a same number of occurrences. The processor PRC can be configured to have access to the mask table V. Thus the processor PRC can deduce the output data from the output set by combining any one of the data in the output set by one mask parameter in the mask table V, the selected data having a same rank in the output set as the mask parameter selected in the mask table V.</p>
<p id="p0090" num="0090">The coprocessor CP2 may also be configured to execute a part of the cryptographic operation. In this case, the processor PRC is configured to produce output tables of resulting data including the result of the cryptographic operation, each output table being such that all data in it have a same number of occurrences.</p>
<p id="p0091" num="0091">The methods disclosed herein may also be implemented by software programs executable by a computer system. Further, implementations may include distributed processing and parallel processing, especially for processing in parallel several or all data in the input data sets and/or for providing in parallel several or all data in the output data sets.</p>
<p id="p0092" num="0092">The illustrations described herein are intended to provide a general understanding of the structure of various embodiments. These illustrations are not intended to serve as a complete description of all of the elements and features of apparatus, processors and systems that utilizes the structures or methods described therein. Many other embodiments or combinations thereof may be apparent to those of ordinary skills in the art upon reviewing the disclosure by combining the disclosed embodiments. Other embodiments may be utilized and derived from the disclosure, such that structural and logical substitutions and changes may be made without departing from the scope of the disclosure.</p>
<p id="p0093" num="0093">Further, the disclosure and the illustrations are to be considered as illustrative rather than restrictive. The scope of protection is defined by the claims.<!-- EPO <DP n="31"> --> Thus, the scope of the following claims is to be determined by the broadest permissible interpretation of the claims and shall not be restricted or limited by the foregoing description.<!-- EPO <DP n="32"> --></p>
<heading id="h0006">References cited</heading>
<p id="p0094" num="0094">
<ol id="ol0001" ol-style="">
<li>[1] <nplcit id="ncit0002" npl-type="b"><text>P. C. Kocher, "Timing attacks on implementations of Diffie-Hellman, RSA, DSS, and other systems" In Neal Koblitz, editor, Advances in Cryptology - CRYPTO '96, volume 1109 of Lecture Notes in Computer Science, p. 104-113. Springer, 1996</text></nplcit>.</li>
<li>[2] <nplcit id="ncit0003" npl-type="b"><text>P. C. Kocher, J. Jaffe, and B. Jun, "Differential Power Analysis" In M. J. Wiener, editor, Advances in Cryptology - CRYPTO '99, volume 1666 of Lecture Notes in Computer Science, p. 388-397. Springer, 1999</text></nplcit>.</li>
<li>[3] <nplcit id="ncit0004" npl-type="b"><text>E. Brier, C. Clavier, and F. Olivier, "Correlation Power Analysis with a Leakage Model" In M. Joye and J-J. Quisquater, editors, Cryptographic Hardware and Embedded Systems - CHES 2004, volume 3156 of Lecture Notes in Computer Science, p. 16-29. Springer, 2004</text></nplcit>.</li>
<li>[4] <nplcit id="ncit0005" npl-type="b"><text>J.-J. Quisquater, "ElectroMagnetic Analysis (EMA): Measures and Counter-measures for Smart Cards", Smart Card Programming and Security, Springer Berlin / Heidelberg, vol. 2140, 2001, p. 200-210</text></nplcit></li>
<li>[5] <nplcit id="ncit0006" npl-type="b"><text>S. Chari, J. R. Rao, and P. Rohatgi, "Template Attacks", Kaliski Jr., B.S., Koç, Ç.K., Paar, C. (eds.) CHES 2002. LNCS, vol. 2523, p. 172-186. Springer, Heidelberg (2003</text></nplcit>)</li>
<li>[6] <nplcit id="ncit0007" npl-type="b"><text>B. Gierlichs, L. Batina, P. Tuyls, and B. Preneel, "Mutual Information Analysis", CHES 2008, volume 5154 of LNCS, p. 426-442, Springer, 2008</text></nplcit></li>
<li>[7]<nplcit id="ncit0008" npl-type="s"><text> Daesung Kwon et al., "New Block Cipher: ARIA", Information Security and Cryptology - ICISC 2003, Volume 2971 of the series Lecture Notes in Computer Science p. 432-445</text></nplcit></li>
</ol></p>
</description>
<claims id="claims01" lang="en"><!-- EPO <DP n="33"> -->
<claim id="c-en-01-0001" num="0001">
<claim-text>A method for executing by a circuit (CT1) an operation (OPj) applied to an input data (X) comprising at least one word, the method comprising:
<claim-text>generating an input set (PX, PX2) comprising data (P2[m]) obtained by combining by Exclusive OR "XOR" operations (⊕) the input data with each of first mask parameters in a first mask set, each first mask parameter (u, U[m]) in the first mask set (U) comprising at least one word, the words in the first mask set having a same size and forming a first word subset comprising a single word from each first mask parameter of the first mask set and a same number of occurrences of all possible values of the words;</claim-text>
<claim-text>applying the operation to each data in the input set to generate an output set (PCX, PX7) comprising all data resulting from the application of the operation to one of the data in the input set; and</claim-text>
<claim-text>providing the output set as an output of the operation, an output data resulting from applying the operation to the input data, being obtained by applying XOR operations to any one of the data in the output set and to a respective second mask parameter (v, V[m]) in a second mask set (V), each second mask parameter in the second mask set comprising at least one word, the words in the second mask set having a same size and forming a second word subset comprising a single word from each second mask parameter of the second mask set and a same number of occurrences of all possible values of the words.</claim-text></claim-text></claim>
<claim id="c-en-01-0002" num="0002">
<claim-text>The method of claim 1, wherein the first mask set (U) is generated using a random permutation function (RNP).</claim-text></claim>
<claim id="c-en-01-0003" num="0003">
<claim-text>The method of claim 1 or 2, wherein the operation is a substitution operation whereby an output data is selected in an input substitution table using the input data as an index, the method comprising:
<claim-text>using masked substitution tables (SBM) generated from the input substitution table and comprising one masked substitution table (SBM[m]) for each of the first mask parameters in the first mask set; and</claim-text>
<claim-text>for each first mask parameter in the first mask set, selecting one of the masked substitution table (SBM[m]) corresponding to the first mask parameter,<!-- EPO <DP n="34"> --> and selecting a first data (SBM[m,P6[m,b]]) in the selected masked substitution table, using as an index a second data (P6[m,b]) corresponding to the first mask parameter in the input set, the output set (PX7) comprising all the first data selected in one of the masked substitution tables.</claim-text></claim-text></claim>
<claim id="c-en-01-0004" num="0004">
<claim-text>The method of claim 3, wherein the masked substitution tables are generated by:
<claim-text>generating the first mask set (U);</claim-text>
<claim-text>generating a second mask set (V) comprising a number of second mask parameters equal to the number of values in the input substitution table (SB), each second mask parameter having a same number of occurrences in the second mask set;</claim-text>
<claim-text>selecting once each mask parameter respectively in the first and second mask sets to form mask pairs, each comprising one of the first mask parameters and one of the second mask parameters;</claim-text>
<claim-text>generating for each mask pair one of the masked substitution table (SBM[m]), the generation of each of the masked substitution tables comprising:<br/>
selecting each data in the input substitution table, and for each selected data (SB[i], SB[i⊕U[m]]):
<claim-text>computing a masked data (SB[i]⊕V[m], SB[i⊕U[m]]⊕V[m]) by applying XOR operations to the selected data and to the second mask parameter (V[m]) of the mask pair,</claim-text>
<claim-text>computing a masked index (i⊕U[m]) by applying XOR operations to the first mask parameter (U[m]) of the mask pair and to an original index (i), and</claim-text>
<claim-text>storing the masked data in the masked substitution table, the selected data being selected at the original index and the masked data being stored at the masked index, or the selected data being selected at the masked index and the masked data being stored at the original index.</claim-text></claim-text></claim-text></claim>
<claim id="c-en-01-0005" num="0005">
<claim-text>The method of one of claims 3 and 4, wherein:
<claim-text>the first and second mask parameters (U[m], V[m]) of each mask pair are identical, or<!-- EPO <DP n="35"> --></claim-text>
<claim-text>the second mask set (V) is deduced from the first mask set (U) using a bijective function, combined or not with a shift function applied to ranks of the first mask parameters in the first mask set, or</claim-text>
<claim-text>the second mask set is generated using a random permutation function, or</claim-text>
<claim-text>the second mask set is generated so that a combination by XOR operations of each of the first mask parameters in the first mask set with a corresponding second mask parameter in the second mask set produces a third mask set comprising third mask parameters, each third mask parameter in the third mask set comprising at least one word, the words in the third mask set having a same size and forming a third word subset comprising a single word from each third mask parameter of the third mask set and a same number of occurrences of all possible values of a word having the size of the words in the third word subset.</claim-text></claim-text></claim>
<claim id="c-en-01-0006" num="0006">
<claim-text>The method of one of claims 3 to 5, wherein the values (SBM[m,b]) in the masked substitution tables (SBM[m]) are determined in a random order and/or stored in randomly selected positions in the masked substitution tables.</claim-text></claim>
<claim id="c-en-01-0007" num="0007">
<claim-text>The method of one of claims 1 to 6, wherein the computations of the data (P7[m,b]) in the output set (PX7) are performed in a random order and/or stored in randomly selected positions in the output set.</claim-text></claim>
<claim id="c-en-01-0008" num="0008">
<claim-text>The method of one of claims 1 to 7, comprising detecting in the output set (PX7) a computation error by:
<claim-text>detecting two identical data in the output set; or</claim-text>
<claim-text>applying XOR operations to each data in the output set and to a corresponding mask parameter in the first or second mask set, and searching in results of the XOR operations for a data different from an expected output data; or</claim-text>
<claim-text>by combining together by XOR operations all the output data in the output set (PCX), the result of the combination being equal to zero when no computation error occurred.</claim-text><!-- EPO <DP n="36"> --></claim-text></claim>
<claim id="c-en-01-0009" num="0009">
<claim-text>A method for encrypting or decrypting an input data (X1) according to a cryptographic algorithm comprising a substitution operation, wherein the substitution operation is performed according to the method of one of claims 3 to 8.</claim-text></claim>
<claim id="c-en-01-0010" num="0010">
<claim-text>The method of claim 9, wherein the cryptographic algorithm conforms with the Advanced Encryption Standard "AES" algorithm, the method comprising:
<claim-text>generating an input set (PX20[0..MX,0..BX]) by applying XOR operations (XG4, XG1) to each word (X1[b]) of the input data (X1), to each mask parameter (U[m]) of the first mask set (U), and to a word of a secret key (KT[b]) corresponding the word of the input data;</claim-text>
<claim-text>performing several intermediate rounds, each comprising:
<claim-text>applying the substitution operation to each word in the input set,</claim-text>
<claim-text>computing a masked round output set by applying XOR operations to each word of a round output set, to a respective mask parameter of the first mask set and to a respective mask parameter of the second mask set, and</claim-text>
<claim-text>using the masked round output set as an input set for a next round;</claim-text></claim-text>
<claim-text>performing a last round comprising applying the substitution operation to each word in the input set; and</claim-text>
<claim-text>providing an output set (PX7R[0..MX,0..BX]) in which each word is masked by a respective mask parameter of the second mask set.</claim-text></claim-text></claim>
<claim id="c-en-01-0011" num="0011">
<claim-text>The method of claim 10, wherein the first and second mask sets (U, V) are generated so that a third mask set (W) resulting from a combination by XOR operations of each mask parameter (U[m]) of the first mask set (U) with a corresponding mask parameter (V[m]) of the second mask set (V), comprises only one occurrence of all possible values of a word of the input data (X1).</claim-text></claim>
<claim id="c-en-01-0012" num="0012">
<claim-text>The method of claim 11, comprising generating a random permutation (PM) of a number of elements corresponding to a number of words in the input set (PX20), using the permutation to select the words in an input<!-- EPO <DP n="37"> --> set of an operation of the cryptographic algorithm, and applying the operation to the words of the input set in an order defined by the permutation.</claim-text></claim>
<claim id="c-en-01-0013" num="0013">
<claim-text>The method of claim 12, wherein a new random permutation (PM) is generated:
<claim-text>during a first round of the cryptographic algorithm, and/or</claim-text>
<claim-text>at each round of the cryptographic algorithm, and/or</claim-text>
<claim-text>at a last round of the cryptographic algorithm, and/or</claim-text>
<claim-text>before each operation of the cryptographic algorithm.</claim-text></claim-text></claim>
<claim id="c-en-01-0014" num="0014">
<claim-text>A circuit (CT1, CT2, CT3) comprising a processor (PRC) and configured to implement the method according to one of claims 1 to 13.</claim-text></claim>
<claim id="c-en-01-0015" num="0015">
<claim-text>The circuit of claim 14, comprising one circuit (OC, OC1) performing a substitution operation, for each masked substitution table (SBM[m]).</claim-text></claim>
<claim id="c-en-01-0016" num="0016">
<claim-text>The circuit of claim 15, comprising a coprocessor (CP1, CP2).</claim-text></claim>
<claim id="c-en-01-0017" num="0017">
<claim-text>A device comprising a circuit according to claim 14 to 16, arranged on a medium (HD).</claim-text></claim>
<claim id="c-en-01-0018" num="0018">
<claim-text>A computer program product loadable into a computer memory and comprising code portions which, when carried out by a computer, configure the computer to carry out the steps of the method according to one of claims 1 to 13.</claim-text></claim>
</claims>
<claims id="claims02" lang="de"><!-- EPO <DP n="38"> -->
<claim id="c-de-01-0001" num="0001">
<claim-text>Verfahren zum Ausführen durch eine Schaltung (CT1) eines Ablaufs (OPj), der auf eine Eingabedateneinheit (X) angewendet wird, die wenigstens ein Wort umfasst, wobei das Verfahren Folgendes umfasst:
<claim-text>Erzeugen eines Eingabesatzes (PX, PX2), der Daten (P2[m]) umfasst, die durch ein Kombinieren der Eingabedaten mit jedem von ersten Maskenparametern in einem ersten Maskensatz durch Exklusiv-Oder (Exclusive OR - XOR)-Abläufe (⊕) erhalten werden, wobei jeder erste Maskenparameter (u, U[m]) in dem ersten Maskensatz (U) wenigstens ein Wort umfasst, wobei die Wörter in dem ersten Maskensatz eine selbe Größe aufweisen und einen ersten Wortteilsatz ausbilden, der ein einzelnes Wort aus jedem ersten Maskenparameter des ersten Maskensatzes und eine selbe Anzahl von Vorkommen aller möglichen Werte der Wörter umfasst;</claim-text>
<claim-text>Anwenden des Ablaufs auf jede Dateneinheit in dem Eingabesatz, um einen Ausgabesatz (PCX, PX7) zu erzeugen, der alle Daten umfasst, die sich aus der Anwendung des Ablaufs auf eine Einheit der Daten in dem Eingabesatz ergeben; und</claim-text>
<claim-text>Bereitstellen des Ausgabesatzes als eine Ausgabe des Ablaufs, wobei eine Ausgabedateneinheit, die sich aus dem Anwenden des Ablaufs auf die Eingabedaten ergibt, durch Anwenden von XOR-Abläufen auf eine beliebige Einheit der Daten in dem Ausgabesatz und auf einen jeweiligen zweiten Maskenparameter (v, V[m]) in einem zweiten Maskensatz (V) erhalten werden, wobei jeder zweite Maskenparameter in dem zweiten Maskensatz wenigstens ein Wort umfasst, wobei die Wörter in dem zweiten Maskensatz eine selbe Größe aufweisen und einen zweiten Wortteilsatz ausbilden, der ein einzelnes Wort aus jedem zweiten Maskenparameter des zweiten Maskensatzes und eine selbe Anzahl von Vorkommen aller möglichen Werte der Wörter umfasst.</claim-text></claim-text></claim>
<claim id="c-de-01-0002" num="0002">
<claim-text>Verfahren nach Anspruch 1, wobei der erste Maskensatz (U) unter Verwendung einer Zufallspermutationsfunktion (RNP) erzeugt wird.</claim-text></claim>
<claim id="c-de-01-0003" num="0003">
<claim-text>Verfahren nach Anspruch 1 oder 2, wobei der Ablauf ein Substitutionsablauf ist, wodurch eine Ausgabedateneinheit in einer Eingabesubstitutionstabelle unter Verwendung der Eingabedaten als einen Index ausgewählt wird, wobei das Verfahren Folgendes umfasst:
<claim-text>Verwenden von maskierten Substitutionstabellen (SBM), die aus der Eingabesubstitutionstabelle erzeugt werden und eine maskierte Substitutionstabelle (SBM[m]) für jeden der ersten Maskenparameter in dem ersten Maskensatz umfassen; und<!-- EPO <DP n="39"> --></claim-text>
<claim-text>für jeden ersten Maskenparameter in dem ersten Maskensatz, Auswählen einer der maskierten Substitutionstabellen (SBM[m]), die dem ersten Maskenparameter entspricht, und Auswählen einer ersten Dateneinheit (SBM [m,P6[m,b]]) in der ausgewählten maskierten Substitutionstabelle unter Verwendung einer zweiten Dateneinheit (P6[m, b]), die dem ersten Maskenparameter in dem Eingabesatz entspricht, als einen Index, wobei der Ausgabesatz (PX7) alle ersten Daten umfasst, die in einer der maskierten Substitutionstabellen ausgewählt sind.</claim-text></claim-text></claim>
<claim id="c-de-01-0004" num="0004">
<claim-text>Verfahren nach Anspruch 3, wobei die maskierten Substitutionstabellen durch Folgendes erzeugt werden:
<claim-text>Erzeugen des ersten Maskensatzes (U);</claim-text>
<claim-text>Erzeugen eines zweiten Maskensatzes (V), der eine Anzahl von zweiten Maskenparametern gleich der Anzahl von Werten in der Eingabesubstitutionstabelle (SB) umfasst, wobei jeder zweite Maskenparameter eine selbe Anzahl von Vorkommen in dem zweiten Maskensatz aufweist;</claim-text>
<claim-text>einmaliges Auswählen jedes Maskenparameters in dem ersten beziehungsweise dem zweiten Maskensatz, um Maskenpaare auszubilden, wobei jedes einen der ersten Maskenparameter und einen der zweiten Maskenparameter umfasst;</claim-text>
<claim-text>Erzeugen einer der maskierten Substitutionstabellen (SBM[m]) für jedes Maskenpaar, wobei die Erzeugung jeder der maskierten Substitutionstabellen Folgendes umfasst:<br/>
Auswählen jeder Dateneinheit in der Eingabesubstitutionstabelle und für jede ausgewählte Dateneinheit (SB[i], SB[i ⊕ U[m]]):
<claim-text>Berechnen einer maskierten Dateneinheit (SB[i] ⊕ V[m], SB[i ⊕ U[m]] ⊕ V[m]) durch Anwenden von XOR-Abläufen auf die ausgewählten Daten und auf den zweiten Maskenparameter (V [m]) des Maskenpaars,</claim-text>
<claim-text>Berechnen eines maskierten Index (i ⊕ U[m]) durch Anwenden von XOR-Abläufen auf den ersten Maskenparameter (U[m]) des Maskenpaares und auf einen ursprünglichen Index (i), und</claim-text>
<claim-text>Speichern der maskierten Daten in der maskierten Substitutionstabelle, wobei die ausgewählten Daten an dem ursprünglichen Index ausgewählt werden und die maskierten Daten an dem maskierten Index gespeichert werden, oder die ausgewählten Daten an dem maskierten Index ausgewählt werden und die maskierten Daten an dem ursprünglichen Index gespeichert werden.</claim-text></claim-text></claim-text></claim>
<claim id="c-de-01-0005" num="0005">
<claim-text>Verfahren nach einem der Ansprüche 3 und 4, wobei:<!-- EPO <DP n="40"> -->
<claim-text>der erste und der zweite Maskenparameter (U[m], V[m]) jedes Maskenpaares identisch sind, oder</claim-text>
<claim-text>der zweite Maskensatz (V) unter Verwendung einer bijektiven Funktion aus dem ersten Maskensatz (U) abgeleitet wird, kombiniert oder nicht mit einer Verschiebungsfunktion, die auf Ränge der ersten Maskenparameter in dem ersten Maskensatz angewendet wird, oder</claim-text>
<claim-text>der zweite Maskensatz unter Verwendung einer Zufallspermutationsfunktion erzeugt wird, oder</claim-text>
<claim-text>der zweite Maskensatz erzeugt wird, so dass eine Kombination jedes der ersten Maskenparameter in dem ersten Maskensatz mit einem entsprechenden zweiten Maskenparameter in dem zweiten Maskensatz durch XOR-Abläufe einen dritten Maskensatz produziert, der dritte Maskenparameter umfasst, wobei jeder dritte Maskenparameter in dem dritten Maskensatz wenigstens ein Wort umfasst, wobei die Wörter in dem dritten Maskensatz eine selbe Größe aufweisen und einen dritten Wortteilsatz ausbilden, der ein einzelnes Wort aus jedem dritten Maskenparameter des dritten Maskensatzes und eine selbe Anzahl von Vorkommen aller möglichen Werte eines Worts umfasst, das die Größe der Wörter in dem dritten Wortteilsatz aufweist.</claim-text></claim-text></claim>
<claim id="c-de-01-0006" num="0006">
<claim-text>Verfahren nach einem der Ansprüche 3 bis 5, wobei die Werte (SBM[m,b]) in den maskierten Substitutionstabellen (SBM[m]) in einer zufälligen Reihenfolge bestimmt und/oder in zufällig ausgewählten Positionen in den maskierten Substitutionstabellen gespeichert werden.</claim-text></claim>
<claim id="c-de-01-0007" num="0007">
<claim-text>Verfahren nach einem der Ansprüche 1 bis 6, wobei die Berechnungen der Daten (P7[m,b] in dem Ausgabesatz (PX7) in einer zufälligen Reihenfolge durchgeführt und/oder in zufällig ausgewählten Positionen in dem Ausgabesatz gespeichert werden.</claim-text></claim>
<claim id="c-de-01-0008" num="0008">
<claim-text>Verfahren nach einem der Ansprüche 1 bis 7, das ein Erfassen eines Berechnungsfehlers in dem Ausgabesatz (PX7) durch Folgendes umfasst:
<claim-text>Erfassen von zwei identischen Dateneinheiten in dem Ausgabesatz; oder</claim-text>
<claim-text>Anwenden von XOR-Abläufen auf jede Dateneinheit in dem Ausgabesatz und auf einen entsprechenden Maskenparameter in dem ersten oder dem zweiten Maskensatz und Suchen in Ergebnissen der XOR-Abläufe nach einer Dateneinheit, die sich von einer erwarteten Ausgabedateneinheit unterscheidet; oder<!-- EPO <DP n="41"> --></claim-text>
<claim-text>durch miteinander Kombinieren aller Ausgabedaten in dem Ausgabesatz (PCX) durch XOR-Abläufe, wobei das Ergebnis der Kombination gleich null ist, wenn kein Rechenfehler vorgekommen ist.</claim-text></claim-text></claim>
<claim id="c-de-01-0009" num="0009">
<claim-text>Verfahren zum Verschlüsseln oder Entschlüsseln einer Eingabedateneinheit (X1) gemäß einem kryptografischen Algorithmus, das einen Substitutionsablauf umfasst, wobei der Substitutionsablauf gemäß dem Verfahren nach einem der Ansprüche 3 bis 8 durchgeführt wird.</claim-text></claim>
<claim id="c-de-01-0010" num="0010">
<claim-text>Verfahren nach Anspruch 9, wobei der kryptografische Algorithmus mit dem Advanced-Encryption-Standard(AES)-Algorithmus übereinstimmt, wobei das Verfahren Folgendes umfasst:
<claim-text>Erzeugen eines Eingabesatzes (PX20[0..MX,0..BX]) durch Anwenden von XOR-Abläufen (XG4, XG1) auf jedes Wort (X1[b]) der Eingabedaten (X1), auf jeden Maskenparameter (U[m]) des ersten Maskensatzes (U) und auf ein Wort eines geheimen Schlüssels (KT[b]), das dem Wort der Eingabedaten entspricht;</claim-text>
<claim-text>Durchführen mehrerer Zwischenrunden, die jeweils Folgendes umfassen:
<claim-text>Anwenden des Substitutionsablaufs auf jedes Wort in dem Eingabesatz,</claim-text>
<claim-text>Berechnen eines maskierten Rundenausgabesatzes durch Anwenden von XOR-Abläufen auf jedes Wort eines Rundenausgabesatzes, auf einen jeweiligen Maskenparameter des ersten Maskensatzes und auf einen jeweiligen Maskenparameter des zweiten Maskensatzes, und</claim-text>
<claim-text>Verwenden des maskierten Rundenausgabesatzes als einen Eingabesatz für eine nächste Runde;</claim-text></claim-text>
<claim-text>Durchführen einer letzten Runde, die das Anwenden des Substitutionsablaufs auf jedes Wort in dem Eingabesatz umfasst; und</claim-text>
<claim-text>Bereitstellen eines Ausgabesatzes (PX7R[0..MX,0..BX]), in dem jedes Wort durch einen jeweiligen Maskenparameter des ersten Maskensatzes maskiert wird.</claim-text></claim-text></claim>
<claim id="c-de-01-0011" num="0011">
<claim-text>Verfahren nach Anspruch 10, wobei der erste und der zweite Maskensatz (U, V) erzeugt werden, so dass ein dritter Maskensatz (W), der sich aus einer Kombination jedes Maskenparameters (U[m]) des ersten Maskensatzes (U) mit einem entsprechenden Maskenparameter (V[m]) des zweiten Maskensatzes (V) durch XOR-Abläufe ergibt, nur ein Vorkommen aller möglichen Werte eines Worts der Eingabedaten (X1) umfasst.<!-- EPO <DP n="42"> --></claim-text></claim>
<claim id="c-de-01-0012" num="0012">
<claim-text>Verfahren nach Anspruch 11, das das Erzeugen einer Zufallspermutation (PM) einer Anzahl von Elementen, die einer Anzahl von Wörtern in dem Eingabesatz (PX20) entspricht, unter Verwendung der Permutation, um Wörter in einem Eingabesatz eines Ablaufs des kryptografischen Algorithmus auszuwählen, und das Anwenden des Ablaufs auf die Wörter des Eingabesatzes in einer durch die Permutation definierten Reihenfolge umfasst.</claim-text></claim>
<claim id="c-de-01-0013" num="0013">
<claim-text>Verfahren nach Anspruch 12, wobei eine neue Zufallspermutation (PM) erzeugt wird:
<claim-text>während einer ersten Runde des kryptografischen Algorithmus und/oder bei jeder Runde des kryptografischen Algorithmus und/oder</claim-text>
<claim-text>bei einer letzten Runde des kryptografischen Algorithmus und/oder vor jedem Ablauf des kryptografischen Algorithmus.</claim-text></claim-text></claim>
<claim id="c-de-01-0014" num="0014">
<claim-text>Schaltung (CT1, CT2, CT3), die einen Prozessor (PRC) umfasst und konfiguriert ist, um das Verfahren nach einem der Ansprüche 1 bis 13 zu implementieren.</claim-text></claim>
<claim id="c-de-01-0015" num="0015">
<claim-text>Schaltung nach Anspruch 14, die eine Schaltung (OC, OC1) umfasst, die einen Substitutionsablauf für jede maskierte Substitutionstabelle (SBM[m]) durchführt.</claim-text></claim>
<claim id="c-de-01-0016" num="0016">
<claim-text>Schaltung nach Anspruch 15, die einen Coprozessor (CP1, CP2) umfasst.</claim-text></claim>
<claim id="c-de-01-0017" num="0017">
<claim-text>Vorrichtung, die eine Schaltung nach Anspruch 14 bis 16 umfasst, die auf einem Medium (HD) angeordnet ist.</claim-text></claim>
<claim id="c-de-01-0018" num="0018">
<claim-text>Computerprogrammprodukt, das in einen Computerspeicher ladbar ist und Codeabschnitte umfasst, die, wenn sie durch einen Computer vorgenommen werden, den Computer konfigurieren, um die Schritte des Verfahrens nach einem der Ansprüche 1 bis 13 vorzunehmen.</claim-text></claim>
</claims>
<claims id="claims03" lang="fr"><!-- EPO <DP n="43"> -->
<claim id="c-fr-01-0001" num="0001">
<claim-text>Procédé pour exécuter, par un circuit (CT1), une opération (OPj) appliquée à une donnée d'entrée (X) comprenant au moins un mot, le procédé comprenant :
<claim-text>la génération d'un ensemble d'entrées (PX, PX2) comprenant des données (P2[m]) obtenues en combinant, par des opérations « XOR » fonction OU exclusif (⊕), les données d'entrée avec chacun des premiers paramètres de masque dans un premier ensemble de masques, chaque premier paramètre de masque (u, U[m]) dans le premier ensemble de masques (U) comprenant au moins un mot, les mots dans le premier ensemble de masques ayant une même taille et formant un premier sous-ensemble de mots comprenant un mot unique provenant de chaque premier paramètre de masque du premier ensemble de masques et un même nombre d'occurrences de toutes les valeurs possibles des mots ;</claim-text>
<claim-text>l'application de l'opération à chaque donnée dans l'ensemble d'entrées pour générer un ensemble de sorties (PCX, PX7) comprenant toutes les données résultant de l'application de l'opération à l'une des données dans l'ensemble d'entrées ; et</claim-text>
<claim-text>la fourniture de l'ensemble de sorties en tant que sortie de l'opération, une donnée de sortie résultant de l'application de l'opération aux données d'entrée étant obtenue en appliquant des opérations XOR à l'une quelconque des données dans l'ensemble de sorties et à un deuxième paramètre de masque respectif (v, V[m]) dans un deuxième ensemble de masques (V), chaque deuxième paramètre de masque dans le deuxième ensemble de masques comprenant au moins un mot, les mots dans le deuxième ensemble de masques ayant une même taille et formant un deuxième sous-ensemble de mots comprenant un mot unique provenant de chaque deuxième paramètre de masque du deuxième ensemble de masques et un même nombre d'occurrences de toutes les valeurs possibles des mots.</claim-text></claim-text></claim>
<claim id="c-fr-01-0002" num="0002">
<claim-text>Procédé selon la revendication 1, le premier ensemble de masques (U) étant généré à l'aide d'une fonction de permutation aléatoire (RNP).</claim-text></claim>
<claim id="c-fr-01-0003" num="0003">
<claim-text>Procédé selon la revendication 1 ou 2, l'opération étant une opération de substitution par laquelle une donnée de sortie est sélectionnée dans une table de substitution d'entrée à l'aide des données d'entrée en tant qu'indice, le procédé comprenant :
<claim-text>l'utilisation de tables de substitution masquées (SBM) générées à partir de la table de substitution d'entrées et comprenant une table de substitution masquée (SBM[m]) pour chacun des premiers paramètres de masque dans le premier ensemble de masques ; et<!-- EPO <DP n="44"> --></claim-text>
<claim-text>pour chaque premier paramètre de masque du premier ensemble de masques, la sélection de l'une des tables de substitution masquées (SBM[m]) correspondant au premier paramètre de masque et la sélection d'une première donnée (SBM[m, P6 [m, b]]) dans la table de substitution masquée sélectionnée, l'utilisation, en tant qu'indice, d'une seconde donnée (P6 [m, b]) correspondant au premier paramètre de masque dans l'ensemble d'entrées, l'ensemble de sorties (PX7) comprenant toutes les premières données sélectionnées dans l'une des tables de substitution masquées.</claim-text></claim-text></claim>
<claim id="c-fr-01-0004" num="0004">
<claim-text>Procédé selon la revendication 3, les tables de substitution masquées étant générées :
<claim-text>par génération du premier ensemble de masques (U) ;</claim-text>
<claim-text>par génération d'un deuxième ensemble de masques (V) comprenant un nombre de deuxièmes paramètres de masque égal au nombre de valeurs dans la table de substitution d'entrée (SB), chaque deuxième paramètre de masque ayant un même nombre d'occurrences dans le deuxième ensemble de masques ;</claim-text>
<claim-text>par sélection, une fois, de chaque paramètre de masque respectivement dans les premier et deuxième ensembles de masques pour former des paires de masques, chacune comprenant l'un des premiers paramètres de masque et l'un des deuxièmes paramètres de masque ;</claim-text>
<claim-text>par génération, pour chaque paire de masques, de l'une des tables de substitution masquées (SBM[m]), la génération de chacune des tables de substitution masquées comprenant :<br/>
la sélection de chaque donnée dans la table de substitution d'entrée, et pour chaque donnée sélectionnée (SB[i], SB[i ⊕ U[m]]) :
<claim-text>le calcul d'une donnée masquée SB[i] ⊕ V[m], SB[i ⊕ U[m]] ⊕ V[m]) en appliquant des opérations XOR aux données sélectionnées et au deuxième paramètre de masque (V[m]) de la paire de masques,</claim-text>
<claim-text>le calcul d'un indice masqué (i ⊕ U[m]) en appliquant des opérations XOR au premier paramètre de masque (U[m]) de la paire de masques et à un indice d'origine (i), et</claim-text>
<claim-text>le stockage des données masquées dans la table de substitution masquée, les données sélectionnées étant sélectionnées au niveau de l'indice d'origine et les données masquées étant stockées au niveau de l'indice masqué, ou les données sélectionnées étant sélectionnées au niveau de l'indice masqué et les données masquées étant stockées au niveau de l'indice d'origine.</claim-text></claim-text></claim-text></claim>
<claim id="c-fr-01-0005" num="0005">
<claim-text>Procédé selon l'une des revendications 3 et 4 :<!-- EPO <DP n="45"> -->
<claim-text>les premier et deuxième paramètres de masque (U[m], V[m]) de chaque paire de masques étant identiques, ou</claim-text>
<claim-text>le deuxième ensemble de masques (V) étant déduit à partir du premier ensemble de masques (U) à l'aide d'une fonction bijective, combinée ou non à une fonction de décalage appliquée aux rangs des premiers paramètres de masques dans le premier ensemble de masques, ou</claim-text>
<claim-text>le deuxième ensemble de masques étant généré à l'aide d'une fonction de permutation aléatoire, ou</claim-text>
<claim-text>le deuxième ensemble de masques étant généré de sorte qu'une combinaison par opérations XOR de chacun des premiers paramètres de masque dans le premier ensemble de masques avec un deuxième paramètre de masque correspondant dans le deuxième ensemble de masques produit un troisième ensemble de masques comprenant des troisièmes paramètres de masque, chaque troisième paramètre de masque dans le troisième ensemble de masques comprenant au moins un mot, les mots dans le troisième ensemble de masques ayant une même taille et formant un troisième sous-ensemble de mots comprenant un mot unique provenant de chaque troisième paramètre de masque du troisième ensemble de masques et un même nombre d'occurrences de toutes les valeurs possibles d'un mot ayant la taille des mots du troisième sous-ensemble de mots.</claim-text></claim-text></claim>
<claim id="c-fr-01-0006" num="0006">
<claim-text>Procédé selon l'une des revendications 3 à 5, les valeurs (SBM[m, b]) dans les tables de substitution masquées (SBM[m]) étant déterminées dans un ordre aléatoire et/ou stockées dans des positions sélectionnées de manière aléatoire dans les tables de substitution masquées.</claim-text></claim>
<claim id="c-fr-01-0007" num="0007">
<claim-text>Procédé selon l'une des revendications 1 à 6, les calculs des données (P7[m, b]) dans l'ensemble de sorties (PX7) étant effectués dans un ordre aléatoire et/ou stockés dans des positions sélectionnées de manière aléatoire dans l'ensemble de sorties.</claim-text></claim>
<claim id="c-fr-01-0008" num="0008">
<claim-text>Procédé selon l'une des revendications 1 à 7, comprenant la détection, dans l'ensemble de sorties (PX7), d'une erreur de calcul :
<claim-text>par détection de deux données identiques dans l'ensemble de sorties ; ou</claim-text>
<claim-text>par application d'opérations XOR à chaque donnée dans l'ensemble de sorties et à un paramètre de masque correspondant dans le premier ou le deuxième ensemble de masques, et par recherche dans les résultats des opérations XOR de données différentes d'une donnée de sortie attendue ; ou<!-- EPO <DP n="46"> --></claim-text>
<claim-text>par combinaison conjointe, par des opérations XOR, de toutes les données de sortie dans l'ensemble de sorties (PCX), le résultat de la combinaison étant égal à zéro lorsqu'aucune erreur de calcul ne s'est produite.</claim-text></claim-text></claim>
<claim id="c-fr-01-0009" num="0009">
<claim-text>Procédé de chiffrement ou de déchiffrement de données d'entrée (X1) selon un algorithme cryptographique comprenant une opération de substitution, l'opération de substitution étant effectuée selon le procédé de l'une des revendications 3 à 8.</claim-text></claim>
<claim id="c-fr-01-0010" num="0010">
<claim-text>Procédé selon la revendication 9, l'algorithme cryptographique étant conforme à l'algorithme de norme de chiffrement avancé « AES », le procédé comprenant :
<claim-text>la génération d'un ensemble d'entrées (PX20[0..MX, 0..BX]) en appliquant des opérations XOR (XG4, XG1) à chaque mot (X1[b]) des données d'entrée (X1), à chaque paramètre de masque (U[m]) du premier ensemble de masques (U), et à un mot d'une clé secrète (KT[b]) correspondant au mot des données d'entrée ;</claim-text>
<claim-text>le fait d'effectuer plusieurs tours intermédiaires, chacun comprenant :
<claim-text>l'application de l'opération de substitution à chaque mot de l'ensemble d'entrées,</claim-text>
<claim-text>le calcul d'un ensemble de sorties de tour masquées en appliquant des opérations XOR à chaque mot d'un ensemble de sorties de tour, à un paramètre de masque respectif du premier ensemble de masques et à un paramètre de masque respectif du deuxième ensemble de masques, et</claim-text>
<claim-text>l'utilisation de l'ensemble de sorties de tour masquées en tant qu'ensemble d'entrées pour un tour suivant ;</claim-text></claim-text>
<claim-text>le fait d'effectuer un dernier tour comprenant l'application de l'opération de substitution à chaque mot dans l'ensemble d'entrées ; et</claim-text>
<claim-text>la fourniture d'un ensemble de sorties (PX7R[0..MX, 0..BX]) dans lequel chaque mot est masqué par un paramètre de masque respectif du deuxième ensemble de masques.</claim-text></claim-text></claim>
<claim id="c-fr-01-0011" num="0011">
<claim-text>Procédé selon la revendication 10, les premier et deuxième ensembles de masques (U, V) étant générés de sorte qu'un troisième ensemble de masques W), résultant d'une combinaison par opérations XOR de chaque paramètre de masque (U[m]) du premier ensemble de masques (U) avec un paramètre de masque correspondant (V[m]) du deuxième ensemble de masques (V), comprend une seule occurrence de toutes les valeurs possibles d'un mot des données d'entrée (X1).<!-- EPO <DP n="47"> --></claim-text></claim>
<claim id="c-fr-01-0012" num="0012">
<claim-text>Procédé selon la revendication 11, comprenant la génération d'une permutation aléatoire (PM) d'un certain nombre d'éléments correspondant à un certain nombre de mots dans l'ensemble d'entrées (PX20), l'utilisation de la permutation pour sélectionner les mots dans un ensemble d'entrées d'une opération de l'algorithme cryptographique, et l'application de l'opération aux mots de l'ensemble d'entrées dans un ordre défini par la permutation.</claim-text></claim>
<claim id="c-fr-01-0013" num="0013">
<claim-text>Procédé selon la revendication 12, une nouvelle permutation aléatoire (PM) étant générée :
<claim-text>lors d'un premier tour de l'algorithme cryptographique, et/ou à chaque tour de l'algorithme cryptographique, et/ou</claim-text>
<claim-text>au dernier tour de l'algorithme cryptographique, et/ou avant chaque opération de l'algorithme cryptographique.</claim-text></claim-text></claim>
<claim id="c-fr-01-0014" num="0014">
<claim-text>Circuit (CT1, CT2, CT3) comprenant un processeur (PRC) et configuré pour mettre en œuvre le procédé selon l'une des revendications 1 à 13.</claim-text></claim>
<claim id="c-fr-01-0015" num="0015">
<claim-text>Circuit selon la revendication 14, comprenant un circuit (OC, OC1) effectuant une opération de substitution, pour chaque table de substitution masquée (SBM[m]).</claim-text></claim>
<claim id="c-fr-01-0016" num="0016">
<claim-text>Circuit selon la revendication 15, comprenant un coprocesseur (CP1, CP2).</claim-text></claim>
<claim id="c-fr-01-0017" num="0017">
<claim-text>Dispositif comprenant un circuit selon les revendications 14 à 16, disposé sur un support (HD).</claim-text></claim>
<claim id="c-fr-01-0018" num="0018">
<claim-text>Produit-programme informatique pouvant être chargé dans une mémoire d'ordinateur et comprenant des parties de code qui, lorsqu'elles sont exécutées par un ordinateur, configurent l'ordinateur pour exécuter les étapes du procédé selon l'une des revendications 1 à 13.</claim-text></claim>
</claims>
<drawings id="draw" lang="en"><!-- EPO <DP n="48"> -->
<figure id="f0001" num="1,2"><img id="if0001" file="imgf0001.tif" wi="151" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="49"> -->
<figure id="f0002" num="3,4"><img id="if0002" file="imgf0002.tif" wi="160" he="229" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="50"> -->
<figure id="f0003" num="5,6"><img id="if0003" file="imgf0003.tif" wi="159" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="51"> -->
<figure id="f0004" num="7,8A,8B,8C"><img id="if0004" file="imgf0004.tif" wi="154" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="52"> -->
<figure id="f0005" num="9,10"><img id="if0005" file="imgf0005.tif" wi="149" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="53"> -->
<figure id="f0006" num="11"><img id="if0006" file="imgf0006.tif" wi="97" he="108" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="54"> -->
<figure id="f0007" num="12"><img id="if0007" file="imgf0007.tif" wi="112" he="167" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="55"> -->
<figure id="f0008" num="13,14"><img id="if0008" file="imgf0008.tif" wi="158" he="221" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="56"> -->
<figure id="f0009" num="15,16"><img id="if0009" file="imgf0009.tif" wi="128" he="228" img-content="drawing" img-format="tif"/></figure>
</drawings>
<ep-reference-list id="ref-list">
<heading id="ref-h0001"><b>REFERENCES CITED IN THE DESCRIPTION</b></heading>
<p id="ref-p0001" num=""><i>This list of references cited by the applicant is for the reader's convenience only. It does not form part of the European patent document. Even though great care has been taken in compiling the references, errors or omissions cannot be excluded and the EPO disclaims all liability in this regard.</i></p>
<heading id="ref-h0002"><b>Patent documents cited in the description</b></heading>
<p id="ref-p0002" num="">
<ul id="ref-ul0001" list-style="bullet">
<li><patcit id="ref-pcit0001" dnum="FR1651443"><document-id><country>FR</country><doc-number>1651443</doc-number><date>20160222</date></document-id></patcit><crossref idref="pcit0001">[0011]</crossref></li>
<li><patcit id="ref-pcit0002" dnum="US2005259814A"><document-id><country>US</country><doc-number>2005259814</doc-number><kind>A</kind></document-id></patcit><crossref idref="pcit0002">[0014]</crossref></li>
<li><patcit id="ref-pcit0003" dnum="EP1601132A"><document-id><country>EP</country><doc-number>1601132</doc-number><kind>A</kind></document-id></patcit><crossref idref="pcit0003">[0014]</crossref></li>
<li><patcit id="ref-pcit0004" dnum="US2011055591A"><document-id><country>US</country><doc-number>2011055591</doc-number><kind>A</kind></document-id></patcit><crossref idref="pcit0004">[0014]</crossref></li>
</ul></p>
<heading id="ref-h0003"><b>Non-patent literature cited in the description</b></heading>
<p id="ref-p0003" num="">
<ul id="ref-ul0002" list-style="bullet">
<li><nplcit id="ref-ncit0001" npl-type="s"><article><atl/><serial><sertitle>Advanced Encryption Standard FIPS PUB 197</sertitle><pubdate><sdate>20011126</sdate><edate/></pubdate></serial></article></nplcit><crossref idref="ncit0001">[0062]</crossref></li>
<li><nplcit id="ref-ncit0002" npl-type="b"><article><atl>Timing attacks on implementations of Diffie-Hellman, RSA, DSS, and other systems</atl><book><author><name>P. C. KOCHER</name></author><book-title>Advances in Cryptology - CRYPTO '96, volume 1109 of Lecture Notes in Computer Science</book-title><imprint><name>Springer</name><pubdate>19960000</pubdate></imprint><vid>1109</vid><location><pp><ppf>104</ppf><ppl>113</ppl></pp></location></book></article></nplcit><crossref idref="ncit0002">[0094]</crossref></li>
<li><nplcit id="ref-ncit0003" npl-type="b"><article><atl>Differential Power Analysis</atl><book><author><name>P. C. KOCHER</name></author><author><name>J. JAFFE</name></author><author><name>B. JUN</name></author><book-title>Advances in Cryptology - CRYPTO '99, volume 1666 of Lecture Notes in Computer Science</book-title><imprint><name>Springer</name><pubdate>19990000</pubdate></imprint><vid>1666</vid><location><pp><ppf>388</ppf><ppl>397</ppl></pp></location></book></article></nplcit><crossref idref="ncit0003">[0094]</crossref></li>
<li><nplcit id="ref-ncit0004" npl-type="b"><article><atl>Correlation Power Analysis with a Leakage Model</atl><book><author><name>E. BRIER</name></author><author><name>C. CLAVIER</name></author><author><name>F. OLIVIER</name></author><book-title>Cryptographic Hardware and Embedded Systems - CHES 2004, volume 3156 of Lecture Notes in Computer Science</book-title><imprint><name>Springer</name><pubdate>20040000</pubdate></imprint><vid>3156</vid><location><pp><ppf>16</ppf><ppl>29</ppl></pp></location></book></article></nplcit><crossref idref="ncit0004">[0094]</crossref></li>
<li><nplcit id="ref-ncit0005" npl-type="b"><article><atl>ElectroMagnetic Analysis (EMA): Measures and Counter-measures for Smart Cards</atl><book><author><name>J.-J. QUISQUATER</name></author><book-title>Smart Card Programming and Security</book-title><imprint><name>Springer</name><pubdate>20010000</pubdate></imprint><vid>2140</vid><location><pp><ppf>200</ppf><ppl>210</ppl></pp></location></book></article></nplcit><crossref idref="ncit0005">[0094]</crossref></li>
<li><nplcit id="ref-ncit0006" npl-type="b"><article><atl>Template Attacks</atl><book><author><name>S. CHARI</name></author><author><name>J. R. RAO</name></author><author><name>P. ROHATGI</name></author><book-title>CHES 2002. LNCS</book-title><imprint><name>Springer</name><pubdate>20030000</pubdate></imprint><vid>2523</vid><location><pp><ppf>172</ppf><ppl>186</ppl></pp></location></book></article></nplcit><crossref idref="ncit0006">[0094]</crossref></li>
<li><nplcit id="ref-ncit0007" npl-type="b"><article><atl>Mutual Information Analysis</atl><book><author><name>B. GIERLICHS</name></author><author><name>L. BATINA</name></author><author><name>P. TUYLS</name></author><author><name>B. PRENEEL</name></author><book-title>CHES 2008, volume 5154 of LNCS</book-title><imprint><name>Springer</name><pubdate>20080000</pubdate></imprint><vid>5154</vid><location><pp><ppf>426</ppf><ppl>442</ppl></pp></location></book></article></nplcit><crossref idref="ncit0007">[0094]</crossref></li>
<li><nplcit id="ref-ncit0008" npl-type="s"><article><author><name>DAESUNG KWON et al.</name></author><atl>New Block Cipher: ARIA</atl><serial><sertitle>Information Security and Cryptology - ICISC 2003, Volume 2971 of the series Lecture Notes in Computer Science</sertitle><vid>2971</vid></serial><location><pp><ppf>432</ppf><ppl>445</ppl></pp></location></article></nplcit><crossref idref="ncit0008">[0094]</crossref></li>
</ul></p>
</ep-reference-list>
</ep-patent-document>
