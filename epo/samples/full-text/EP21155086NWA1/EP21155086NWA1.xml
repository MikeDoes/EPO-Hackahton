<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE ep-patent-document PUBLIC "-//EPO//EP PATENT DOCUMENT 1.5.1//EN" "ep-patent-document-v1-5-1.dtd">
<!-- This XML data has been generated under the supervision of the European Patent Office -->
<ep-patent-document id="EP21155086A1" file="EP21155086NWA1.xml" lang="en" country="EP" doc-number="3889784" kind="A1" date-publ="20211006" status="n" dtd-version="ep-patent-document-v1-5-1">
<SDOBI lang="en"><B000><eptags><B001EP>ATBECHDEDKESFRGBGRITLILUNLSEMCPTIESILTLVFIROMKCYALTRBGCZEEHUPLSKBAHRIS..MTNORSMESMMAKHTNMD..........</B001EP><B005EP>J</B005EP><B007EP>BDM Ver 2.0.12 (4th of August) -  1100000/0</B007EP></eptags></B000><B100><B110>3889784</B110><B120><B121>EUROPEAN PATENT APPLICATION</B121></B120><B130>A1</B130><B140><date>20211006</date></B140><B190>EP</B190></B100><B200><B210>21155086.8</B210><B220><date>20210203</date></B220><B250>en</B250><B251EP>en</B251EP><B260>en</B260></B200><B300><B310>202011014116</B310><B320><date>20200330</date></B320><B330><ctry>IN</ctry></B330><B310>202016862831</B310><B320><date>20200430</date></B320><B330><ctry>US</ctry></B330></B300><B400><B405><date>20211006</date><bnum>202140</bnum></B405><B430><date>20211006</date><bnum>202140</bnum></B430></B400><B500><B510EP><classification-ipcr sequence="1"><text>G06F  11/36        20060101AFI20210809BHEP        </text></classification-ipcr></B510EP><B520EP><classifications-cpc><classification-cpc sequence="1"><text>G06F  11/3688      20130101 FI20210729BHEP        </text></classification-cpc></classifications-cpc></B520EP><B540><B541>de</B541><B542>TESTFALLOPTIMIERUNG UND -PRIORISIERUNG</B542><B541>en</B541><B542>TEST CASE OPTIMIZATION AND PRIORITIZATION</B542><B541>fr</B541><B542>OPTIMISATION ET PRIORISATION DES SCÉNARIOS D'ESSAI</B542></B540><B590><B598>1</B598></B590></B500><B700><B710><B711><snm>Accenture Global Solutions Limited</snm><iid>101607127</iid><irf>MJL/48650EP1</irf><adr><str>3 Grand Canal Plaza 
Grand Canal Street Upper</str><city>Dublin 4</city><ctry>IE</ctry></adr></B711></B710><B720><B721><snm>BHAT, Sam</snm><adr><str>1467 Irongate Drive</str><city>Pleasanton, California 94588</city><ctry>US</ctry></adr></B721><B721><snm>PATWARDHAN, Rohit Shrikant</snm><adr><str>M-17, Chaitanya Nagari
Near Kakade City</str><city>411058 Warje Pune Maharashtra</city><ctry>IN</ctry></adr></B721><B721><snm>JOGLEKAR, Rahul Ghanashyam</snm><adr><str>B-1007, Pebbles, Forest Trails
Opp. Manas Lake
Paud Road</str><city>412115 Pune</city><ctry>IN</ctry></adr></B721></B720><B740><B741><snm>Swindell &amp; Pearson Limited</snm><iid>101236117</iid><adr><str>48 Friar Gate</str><city>Derby DE1 1GY</city><ctry>GB</ctry></adr></B741></B740></B700><B800><B840><ctry>AL</ctry><ctry>AT</ctry><ctry>BE</ctry><ctry>BG</ctry><ctry>CH</ctry><ctry>CY</ctry><ctry>CZ</ctry><ctry>DE</ctry><ctry>DK</ctry><ctry>EE</ctry><ctry>ES</ctry><ctry>FI</ctry><ctry>FR</ctry><ctry>GB</ctry><ctry>GR</ctry><ctry>HR</ctry><ctry>HU</ctry><ctry>IE</ctry><ctry>IS</ctry><ctry>IT</ctry><ctry>LI</ctry><ctry>LT</ctry><ctry>LU</ctry><ctry>LV</ctry><ctry>MC</ctry><ctry>MK</ctry><ctry>MT</ctry><ctry>NL</ctry><ctry>NO</ctry><ctry>PL</ctry><ctry>PT</ctry><ctry>RO</ctry><ctry>RS</ctry><ctry>SE</ctry><ctry>SI</ctry><ctry>SK</ctry><ctry>SM</ctry><ctry>TR</ctry></B840><B844EP><B845EP><ctry>BA</ctry></B845EP><B845EP><ctry>ME</ctry></B845EP></B844EP><B848EP><B849EP><ctry>KH</ctry></B849EP><B849EP><ctry>MA</ctry></B849EP><B849EP><ctry>MD</ctry></B849EP><B849EP><ctry>TN</ctry></B849EP></B848EP></B800></SDOBI>
<abstract id="abst" lang="en">
<p id="pa01" num="0001">Methods, systems, and apparatuses, including computer programs encoded on computer-storage media, for prioritizing test cases. Processes may include obtaining test artifacts that were generated based on testing one or more legacy versions of a software application using multiple test cases, generating a risk index based at least on the test artifacts that were generated based on testing the one or more legacy versions of the software application using the multiple test cases, and training an ensemble model that is configured to identify likely unnecessary or redundant test cases in connection with in testing an updated version of the software application, based at least on the risk index.
<img id="iaf01" file="imgaf001.tif" wi="78" he="103" img-content="drawing" img-format="tif"/></p>
</abstract>
<description id="desc" lang="en"><!-- EPO <DP n="1"> -->
<heading id="h0001">FIELD</heading>
<p id="p0001" num="0001">This specification generally relates to software application test automation.</p>
<heading id="h0002">SUMMARY</heading>
<p id="p0002" num="0002">Software applications are designed to accommodate a multitude of transactions across different functional areas, where each transaction often requires the performance of a significant number of functions. Testing of software applications may include creating test cases based on requirements and then executing the test cases through, for example, a test script to detect defects.</p>
<p id="p0003" num="0003">Test cases may be automated using commercial and open source tools to reduce execution time. Once automated, these test cases can be executed repeatedly and frequently, which adds to the amount of testing coverage for the respective application. However, effective and efficient management of such suites of test cases is both time consuming and effort intensive.</p>
<p id="p0004" num="0004">The selection and prioritization of test cases for execution is generally performed under conditions of high uncertainty, including uncertainty regarding final application requirements, uncertainty regarding which functional areas need to be prioritized, scheduling uncertainty, and uncertainty regarding a determination of whether certain software behaviors are normal or anomalous. Given these uncertainties, it is not uncommon for redundant or unwanted test cases to be run, potentially increasing product backlog when the detection of defects is delayed.</p>
<p id="p0005" num="0005">Examples of redundant test cases include test cases that only identify anomalous software behaviors that are always detected by other test cases. Examples of unwanted or unnecessary test cases include test cases that never identify any defects. Executing unwanted or redundant<!-- EPO <DP n="2"> --> test cases can cause delays that can contribute to low productivity, diminishing the return on investment (ROI) for automated test scripting tools.</p>
<heading id="h0003">SUMMARY</heading>
<p id="p0006" num="0006">Implementations of the present specification are generally directed to prioritizing test cases for execution on an updated version of a software application based on features derived from test artifacts that resulted from executing the test cases on a legacy version of the software application. In one example, one feature that is used to prioritized test cases is a risk index, which is derived via a weighted aggregation of certain parameter values of features such as a count of test cases, a count of defects, and other features. Prioritization of test cases can reduce delays and free up computer resources associated with the execution of unnecessary or redundant test cases.</p>
<p id="p0007" num="0007">One general implementation includes the actions of obtaining test artifacts that were generated based on testing one or more legacy versions of a software application using multiple test cases, generating a risk index based at least on the test artifacts that were generated based on testing the one or more legacy versions of the software application using the multiple test cases, and training an ensemble model that is configured to identify likely unnecessary or redundant test cases in connection with in testing an updated version of the software application, based at least on the risk index. The actions also include generating, using the ensemble model, a score for each of the multiple test cases in connection with testing the updated version of the software application, and outputting data identifying one or more of the multiple test cases and, for each test case, the score in connection with testing the updated version of the software application.</p>
<p id="p0008" num="0008">Implementations may include one or more of the following features. The risk index may be generated for each functional area or module of the software application. Obtaining the test artifacts may include generating the test artifacts based on a test case execution history of executing the multiple test cases on the one or more legacy versions of the software application. The test artifacts may include data indicating a number of times each test case was executed, data indicating a priority that was assigned to each test case, data indicating a number of times that<!-- EPO <DP n="3"> --> each test case passed, data indicating a number of times that each test case failed, data indicating an execution status of each test case a first time that the test case was executed, and/or data indicating a sequence number associated with each test case that failed.</p>
<p id="p0009" num="0009">Additionally, generating the risk index based at least on the test artifacts that were generated based on testing the one or more legacy versions of the software application using the multiple test cases may include aggregating, for a particular functional area or module of the software application, a count of test cases that are associated with the particular functional area or module of the software application, a count of defects that are associated with the particular functional area or module of the software application, a value that represents a ratio of the count of test cases that are associated with the particular functional area or module of the software application to the count of defects that are associated with the particular functional area or module of the software application, and/or a count of defects that are associated with the particular functional area or module of the software application and that are indicated as high priority. The actions may include training, using the test artifacts, a natural language processing model to predict, for a given textual description associated with a given test case, whether the given test case is likely to pass or fail, where the ensemble model is trained further based on predictions that are generated for the multiple test cases using the natural language processing model.</p>
<p id="p0010" num="0010">Furthermore, the natural language processing model may be trained using pre-processed versions of original textual descriptions associated with test cases, where the pre-processing the original textual descriptions may include applying lowercase conversions, removing numbers, removing punctuation, removing stop words, removing extra whitespace, and applying word stemming or lemmatization. The ensemble model may be trained further based directly on a subset of the test artifacts. The subset of the test artifacts that are used directly to train the ensemble model may include data indicating a number of times each test case was executed, data indicating a number of times each test case passed, data indicating a number of times each test case filed, data indicating an execution status of each test case when the test case was first executed, and data indicating a sequence number associated with each test case that failed.<!-- EPO <DP n="4"> --></p>
<p id="p0011" num="0011">Moreover, the ensemble model may be trained further based on tunable parameters that define desired model metrics and a resource budget. Outputting data identifying one or more of the multiple test cases and, for each test case, the score in connection with testing the updated version of the software application may include generating and providing, for output, a ranked list of test cases on a user interface. The actions may include executing the multiple test cases on the second version of the software application in a prioritized order according to the score.</p>
<p id="p0012" num="0012">Other implementations of any of the above aspects include corresponding systems, apparatus, and/or computer programs that are configured to perform the operations of the methods. The present disclosure also provides a computer-readable storage medium coupled to one or more processors and having instructions stored thereon which, when executed by the one or more processors, cause the one or more processors to perform operations in accordance with implementations of the methods provided herein. The present disclosure further provides a system for implementing the methods provided herein. The system includes one or more computers, and one or more computer memory devices coupled to the one or more computers having instructions stored thereon which, when executed by the one or more computers, cause the one or more computers to perform operations in accordance with implementations of the methods provided herein.</p>
<p id="p0013" num="0013">These implementations may provide for several important technical advantages. For instance, by prioritizing test cases, test cases that are most likely to identify an important anomaly are identified for execution sooner than test cases that are unlikely to identify important anomalies, that are likely to not identify any anomalies at all, or that are likely to only identify anomalies that other test cases are also likely to identify. Computational resources are saved by not executing unwanted or redundant or unnecessary test cases. The early detection of defects reduces uncertainties that can lead to product backlog. Prioritization of test cases on updated versions of software applications can be performed using information that is already generated in the testing of legacy versions of the same software application, or of different software applications, eliminating additional or stand-alone feature generation operations.<!-- EPO <DP n="5"> --></p>
<p id="p0014" num="0014">It is appreciated that methods in accordance with the present disclosure can include any combination of the aspects and features described herein. That is, methods in accordance with the present disclosure are not limited to the combinations of aspects and features specifically described herein, but also may include any combination of the aspects and features provided.</p>
<p id="p0015" num="0015">The details of one or more implementations of the present disclosure are set forth in the accompanying drawings and the description below. Other features and advantages of the present disclosure will be apparent from the description and drawings, and from the claims.</p>
<heading id="h0004">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p0016" num="0016">
<ul id="ul0001" list-style="none" compact="compact">
<li><figref idref="f0001">FIG. 1</figref> illustrates an architecture for prioritizing test cases using ensemble learning.</li>
<li><figref idref="f0002">FIG. 2</figref> is a flowchart that illustrates a process for prioritizing test cases using ensemble learning.</li>
<li><figref idref="f0003">FIG. 3</figref> illustrates a user interface that depicts prioritized test cases, according to one example implementation.</li>
</ul></p>
<p id="p0017" num="0017">Like reference numbers and designations in the various drawings indicate like elements.</p>
<heading id="h0005">DETAILED DESCRIPTION</heading>
<p id="p0018" num="0018"><figref idref="f0001">FIG. 1</figref> illustrates an enhanced architecture 100 for prioritizing test cases of a test suite 102 using ensemble learning. At a high level, the enhanced architecture 100 uses multiple models, working together, to improve the selection, optimization, and/or prioritization of test cases that are to be executed on an updated version of a software application based on features derived from test artifacts that resulted from executing test cases on a legacy version of the software application. In one example, one feature that is used to prioritized test cases is a risk index, which is derived via a weighted aggregation of certain parameter values of features such as a count of test cases, a count of defects, and other features.<!-- EPO <DP n="6"> --></p>
<p id="p0019" num="0019">In more detail, the enhanced architecture 100 includes several components that are used to generate features and models that are used to prioritize test cases of the test suite 102, such as a test artifact generator that 104 is configured to generate test artifacts based on evaluating software using test cases, a feature extractor 106 that is configured to select, identify, or derive features from the test artifacts that are generated by the test artifact generator 104, and a risk algorithm generator 108 that is configured to consume the features that were extracted from the test artifacts, and to generate risk indices for test cases.</p>
<p id="p0020" num="0020">The enhanced architecture 100 also includes a data pre-processor 110 for consuming test case descriptions and outputting pre-processed text, and a model training system 112 that, based on the pre-processed text and class labels, is configured to generate natural language processing models that can predict test case outcomes based on natural language text included in test case descriptions that are associated with test cases by developers.</p>
<p id="p0021" num="0021">The enhanced architecture 100 also includes an ensemble model training engine 114 that, based on various features that are generated by other components of the enhanced architecture 100, is configured to generate ensemble models that can be used by a test case prioritizer 116 to generate prioritized lists of test cases of the test suite 102 (or of other test cases). Notably, training of the ensemble models can be performed using information, e.g., test artifacts 118, that was already generated in the testing of legacy versions of the same software application, or of different software applications, eliminating additional or stand-alone feature generation operations.</p>
<p id="p0022" num="0022">The operation of the enhanced architecture 100 is described below in connection with illustrated stages (A) through (H), below. In stage (A), the test suite 102, which may include a single test case, dozens of test cases, hundreds or thousands (or even more) of test cases, is executed on one or more legacy versions of a software application (in the Figure, "Example Software v1.0"), and test artifacts 118 are generated.</p>
<p id="p0023" num="0023">Test artifacts 118, which are generated as a result of executing the test suite 102 on the legacy versions of the software application, include status information that reflects various<!-- EPO <DP n="7"> --> metrics regarding the performance of each test case while testing the software application. Some of these metrics reflect information about the success or failure of the test case when an attempt was made to test functionality of the software application, such as whether the test case successfully executed to completion, the number of times that the test case was attempted or the number of times that execution of the test case was deemed successful or failed, and/or status information, such as a sequence number, associated with the test case when execution of the test case was attempted or was deemed successful or failed.</p>
<p id="p0024" num="0024">Features, such as parameter values, are extracted from the test artifacts 118 during stage (B), and, during stage (C), the risk algorithm generator 108 uses certain of the extracted features to generate a value for a risk index 120. A custom reinforced type algorithm may be used to calculate a score for a risk index for each of the functional areas of the software applications, or for each module of the software application that is under test. The score for the risk index can be bounded to a particular range, e.g., from 1 to 10, where 10 represents a highest risk.</p>
<p id="p0025" num="0025">Using features such as a requirement count, a test case count, an average requirement complexity, a defects count, a test cases to defects ratio, a requirements to defects ratio, a high requirement complexity average to high severity defects ratio, a high requirement complexity average to low severity defects ratio, Equation (1) can ingest values for each feature, and can be used to generate a weighted average for each parameter: <maths id="math0001" num="(1)"><math display="block"><mrow><mover><mi>x</mi><mrow><mo>‾</mo></mrow></mover><mo>=</mo><mfrac><mrow><mrow><mstyle displaystyle="false"><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover></mrow></mstyle><mrow><msub><mi>w</mi><mi>i</mi></msub><msub><mi>x</mi><mi>i</mi></msub></mrow></mrow></mrow><mrow><mrow><mstyle displaystyle="false"><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover></mrow></mstyle><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow></mrow></mrow></mfrac></mrow></math><img id="ib0001" file="imgb0001.tif" wi="119" he="12" img-content="math" img-format="tif"/></maths></p>
<p id="p0026" num="0026">Because the calculation of a risk index is a reinforced type algorithm, additional learning occurs as additional information is received, i.e., as the suite of test cases is executed on additional, interim versions of the software application.</p>
<p id="p0027" num="0027">Feature values can be weighted when combined to generate the value for the risk index. For instance, in one example calculation, a count of test cases can make up 10% of the value of the risk index, a count of defects can make up 10% of the value of the risk index, a test case to<!-- EPO <DP n="8"> --> defects ratio can make up 20% of the value of the risk index, a count of high priority defects can make up 10% of the value of the risk index, a high requirements complexity average to high defect severity ratio can make up 25% of the value of the risk index, a high requirement complexity average to low defect severity ratio can make up 5% of the value of the risk index, and a low requirement complexity average to low defect severity ratio can make up 20% of the value of the risk index. Other weightings or other feature values can be used in other risk index calculation algorithms.</p>
<p id="p0028" num="0028">In addition to generating the risk index 120, the enhanced architecture 100 may optionally generate an NLP-based model 122 by pre-processing test case description data that is associated with the test cases of the test suite 102 (at stage (D)), and by training the NLP-based model 122 (at stage (E)) using the pre-processed, test case description data.</p>
<p id="p0029" num="0029">The NLP-based model 122 can be trained using textual test case descriptions and pass-or-fail class labels, where the test case descriptions may optionally be pre-processed or otherwise standardized prior to model training. Test case descriptions are typically generated by test case developers to describe the object of each test case. Pre-processing the test case descriptions may include processes to convert test case descriptions to lower case, to remove numbers, punctuation, stop words or extra whitespace, or to apply word stemming or lemmatization.</p>
<p id="p0030" num="0030">Once trained the NLP-based model can provide an NLP-based prediction of a pass-or-fail outcome for an input test case description, which can be used as an optional, independent feature for an ensemble model. Training may occur using a random forest technique or other similar technique.</p>
<p id="p0031" num="0031">In other implementations, the NLP-based model 122 may be a machine learning model that includes one or more neural network layers. The machine learning model can include a convolutional neural network (CNN) embedding model. The CNN embedding model can include one or more LSTM layers and may be a deep LSTM neural network architecture built by stacking multiple LSTM layers. The CNN embedding model may be trained using a loss<!-- EPO <DP n="9"> --> function tuned for learning differentiation features. The different features can include triplet loss function, softmax loss function, or n-pairs loss function, to name a few examples.</p>
<p id="p0032" num="0032">Using the risk index 120 and, optionally, tunable parameters 124, feature values extracted from the test artifacts, and/or predictions that are output by the NLP-based model 122, the ensemble model training engine 114 can generate an ensemble model 126, at stage (F). The ensemble model 126 may use, as a feature set, a count of the number of times a test case has been executed, a count of a number of times the test case has passed, a number of times that the test case has failed, a status of the test case upon first execution, a sequence number for the test case when the test case failed, the value of the risk index, and an outcome prediction for the test case using the NLP-based model. Fewer or more features may be used.</p>
<p id="p0033" num="0033">Tunable parameters 124 that may be used to configure the ensemble model 126 may specify, for instance, a desired model metric, such as a desired F1 score or accuracy for the trained ensemble model 126, may define a budget, such as a number of training iterations, or may specify a best fit mode, such as hyper-parameterization.</p>
<p id="p0034" num="0034">In one example of how tunable parameters may affect outcomes, a tunable parameter may specify a budget of 100 iterations. The ensemble model training engine 114 can then train 100 machine learning models given the provided features, using different algorithms. Once all of the 100 algorithms are trained, the model having the best performance, e.g., as defined by a different tunable parameter, is chosen as the ensemble model 126.</p>
<p id="p0035" num="0035">The test case prioritizer 116 can use the ensemble model 126 to generate prioritized test cases. Specifically, the test case prioritizer 116 can use a custom algorithm that considers, for each test case, the prediction of the ensemble model 126 for the test case, the risk index value for the test case, and the priority assigned to the test case, to generate a risk score that is used to assign test cases to a category of "low risk," "medium risk," and "high risk" for risk-based testing.<!-- EPO <DP n="10"> --></p>
<p id="p0036" num="0036">In one example, the custom algorithm weights the prediction of the ensemble model 126 as 30% of the risk score, the value of the risk index as 50% of the risk score, and a value reflecting the priority assigned to the case as 20% of the risk score. Other weightings can be used.</p>
<p id="p0037" num="0037">When, at stage (G), an updated version 130 of a software application (in the Figure, "Example Software v2.0") is to be tested, the test case prioritizer 116 is configured to extract features of the test cases of the test suite 102, using feature extractor 132. By applying these features to the ensemble model 126, the test case prioritizer 116 is configured to, at stage (H), prioritize the test cases of the test suite 102. By prioritizing test cases, the test case prioritizer 116 is able to those test cases that are most likely to identify important anomalies, and, by this same logic, is able to identify those test cases that are unlikely to identify unique anomalies at all.</p>
<p id="p0038" num="0038">Prioritizing test cases of the test suite may include executing the most important, or the non-trivial cases on the second version of the software application, in a prioritized order, e.g., according to an order specified by the ensemble model 126. By bypassing unwanted, unnecessary or redundant test cases, computational resources are preserved, and notable defects are detected at an earlier time.</p>
<p id="p0039" num="0039"><figref idref="f0002">FIG. 2</figref> is a flowchart that illustrates a process 200 for prioritizing test cases using ensemble learning. Briefly, the process 200 includes the actions of obtaining test artifacts that were generated based on testing one or more legacy versions of a software application using multiple test cases, generating a risk index based at least on the test artifacts that were generated based on testing the one or more legacy versions of the software application using the multiple test cases, and training an ensemble model that is configured to identify likely unnecessary or redundant test cases in connection with in testing an updated version of the software application, based at least on the risk index. The actions also include generating, using the ensemble model, a score for each of the multiple test cases in connection with testing the updated version of the software application, and outputting data identifying one or more of the multiple test cases and,<!-- EPO <DP n="11"> --> for each test case, the score in connection with testing the updated version of the software application.</p>
<p id="p0040" num="0040">In more detail, when the process 200 begins (202), test artifacts that were generated based on testing one or more legacy versions of a software application using multiple test cases are obtained (204). Obtaining the test artifacts may include generating the test artifacts based on a test case execution history of executing the multiple test cases on the one or more legacy versions of the software application.</p>
<p id="p0041" num="0041">Test artifacts 118, which are generated as a result of executing the test suite 102 on the legacy versions of the software application, include status information that reflects various metrics regarding the performance of each test case while testing the software application. Some of these metrics reflect information about the success or failure of the test case when an attempt was made to test functionality of the software application, such as whether the test case successfully executed to completion, the number of times that the test case was attempted or the number of times that execution of the test case was deemed successful or failed, a status of the test case upon first execution, and/or status information, such as a sequence number, associated with the test case when execution of the test case was attempted or was deemed successful or failed.</p>
<p id="p0042" num="0042">Table 1, below, provides an example test execution history for an example suite of test cases. For each test case, for instance, the example test execution history includes a row of data indicating (i) a priority associated with each test case, (ii) a line of the test case that was executed, (iii) an execution status of the test case when the test case was first executed, (iv) a count of the number of times the test case was executed and passed, (v) a count of the number of times the test case was executed and failed, (vi) a risk index associated with the test case in the test execution history, (vii) a sequence number associated with the test case when the test case failed, and (viii) a class, e.g., 'passed' or 'failed' or 'indeterminate,' that was ultimately assigned to the test case. Fewer or more attributes can be included in the test execution history.<!-- EPO <DP n="12"> -->
<tables id="tabl0001" num="0001">
<table frame="all">
<title>Table 1: Example Test Execution History</title>
<tgroup cols="8">
<colspec colnum="1" colname="col1" colwidth="17mm"/>
<colspec colnum="2" colname="col2" colwidth="22mm"/>
<colspec colnum="3" colname="col3" colwidth="21mm"/>
<colspec colnum="4" colname="col4" colwidth="23mm"/>
<colspec colnum="5" colname="col5" colwidth="21mm"/>
<colspec colnum="6" colname="col6" colwidth="22mm"/>
<colspec colnum="7" colname="col7" colwidth="27mm"/>
<colspec colnum="8" colname="col8" colwidth="16mm"/>
<thead>
<row>
<entry align="center" valign="top"><b>TC_Priority</b></entry>
<entry align="center" valign="top"><b>TC_line_Executed</b></entry>
<entry align="center" valign="top"><b>TC_First_Status</b></entry>
<entry align="center" valign="top"><b>TC_Passed_Count</b></entry>
<entry align="center" valign="top"><b>TC_Failed_Count</b></entry>
<entry align="center" valign="top"><b>TC_Risk_Index</b></entry>
<entry align="center" valign="top"><b>TC_Failed_Seq_No</b></entry>
<entry align="center" valign="top"><b>class</b></entry></row></thead>
<tbody>
<row>
<entry align="center">1-Critical</entry>
<entry align="center">1</entry>
<entry align="center">Passed</entry>
<entry align="center">1</entry>
<entry align="center">0</entry>
<entry align="center">6</entry>
<entry align="center">0</entry>
<entry align="center">Passed</entry></row>
<row>
<entry align="center">2-High</entry>
<entry align="center">0</entry>
<entry align="center">Failed</entry>
<entry align="center">0</entry>
<entry align="center">0</entry>
<entry align="center">4</entry>
<entry align="center">0</entry>
<entry align="center">Failed</entry></row>
<row>
<entry align="center">1-Critical</entry>
<entry align="center">5</entry>
<entry align="center">Passed</entry>
<entry align="center">5</entry>
<entry align="center">0</entry>
<entry align="center">3</entry>
<entry align="center">0</entry>
<entry align="center">Passed</entry></row>
<row>
<entry align="center">1-Critical</entry>
<entry align="center">1</entry>
<entry align="center">Passed</entry>
<entry align="center">0</entry>
<entry align="center">0</entry>
<entry align="center">2</entry>
<entry align="center">0</entry>
<entry align="center">Failed</entry></row>
<row>
<entry align="center">2-High</entry>
<entry align="center">2</entry>
<entry align="center">Passed</entry>
<entry align="center">2</entry>
<entry align="center">0</entry>
<entry align="center">1</entry>
<entry align="center">0</entry>
<entry align="center">Failed</entry></row>
<row>
<entry align="center">3-Medium</entry>
<entry align="center">1</entry>
<entry align="center">Passed</entry>
<entry align="center">0</entry>
<entry align="center">0</entry>
<entry align="center">8</entry>
<entry align="center">0</entry>
<entry align="center">Failed</entry></row>
<row>
<entry align="center">1-Critical</entry>
<entry align="center">1</entry>
<entry align="center">Passed</entry>
<entry align="center">1</entry>
<entry align="center">0</entry>
<entry align="center">3</entry>
<entry align="center">0</entry>
<entry align="center">Failed</entry></row>
<row>
<entry align="center">1-Critical</entry>
<entry align="center">4</entry>
<entry align="center">Passed</entry>
<entry align="center">3</entry>
<entry align="center">1</entry>
<entry align="center">5</entry>
<entry align="center">1</entry>
<entry align="center">Failed</entry></row>
<row>
<entry align="center">2-High</entry>
<entry align="center">4</entry>
<entry align="center">Passed</entry>
<entry align="center">1</entry>
<entry align="center">3</entry>
<entry align="center">9</entry>
<entry align="center">2</entry>
<entry align="center">Failed</entry></row>
<row>
<entry align="center">1-Critical</entry>
<entry align="center">3</entry>
<entry align="center">Passed</entry>
<entry align="center">3</entry>
<entry align="center">0</entry>
<entry align="center">1</entry>
<entry align="center">1</entry>
<entry align="center">Failed</entry></row>
<row>
<entry align="center">1-Critical</entry>
<entry align="center">4</entry>
<entry align="center">Passed</entry>
<entry align="center">2</entry>
<entry align="center">2</entry>
<entry align="center">8</entry>
<entry align="center">1</entry>
<entry align="center">Failed</entry></row>
<row>
<entry align="center">2-High</entry>
<entry align="center">4</entry>
<entry align="center">Passed</entry>
<entry align="center">1</entry>
<entry align="center">3</entry>
<entry align="center">4</entry>
<entry align="center">2</entry>
<entry align="center">Failed</entry></row>
<row>
<entry align="center">3-Medium</entry>
<entry align="center">3</entry>
<entry align="center">Passed</entry>
<entry align="center">2</entry>
<entry align="center">1</entry>
<entry align="center">9</entry>
<entry align="center">1</entry>
<entry align="center">Failed</entry></row>
<row>
<entry align="center">3-Medium</entry>
<entry align="center">0</entry>
<entry align="center">Failed</entry>
<entry align="center">0</entry>
<entry align="center">0</entry>
<entry align="center">2</entry>
<entry align="center">0</entry>
<entry align="center">Failed</entry></row>
<row>
<entry align="center">3-Medium</entry>
<entry align="center">4</entry>
<entry align="center">Passed</entry>
<entry align="center">2</entry>
<entry align="center">2</entry>
<entry align="center">2</entry>
<entry align="center">2</entry>
<entry align="center">Failed</entry></row>
<row>
<entry align="center">4-Low</entry>
<entry align="center">2</entry>
<entry align="center">Passed</entry>
<entry align="center">1</entry>
<entry align="center">1</entry>
<entry align="center">3</entry>
<entry align="center">1</entry>
<entry align="center">Passed</entry></row>
<row>
<entry align="center">3-Medium</entry>
<entry align="center">3</entry>
<entry align="center">Passed</entry>
<entry align="center">2</entry>
<entry align="center">1</entry>
<entry align="center">4</entry>
<entry align="center">1</entry>
<entry align="center">Failed</entry></row>
<row>
<entry align="center">4-Low</entry>
<entry align="center">0</entry>
<entry align="center">Failed</entry>
<entry align="center">0</entry>
<entry align="center">0</entry>
<entry align="center">9</entry>
<entry align="center">0</entry>
<entry align="center">Failed</entry></row></tbody></tgroup>
</table>
</tables></p>
<p id="p0043" num="0043">A custom reinforced type algorithm may be used to calculate a score for a risk index for each of the functional areas of the software applications, or for each module of the software application that is under test. The score for the risk index can be bounded to a particular range, e.g., from 1 to 100, where 100 represents a highest risk.</p>
<p id="p0044" num="0044">As noted above, using features such as a requirement count, a test case count, an average requirement complexity, a defects count, a test cases to defects ratio, a requirements to defects ratio, a high requirement complexity average to high severity defects ratio, a high requirement complexity average to low severity defects ratio, Equation (1) (above) can ingest values for each feature, and can be used to generate a weighted average for each parameter. Because the calculation of a risk index is a reinforced type algorithm, additional learning occurs as additional information is received, i.e., as the suite of test cases is executed on additional, interim versions of the software application.<!-- EPO <DP n="13"> --></p>
<p id="p0045" num="0045">Additionally, generating the risk index based at least on the test artifacts that were generated based on testing the one or more legacy versions of the software application using the multiple test cases may include aggregating, for a particular functional area or module of the software application, a count of test cases that are associated with the particular functional area or module of the software application, a count of defects that are associated with the particular functional area or module of the software application, a value that represents a ratio of the count of test cases that are associated with the particular functional area or module of the software application to the count of defects that are associated with the particular functional area or module of the software application, and/or a count of defects that are associated with the particular functional area or module of the software application and that are indicated as high priority.</p>
<p id="p0046" num="0046">An NLP-based model may optionally be trained using textual test case descriptions and pass-or-fail class labels, where the test case descriptions may optionally be pre-processed or otherwise standardized. Pre-processing the test case descriptions may include processes to convert test case descriptions to lower case, to remove numbers, punctuation, stop words or extra whitespace, or to apply word stemming or lemmatization.</p>
<p id="p0047" num="0047">Once trained the NLP-based model can provide an NLP-based prediction of a pass-or-fail outcome for an input test case description, which can be used as an optional, independent feature for an ensemble model. The NLP-based model looks at specific words in the test case description for new test cases, and can predict a pass-or-fail outcome for the new test cases based on historical results for other test cases.</p>
<p id="p0048" num="0048">An ensemble model that is configured to identify likely unnecessary or redundant test cases in connection with in testing an updated version of the software application is trained, based at least on the risk index (208). Ensemble model training can involve auto-algorithm selection, as well as hyper-parameterization selection.</p>
<p id="p0049" num="0049">In one example implementation, the ensemble model may use, as a feature set, a count of the number of times a test case has been executed, a count of a number of times the test case has<!-- EPO <DP n="14"> --> passed, a number of times that the test case has failed, a status of the test case upon first execution, a sequence number for the test case when the test case failed, the value of the risk index, and an outcome prediction for the test case using the NLP-based model. Fewer or more features may be used.</p>
<p id="p0050" num="0050">In other implementations, the NLP-based model may be a machine learning model that includes one or more neural network layers. The machine learning model can include a convolutional neural network (CNN) embedding model. The CNN embedding model can include one or more LSTM layers, and may be a deep LSTM neural network architecture built by stacking multiple LSTM layers. The CNN embedding model may be trained using a loss function tuned for learning differentiation features. The different features can include triplet loss function, softmax loss function, or n-pairs loss function, to name a few examples.</p>
<p id="p0051" num="0051">Moreover, the ensemble model may be trained further based on tunable parameters that define desired model metrics and a resource budget. These tunable parameters may specify parameters such as a desired F1 score or accuracy for the trained ensemble model, may define a budget, or may specify a best fit mode. A tunable parameter may specify a budget of a particular number of iterations. The ensemble model training engine may then then train that particular number of machine learning models given the provided features, using various different algorithms and, once all of the algorithms are trained, the model having the best performance may be chosen as the ensemble model.</p>
<p id="p0052" num="0052">Using the ensemble model, a score for each of the multiple test cases is generated in connection with testing the updated version of the software application (210). Specifically, a test case prioritizer can use an algorithm that considers, for each test case, the prediction of the ensemble model the test case, the risk index value for the test case, and the priority assigned to the test case, to generate a risk score that is used to assign test cases to a category of "low risk," "medium risk," and "high risk" for risk-based testing.</p>
<p id="p0053" num="0053">Data is output that identifies one or more of the multiple test cases and, for each test case, the score in connection with testing the updated version of the software application (212),<!-- EPO <DP n="15"> --> thereby ending the process 200 (214). This data may include, for example, a ranked list of test cases, that is provided for display in a user interface. The test cases may also be executed in their prioritized order on the second version of the software application.</p>
<p id="p0054" num="0054">In summary, through the use of process 200, test cases that are most likely to identify an important anomaly are identified for execution sooner than test cases that are unlikely to identify important anomalies, that are likely to not identify any anomalies at all, or that are likely to only identify anomalies that other test cases are also likely to identify. Computational resources are preserved through implementation of the process 200 by not executing unwanted or redundant or unnecessary test cases. The early detection of defects reduces uncertainties that can lead to product backlog. Prioritization of test cases on updated versions of software applications can be performed using information that is already generated in the testing of legacy versions of the same software application, or of different software applications, eliminating additional or stand-alone feature generation operations.</p>
<p id="p0055" num="0055"><figref idref="f0003">FIG 3</figref> illustrates a user interface 300 that depicts prioritized test cases, according to one example implementation. Specifically, user interface 300 ranks the test cases in a suggested execution order, deprecating those test cases that are identified by the enhanced techniques described by this specification as redundant or unnecessary. A first column 302 of the user interface 300 indicates a test identifier for each test case, and a second column 304 of the user interface indicates a priority that is assigned to each test case. Other information, such as an owner name that is associated with each case, or a risk level or score associated with each test case or with a suite of test case may also optionally be illustrated.</p>
<p id="p0056" num="0056">A number of implementations have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the disclosure. For example, various forms of the flows shown above may be used, with steps reordered, added, or removed.</p>
<p id="p0057" num="0057">Embodiments of the invention and all of the functional operations described in this specification can be implemented in digital electronic circuitry, or in computer software,<!-- EPO <DP n="16"> --> firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the invention can be implemented as one or more computer program products, e.g., one or more modules of computer program instructions encoded on a computer readable medium for execution by, or to control the operation of, data processing apparatus. The computer readable medium can be a machine-readable storage device, a machine-readable storage substrate, a memory device, a composition of matter affecting a machine-readable propagated signal, or a combination of one or more of them. The term "data processing apparatus" encompasses all apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them. A propagated signal is an artificially generated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus.</p>
<p id="p0058" num="0058">A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.</p>
<p id="p0059" num="0059">The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be<!-- EPO <DP n="17"> --> performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).</p>
<p id="p0060" num="0060">Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices.</p>
<p id="p0061" num="0061">Moreover, a computer can be embedded in another device, e.g., a tablet computer, a mobile telephone, a personal digital assistant (PDA), a mobile audio player, a Global Positioning System (GPS) receiver, to name just a few. Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.</p>
<p id="p0062" num="0062">To provide for interaction with a user, embodiments of the invention can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.<!-- EPO <DP n="18"> --></p>
<p id="p0063" num="0063">Embodiments of the invention can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the invention, or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network ("LAN") and a wide area network ("WAN"), e.g., the Internet.</p>
<p id="p0064" num="0064">The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.</p>
<p id="p0065" num="0065">While this specification contains many specifics, these should not be construed as limitations on the scope of the invention or of what may be claimed, but rather as descriptions of features specific to particular embodiments of the invention. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.</p>
<p id="p0066" num="0066">Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be<!-- EPO <DP n="19"> --> understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.</p>
<p id="p0067" num="0067">In each instance where an HTML file is mentioned, other file types or formats may be substituted. For instance, an HTML file may be replaced by an XML, JSON, plain text, or other types of files. Moreover, where a table or hash table is mentioned, other data structures (such as spreadsheets, relational databases, or structured files) may be used.</p>
<p id="p0068" num="0068">Particular embodiments of the invention have been described. Other embodiments are within the scope of the following claims. For example, the steps recited in the claims can be performed in a different order and still achieve desirable results.</p>
</description>
<claims id="claims01" lang="en"><!-- EPO <DP n="20"> -->
<claim id="c-en-0001" num="0001">
<claim-text>A computer-implemented method comprising:
<claim-text>obtaining test artifacts that were generated based on testing one or more legacy versions of a software application using multiple test cases;</claim-text>
<claim-text>generating a risk index based at least on the test artifacts that were generated based on testing the one or more legacy versions of the software application using the multiple test cases;</claim-text>
<claim-text>training an ensemble model that is configured to identify likely unnecessary or redundant test cases in connection with in testing an updated version of the software application, based at least on the risk index; and</claim-text>
<claim-text>generating, using the ensemble model, a score for each of the multiple test cases in connection with testing the updated version of the software application; and</claim-text>
<claim-text>outputting data identifying one or more of the multiple test cases and, for each test case, the score in connection with testing the updated version of the software application.</claim-text></claim-text></claim>
<claim id="c-en-0002" num="0002">
<claim-text>The method of claim 1, wherein the risk index is generated for each functional area or module of the software application.</claim-text></claim>
<claim id="c-en-0003" num="0003">
<claim-text>The method of claim 1 or 2, wherein obtaining the test artifacts comprises generating the test artifacts based on a test case execution history of executing the multiple test cases on the one or more legacy versions of the software application.</claim-text></claim>
<claim id="c-en-0004" num="0004">
<claim-text>The method of any of the preceding claims, wherein the test artifacts comprise:
<claim-text>data indicating a number of times each test case was executed,</claim-text>
<claim-text>data indicating a priority that was assigned to each test case,</claim-text>
<claim-text>data indicating a number of times that each test case passed,</claim-text>
<claim-text>data indicating a number of times that each test case failed,</claim-text>
<claim-text>data indicating an execution status of each test case a first time that the test case was executed, and</claim-text>
<claim-text>data indicating a sequence number associated with each test case that failed.</claim-text><!-- EPO <DP n="21"> --></claim-text></claim>
<claim id="c-en-0005" num="0005">
<claim-text>The method of any of the preceding claims, wherein generating the risk index based at least on the test artifacts that were generated based on testing the one or more legacy versions of the software application using the multiple test cases comprises:<br/>
aggregating, for a particular functional area or module of the software application:
<claim-text>a count of test cases that are associated with the particular functional area or module of the software application,</claim-text>
<claim-text>a count of defects that are associated with the particular functional area or module of the software application,</claim-text>
<claim-text>a value that represents a ratio of the count of test cases that are associated with the particular functional area or module of the software application to the count of defects that are associated with the particular functional area or module of the software application, and</claim-text>
<claim-text>a count of defects that are associated with the particular functional area or module of the software application and that are indicated as high priority.</claim-text></claim-text></claim>
<claim id="c-en-0006" num="0006">
<claim-text>The method of any of the preceding claims, further comprising:
<claim-text>training, using the test artifacts, a natural language processing model to predict, for a given textual description associated with a given test case, whether the given test case is likely to pass or fail,</claim-text>
<claim-text>wherein the ensemble model is trained further based on predictions that are generated for the multiple test cases using the natural language processing model.</claim-text></claim-text></claim>
<claim id="c-en-0007" num="0007">
<claim-text>The method of any of the preceding claims, wherein the natural language processing model is trained using pre-processed versions of original textual descriptions associated with test cases, and wherein the pre-processing the original textual descriptions comprises applying lowercase conversions, removing numbers, removing punctuation, removing stop words, removing extra whitespace, and applying word stemming or lemmatization.</claim-text></claim>
<claim id="c-en-0008" num="0008">
<claim-text>The method of any of the preceding claims, wherein the ensemble model is trained further based directly on a subset of the test artifacts.<!-- EPO <DP n="22"> --></claim-text></claim>
<claim id="c-en-0009" num="0009">
<claim-text>The method of any of the preceding claims, wherein the subset of the test artifacts that are used directly to train the ensemble model comprise data indicating a number of times each test case was executed, data indicating a number of times each test case passed, data indicating a number of times each test case filed, data indicating an execution status of each test case when the test case was first executed, and data indicating a sequence number associated with each test case that failed.</claim-text></claim>
<claim id="c-en-0010" num="0010">
<claim-text>The method of any of the preceding claims, wherein the ensemble model is trained further based on tunable parameters that define desired model metrics and a resource budget.</claim-text></claim>
<claim id="c-en-0011" num="0011">
<claim-text>The method of any of the preceding claims, wherein outputting data identifying one or more of the multiple test cases and, for each test case, the score in connection with testing the updated version of the software application comprises generating and providing, for output, a ranked list of test cases on a user interface.</claim-text></claim>
<claim id="c-en-0012" num="0012">
<claim-text>The method of any of the preceding claims, comprising executing the multiple test cases on the second version of the software application in a prioritized order according to the score.</claim-text></claim>
<claim id="c-en-0013" num="0013">
<claim-text>Computer program instructions that, when executed by one or more processors, cause the method of one or more of the preceding claims to be performed.</claim-text></claim>
<claim id="c-en-0014" num="0014">
<claim-text>A system comprising:
<claim-text>one or more computers; and</claim-text>
<claim-text>one or more computer memory devices interoperably coupled with the one or more computers storing one or more instructions that, when executed by the one or more computers, perform one or more operations comprising:
<claim-text>obtaining test artifacts that were generated based on testing one or more legacy versions of a software application using multiple test cases;</claim-text>
<claim-text>generating a risk index based at least on the test artifacts that were generated based on testing the one or more legacy versions of the software application using the multiple test cases;<!-- EPO <DP n="23"> --></claim-text>
<claim-text>training an ensemble model that is configured to identify likely unnecessary or redundant test cases in connection with in testing an updated version of the software application, based at least on the risk index; and</claim-text>
<claim-text>generating, using the ensemble model, a score for each of the multiple test cases in connection with testing the updated version of the software application; and</claim-text></claim-text>
<claim-text>outputting data identifying one or more of the multiple test cases and, for each test case, the score in connection with testing the updated version of the software application.</claim-text></claim-text></claim>
<claim id="c-en-0015" num="0015">
<claim-text>The system of claim 14, wherein the instructions are configured, when executed by the one or more computers, to cause the one or more computers to perform the method of one or more of claims 2 to 12.</claim-text></claim>
</claims>
<drawings id="draw" lang="en"><!-- EPO <DP n="24"> -->
<figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="165" he="217" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="25"> -->
<figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="87" he="172" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="26"> -->
<figure id="f0003" num="3"><img id="if0003" file="imgf0003.tif" wi="153" he="226" img-content="drawing" img-format="tif"/></figure>
</drawings>
<search-report-data id="srep" lang="en" srep-office="EP" date-produced=""><doc-page id="srep0001" file="srep0001.tif" wi="151" he="233" type="tif"/><doc-page id="srep0002" file="srep0002.tif" wi="151" he="233" type="tif"/></search-report-data><search-report-data date-produced="20210729" id="srepxml" lang="en" srep-office="EP" srep-type="ep-sr" status="n"><!--
 The search report data in XML is provided for the users' convenience only. It might differ from the search report of the PDF document, which contains the officially published data. The EPO disclaims any liability for incorrect or incomplete data in the XML for search reports.
 -->

<srep-info><file-reference-id>MJL/48650EP1</file-reference-id><application-reference><document-id><country>EP</country><doc-number>21155086.8</doc-number></document-id></application-reference><applicant-name><name>Accenture Global Solutions Limited</name></applicant-name><srep-established srep-established="yes"/><srep-invention-title title-approval="yes"/><srep-abstract abs-approval="yes"/><srep-figure-to-publish figinfo="by-applicant"><figure-to-publish><fig-number>1</fig-number></figure-to-publish></srep-figure-to-publish><srep-info-admin><srep-office><addressbook><text>MN</text></addressbook></srep-office><date-search-report-mailed><date>20210813</date></date-search-report-mailed></srep-info-admin></srep-info><srep-for-pub><srep-fields-searched><minimum-documentation><classifications-ipcr><classification-ipcr><text>G06F</text></classification-ipcr><classification-ipcr><text>G06N</text></classification-ipcr></classifications-ipcr></minimum-documentation></srep-fields-searched><srep-citations><citation id="sr-cit0001"><nplcit id="sr-ncit0001" npl-type="w"><online><author><name>LACHMANN REMO</name></author><online-title>Machine Learning-Driven Test Case Prioritization Approaches for Black-Box Software Testing</online-title><serial><sertitle>THE EUROPEAN TEST AND TELEMETRY CONFERENCE, ETTC2018</sertitle></serial><pubdate>20180628</pubdate><location><pp><ppf>300</ppf><ppl>309</ppl></pp></location><avail>https://www.ama-science.org/proceedings/getFile/ZwtmZt==</avail><refno>XP055776510</refno></online></nplcit><category>Y</category><rel-claims>1-4,6-15</rel-claims><category>A</category><rel-claims>5</rel-claims><rel-passage><passage>* abstract *</passage></rel-passage><rel-passage><passage>* page 300 - page 305 *</passage><passage>* page 308 *</passage></rel-passage></citation><citation id="sr-cit0002"><nplcit id="sr-ncit0002" npl-type="s"><article><author><name>ANDERSON C ET AL</name></author><atl>ON THE USE OF NEURAL NETWORKS TO GUIDE SOFTWARE TESTING ACTIVITIES</atl><serial><sertitle>PROCEEDINGS OF THE INTERNATIONAL TEST CONFERENCE (ITC). WASHINGTON, OCT. 21 - 25, 1995; [PROCEEDINGS OF THE INTERNATIONAL TEST CONFERENCE (ITC)], NEW YORK, IEEE, US</sertitle><pubdate>19951021</pubdate><doi>10.1109/TEST.1995.529902</doi><isbn>978-0-7803-2992-8</isbn></serial><location><pp><ppf>720</ppf><ppl>729</ppl></pp></location><refno>XP000552875</refno></article></nplcit><category>Y</category><rel-claims>1-4,6-15</rel-claims><rel-passage><passage>* abstract *</passage><passage>* page 720 *</passage><passage>* page 722 - page 727 *</passage></rel-passage></citation><citation id="sr-cit0003"><nplcit id="sr-ncit0003" npl-type="s"><article><author><name>LACHMANN REMO ET AL</name></author><atl>System-Level Test Case Prioritization Using Machine Learning</atl><serial><sertitle>2016 15TH IEEE INTERNATIONAL CONFERENCE ON MACHINE LEARNING AND APPLICATIONS (ICMLA), IEEE</sertitle><pubdate>20161218</pubdate><doi>10.1109/ICMLA.2016.0065</doi></serial><location><pp><ppf>361</ppf><ppl>368</ppl></pp></location><refno>XP033055548</refno></article></nplcit><category>A</category><rel-claims>1-15</rel-claims><rel-passage><passage>* page 361 - page 364 *</passage></rel-passage></citation><citation id="sr-cit0004"><nplcit id="sr-ncit0004" npl-type="s"><article><author><name>SEPEHR EGHBALI ET AL</name></author><atl>Supervised tie breaking in test case prioritization</atl><serial><sertitle>SOFTWARE ENGINEERING, IEEE PRESS, 445 HOES LANE, PO BOX 1331, PISCATAWAY, NJ08855-1331USA</sertitle><pubdate>20190525</pubdate><doi>10.1109/ICSE-COMPANION.2019.00095</doi></serial><location><pp><ppf>242</ppf><ppl>243</ppl></pp></location><refno>XP058432922</refno></article></nplcit><category>A</category><rel-claims>1-15</rel-claims><rel-passage><passage>* abstract *</passage><passage>* page 242 - page 243 *</passage></rel-passage></citation></srep-citations><srep-admin><examiners><primary-examiner><name>Alonso Nogueiro, L</name></primary-examiner></examiners><srep-office><addressbook><text>Munich</text></addressbook></srep-office><date-search-completed><date>20210729</date></date-search-completed></srep-admin></srep-for-pub></search-report-data>
</ep-patent-document>
