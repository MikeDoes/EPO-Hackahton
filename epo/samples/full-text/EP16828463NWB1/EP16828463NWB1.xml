<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE ep-patent-document PUBLIC "-//EPO//EP PATENT DOCUMENT 1.5.1//EN" "ep-patent-document-v1-5-1.dtd">
<!-- This XML data has been generated under the supervision of the European Patent Office -->
<ep-patent-document id="EP16828463B1" file="EP16828463NWB1.xml" lang="en" country="EP" doc-number="3326345" kind="B1" date-publ="20211006" status="n" dtd-version="ep-patent-document-v1-5-1">
<SDOBI lang="en"><B000><eptags><B001EP>ATBECHDEDKESFRGBGRITLILUNLSEMCPTIESILTLVFIROMKCYALTRBGCZEEHUPLSK..HRIS..MTNORS..SM..................</B001EP><B003EP>*</B003EP><B005EP>J</B005EP><B007EP>BDM Ver 2.0.12 (4th of August) -  2100000/0</B007EP></eptags></B000><B100><B110>3326345</B110><B120><B121>EUROPEAN PATENT SPECIFICATION</B121></B120><B130>B1</B130><B140><date>20211006</date></B140><B190>EP</B190></B100><B200><B210>16828463.6</B210><B220><date>20160720</date></B220><B240><B241><date>20180221</date></B241><B242><date>20191106</date></B242></B240><B250>en</B250><B251EP>en</B251EP><B260>en</B260></B200><B300><B310>201514804713</B310><B320><date>20150721</date></B320><B330><ctry>US</ctry></B330></B300><B400><B405><date>20211006</date><bnum>202140</bnum></B405><B430><date>20180530</date><bnum>201822</bnum></B430><B450><date>20211006</date><bnum>202140</bnum></B450><B452EP><date>20210429</date></B452EP></B400><B500><B510EP><classification-ipcr sequence="1"><text>H04L  29/06        20060101AFI20190219BHEP        </text></classification-ipcr><classification-ipcr sequence="2"><text>H04L   9/00        20060101ALI20190219BHEP        </text></classification-ipcr><classification-ipcr sequence="3"><text>G06F  21/14        20130101ALI20190219BHEP        </text></classification-ipcr></B510EP><B520EP><classifications-cpc><classification-cpc sequence="1"><text>H04L  63/0407      20130101 FI20170126BHEP        </text></classification-cpc><classification-cpc sequence="2"><text>H04L   9/008       20130101 LI20170126BHEP        </text></classification-cpc><classification-cpc sequence="3"><text>H04L2209/046       20130101 LA20170217BHEP        </text></classification-cpc><classification-cpc sequence="4"><text>H04L  63/0428      20130101 LA20170126BHEP        </text></classification-cpc><classification-cpc sequence="5"><text>H04L2209/16        20130101 LA20170217BHEP        </text></classification-cpc><classification-cpc sequence="6"><text>G06F  21/14        20130101 LI20190213BHEP        </text></classification-cpc><classification-cpc sequence="7"><text>H04L  63/18        20130101 LA20170307BHEP        </text></classification-cpc></classifications-cpc></B520EP><B540><B541>de</B541><B542>SYSTEME UND VERFAHREN ZUR AUSFÜHRUNG VERTRAULICHER PROGRAMME AUF UNSICHEREN COMPUTERN</B542><B541>en</B541><B542>SYSTEMS AND PROCESSES FOR EXECUTING PRIVATE PROGRAMS ON UNTRUSTED COMPUTERS</B542><B541>fr</B541><B542>SYSTÈMES ET PROCÉDÉS POUR EXÉCUTER DES PROGRAMMES PRIVÉS SUR DES ORDINATEURS NON SÉCURISÉS</B542></B540><B560><B561><text>US-A1- 2006 259 744</text></B561><B561><text>US-A1- 2011 225 417</text></B561><B561><text>US-A1- 2012 066 510</text></B561><B561><text>US-A1- 2012 159 459</text></B561><B561><text>US-A1- 2012 185 946</text></B561><B561><text>US-A1- 2014 331 279</text></B561><B561><text>US-B1- 7 430 670</text></B561><B561><text>US-B1- 9 055 038</text></B561><B562><text>Sau-Koon Ng: "Protecting Mobile Agents Against Malicious Hosts", , June 2000 (2000-06), XP055557095, Hong Kong Retrieved from the Internet: URL:https://pdfs.semanticscholar.org/fd03/ 8f2757816f23bab1e00ba3c708e470e895e8.pdf?_ ga=2.202210838.685786396.1550045552-638021 229.1550045552 [retrieved on 2019-02-14]</text></B562><B565EP><date>20190225</date></B565EP></B560></B500><B700><B720><B721><snm>SIDANA, Ashmeet</snm><adr><str>1175 Stanley Way</str><city>Palo Alto, CA 94303</city><ctry>US</ctry></adr></B721><B721><snm>KOLTE, Priyadarshan</snm><adr><str>7239 Villa Maria Lane</str><city>Austin, TX 78759</city><ctry>US</ctry></adr></B721><B721><snm>LIN, Calvin</snm><adr><str>8408 Lone Mesa</str><city>Austin, TX 78759</city><ctry>US</ctry></adr></B721></B720><B730><B731><snm>Baffle, Inc.</snm><iid>101647525</iid><irf>P072542EP</irf><adr><str>3945 Freedom Circle 
Suite 450</str><city>Santa Clara, CA 95054</city><ctry>US</ctry></adr></B731></B730><B740><B741><snm>Carpmaels &amp; Ransford LLP</snm><iid>101299776</iid><adr><str>One Southampton Row</str><city>London WC1B 5HA</city><ctry>GB</ctry></adr></B741></B740></B700><B800><B840><ctry>AL</ctry><ctry>AT</ctry><ctry>BE</ctry><ctry>BG</ctry><ctry>CH</ctry><ctry>CY</ctry><ctry>CZ</ctry><ctry>DE</ctry><ctry>DK</ctry><ctry>EE</ctry><ctry>ES</ctry><ctry>FI</ctry><ctry>FR</ctry><ctry>GB</ctry><ctry>GR</ctry><ctry>HR</ctry><ctry>HU</ctry><ctry>IE</ctry><ctry>IS</ctry><ctry>IT</ctry><ctry>LI</ctry><ctry>LT</ctry><ctry>LU</ctry><ctry>LV</ctry><ctry>MC</ctry><ctry>MK</ctry><ctry>MT</ctry><ctry>NL</ctry><ctry>NO</ctry><ctry>PL</ctry><ctry>PT</ctry><ctry>RO</ctry><ctry>RS</ctry><ctry>SE</ctry><ctry>SI</ctry><ctry>SK</ctry><ctry>SM</ctry><ctry>TR</ctry></B840><B860><B861><dnum><anum>US2016043117</anum></dnum><date>20160720</date></B861><B862>en</B862></B860><B870><B871><dnum><pnum>WO2017015357</pnum></dnum><date>20170126</date><bnum>201704</bnum></B871></B870></B800></SDOBI>
<description id="desc" lang="en"><!-- EPO <DP n="1"> -->
<heading id="h0001"><b>FIELD OF THE INVENTION</b></heading>
<p id="p0001" num="0001">The disclosed invention is in the field of computing security.</p>
<heading id="h0002"><b>BACKGROUND OF THE INVENTION</b></heading>
<p id="p0002" num="0002">Security in remote computer program execution is a continuous battle, especially with the recent surge in cloud networks and expanded enterprise networks, allowing users unfettered access to large networks of computers. The combined power and speed of program execution on multiple computers is advantageous, but may also be subject to prying eyes. Any or all of the remote computers may be under the control of a malicious user or attacker, compromising precious confidential information.</p>
<p id="p0003" num="0003">Thus, there is a need for a method and system to execute a program on an untrusted computer, or plurality of computers, such that the executing program and data is kept private from an attacker that has complete access to the untrusted computer(s). The invention is directed to these and other important needs.</p>
<p id="p0004" num="0004">Document <patcit id="pcit0001" dnum="US2012185946A"><text>US 2012/185946</text></patcit> discloses splitting input values across cloud servers and recombining the results by a trusted entity.</p>
<heading id="h0003"><b>SUMMARY OF THE INVENTION</b></heading>
<p id="p0005" num="0005">The present invention provides a method and a system as specified in the claims.<!-- EPO <DP n="2"> --></p>
<p id="p0006" num="0006">The general description and the following detailed description are exemplary and explanatory only and are not restrictive of the invention, as defined in the appended claims. Other aspects of the present invention will be apparent to those skilled in the art in view of the detailed description of the invention as provided herein.</p>
<heading id="h0004"><b>BRIEF DESCRIPTION OF THE DRAWINGS</b></heading>
<p id="p0007" num="0007">The summary, as well as the following detailed description, is further understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there are shown in the drawings exemplary embodiments of the invention; however, the invention is not limited to the specific methods, compositions, and devices disclosed. In addition, the drawings are not necessarily drawn to scale. In the drawings:
<ul id="ul0001" list-style="none" compact="compact">
<li><figref idref="f0001"><b>FIG 1</b></figref> illustrates an embodiment of the present invention directed to shredding a program across networked computers;</li>
<li><figref idref="f0002"><b>FIG 2</b></figref> illustrates an embodiment of the present invention directed to split device driver operation;</li>
<li><figref idref="f0003"><b>FIG 3</b></figref> illustrates an embodiment of the present invention directed to symmetric-key encryption and decryption operations for shreds of code and data;</li>
<li><figref idref="f0004"><b>FIG 4</b></figref> illustrates an embodiment of the present invention directed to obfuscating shreds;</li>
<li><figref idref="f0005"><b>FIG 5</b></figref> illustrates an embodiment of the present invention directed to shredding a circuit gate operation;</li>
<li><figref idref="f0006"><b>FIG 6</b></figref> illustrates an embodiment of the present invention directed to shredding another circuit gate operation;</li>
<li><figref idref="f0007"><b>FIG 7</b></figref> illustrates an embodiment of the present invention directed to shredding a circuit gate operation with an additional layer of obfuscation;</li>
<li><figref idref="f0008"><b>FIG 8</b></figref> illustrates an embodiment of the present invention directed to shredding an arbitrary circuit of gate operations on a network of computers;</li>
<li><figref idref="f0009"><b>FIG 9</b></figref> illustrates an embodiment of the present invention directed to shredding an operation with added encryption;<!-- EPO <DP n="3"> --></li>
<li><figref idref="f0010"><b>FIG 10</b></figref> illustrates normal device driver operation;</li>
<li><figref idref="f0011"><b>FIG 11</b></figref> illustrates an embodiment of the present invention directed to split device driver operation;</li>
<li><figref idref="f0012"><b>FIG 12</b></figref> illustrates an embodiment of the present invention directed to shredding a mathematical operation;</li>
<li><figref idref="f0013"><b>FIG 13</b></figref> illustrates an embodiment of the present invention directed to shredding another mathematical operation;</li>
<li><figref idref="f0014"><b>FIG 14</b></figref> illustrates an embodiment of the present invention directed to shredding a transition encryption function;</li>
<li><figref idref="f0015"><b>FIG 15</b></figref> illustrates an embodiment of the present invention directed to shredding another transition encryption function;</li>
<li><figref idref="f0016"><b>FIG 16</b></figref> illustrates an embodiment of the present invention directed to shredding an encrypted comparison operation;</li>
<li><figref idref="f0017"><b>FIG 17</b></figref> illustrates an embodiment of the present invention directed to shredding another encrypted comparison operation;</li>
<li><figref idref="f0018"><b>FIG 18</b></figref> illustrates an embodiment of the present invention directed to shredding a mathematical obfuscation transition function; and</li>
<li><figref idref="f0019"><b>FIG 19</b></figref> illustrates an embodiment of the present invention directed to shredding another mathematical obfuscation transition function.</li>
</ul></p>
<heading id="h0005"><b>DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS</b></heading>
<p id="p0008" num="0008">The present invention may be understood more readily by reference to the following detailed description taken in connection with the accompanying figures and examples, which form a part of this disclosure. It is to be understood that this invention is not limited to the specific devices, methods, applications, conditions or parameters described and/or shown herein, and that the terminology used herein is for the purpose of describing particular embodiments by way of example only and is not intended to be limiting of the claimed invention. Also, as used in the specification including the appended claims, the singular forms "a," "an," and "the" include the plural, and reference to a particular numerical value includes at least that particular value, unless the context clearly dictates otherwise. The term "plurality", as used herein, means more than one. When a range of values is expressed, another embodiment includes from the one particular value and/or to the other particular value. Similarly, when values are expressed as approximations, by use of the antecedent "about," it will be understood that the particular value forms another embodiment. All ranges are inclusive and combinable.<!-- EPO <DP n="4"> --></p>
<p id="p0009" num="0009">It is to be appreciated that certain features of the invention which are, for clarity, described herein in the context of separate embodiments, may also be provided in combination in a single embodiment. Conversely, various features of the invention that are, for brevity, described in the context of a single embodiment, may also be provided separately or in any subcombination. Further, reference to values stated in ranges include each and every value within that range.</p>
<p id="p0010" num="0010">The solution disclosed herein includes a method for executing a computer program on a trusted computer networked to at least one other computer and a system capable of performing that method. The method includes: dividing the computer program into a series of operations; sending each operation of the series of operations to the at least one other computer, each operation having accompanying instructions that tell the respective computer that received the operation to calculate the operation and then forward the result of that calculation to another computer; and receiving the outcome of the computer program at the trusted computer. Encryption and obfuscation may be used for added security with the method.</p>
<p id="p0011" num="0011">A trusted computer is a computer known to be uncompromised by an attacker, and the at least one other computer may be needed to provide computational or other resources. In non-limiting example, the at least one other computer may be trusted or untrusted, part of an enterprise network, part of a cloud, a mobile device, generally part of a plurality of computers, or any other computer or set of computers communicatively connected to the trusted computer, but not including the trusted computer. In further non-limiting example, the at least one other computer may be randomly selected from a plurality of computers. With reference to a "cloud," the cloud may be trusted or untrusted, span multiple administrative domains, span multiple commercially distinct infrastructures, or be in any combination or other context known in the art. Computers may be networked together with a wired connection (electrically or optically), wireless connection, and/or any type of connection allowing the computers to communicate data. A computer may also comprise a virtual machine or group of virtual machines.</p>
<p id="p0012" num="0012">Dividing the computer program into a series of operations and sending each operation of the series of operations to the at least one computer with accompanying instructions may be referred to as "shredding," with each operation called a "shred." The shredding process transforms the program into a collection of shreds, where each shred executes a part of the program on the at least one computer and communicates with other shreds such that the ensemble of shreds execute the complete program. In an embodiment, the shredding process places the shreds on networked computers using a random selection of computers such that each computer performs the partial computation specified in its shred and then forwards the rest of the<!-- EPO <DP n="5"> --> computation to the next computer. Each computer only knows where it received a shred from, what it is supposed to compute within a shred, and where to forward the results of its shred to. If the number of networked computers is large enough, a possible attacker will not be able to monitor all computers simultaneously to piece together the shredded computation.</p>
<p id="p0013" num="0013"><figref idref="f0001">FIG. 1</figref> shows an example program being executed on trusted computers and cloud computers using an embodiment of the shredding process. The program 100 contains four parts: an input, a function 'f', a function 'g', and an output. The shredder program that executes on a trusted computer analyzes the binary executable for this program to discover the four parts, and accordingly produces four shreds, which are also in binary executable form. The input and output operations are executed on Trusted Computer 1 (TC1) 110 and Trusted Computer 4 (TC4) 140, respectively. TC1 110 and TC4 140 are chosen by the shredder because they are connected to the required input and output devices. The functions 'f' and 'g' are computationally expensive and are therefore executed on Cloud Computer 2 (CC2) 120 and Cloud Computer 3 (CC3) 130, respectively. CC2 120 and CC3 130 were randomly chosen by the shredder from the pool of available machines. TC1 110 receives input and assigns the input to variable 'x', which it then forwards to CC2 120. CC2 120 receives variable 'x' and computes function "f(x)", assigning the result to variable 'y', which it then forwards to CC3 130. CC3 130 receives variable 'y' and computes function "g(x)", assigning the result to variable 'z', which it then forwards to TC4 140. TC4 140 receives variable 'z' and outputs it.</p>
<p id="p0014" num="0014">As can be seen in <figref idref="f0001">FIG. 1</figref>, some of the series of operations may require an input and/or output (I/O) interaction from a trusted computer. To account for lack of an I/O device, or trusted I/O (for security, only trusted computers should see plain data from I/O devices), on a computer executing a shred, special "split" device drivers may be implemented. A split device driver is actually two drivers, one on each computer, wherein each driver performs half the work of a normal device driver. Because both halves of the driver execute as user processes, they require no modification of the operating systems on both the computer executing a shred and the trusted computer. The following are example embodiments illustrating how a split device driver may be implemented and used.</p>
<p id="p0015" num="0015">In an embodiment, if, during computation of a result of an operation, or shred, on a certain computer, the operation requires input from a device connected to a first trusted computer, the certain computer may: generate an input request at a program driver on the certain computer; pass the input request from the program driver to a network driver; send the input request to the first trusted computer via the network driver; receive a response of the device at the network driver from the first trusted computer; and pass the response from the network driver<!-- EPO <DP n="6"> --> to the program driver for use in the computation. The received response may be encrypted for added security.</p>
<p id="p0016" num="0016">In an embodiment, if, during computation of a result of an operation, or shred, on a certain computer, the operation requires input from a device connected to a first trusted computer, the first trusted computer may: receive from the certain computer, at a network driver on the first trusted computer, a request for input from the device; pass the request from the network driver to an input driver for the device; pass a response from the device from the input driver to the network driver; and send the response to the certain computer via the network driver. The first trusted computer may encrypt the response from the device before passing the response from the input driver to the network driver for added security.</p>
<p id="p0017" num="0017">In an embodiment, if, during computation of a result of an operation on a certain computer, the operation requires output from a device connected to a first trusted computer, the certain computer may: generate an output request at a program driver on the certain computer; pass the output request from the program driver to a network driver; send the output request to the first trusted computer via the network driver; receive a status of the device at the network driver from the first trusted computer; and pass the status from the network driver to the program driver for use in the computation. The output request may include encrypted data.</p>
<p id="p0018" num="0018">In an embodiment, if, during computation of a result of an operation on a certain computer, the operation requires output from a device connected to a first trusted computer, the first trusted computer may: receive from the certain computer, at a network driver on the first trusted computer, a request for output to the device; pass the request from the network driver to an output driver for the device; pass a status from the device from the output driver to the network driver; and send the status to the certain computer via the network driver. The request may include encrypted data, and the first trusted computer may need to decrypt that data before passing the request from the network driver to the output driver.</p>
<p id="p0019" num="0019">In an embodiment, if, during computation of a result of an operation on a certain computer, the operation requires input from a device connected to a first trusted computer, the method to gather that input may include: generating an input request at a program driver on the certain computer; passing the input request from the program driver to a first network driver; sending the input request to the first trusted computer via the first network driver; receiving from the certain computer, at a second network driver on the first trusted computer, the input request; passing the input request from the second network driver to an input driver for the device; passing a response from the device from the input driver to the second network driver; sending the response to the certain computer via the second network driver; receiving the response of the<!-- EPO <DP n="7"> --> device at the first network driver from the first trusted computer; and passing the response from the first network driver to the program driver for use in the computation. For added security, the method may further include encrypting the response from the device before passing the response from the input driver to the second network driver. Therefore, the received response from the first trusted computer may be encrypted.</p>
<p id="p0020" num="0020">In an embodiment, if, during computation of a result of an operation on a certain computer, the operation requires output from a device connected to a first trusted computer, the method to perform that output may include: generating an output request at a program driver on the certain computer; passing the output request from the program driver to a first network driver; sending the output request to the first trusted computer via the first network driver; receiving from the certain computer, at a second network driver on the first trusted computer, the output request; passing the output request from the second network driver to an output driver for the device; passing a status from the device from the output driver to the second network driver; sending the status to the certain computer via the second network driver; receiving the status at the first network driver from the first trusted computer; and passing the status from the first network driver to the program driver for use in the computation. For added security, the output request may include encrypted data, which would then need to be decrypted before passing the output request from the second network driver to the output driver.</p>
<p id="p0021" num="0021">Encryption may be used on several levels for added security. All network connections between the trusted computer and the at least one other computer may be encrypted. Such network encryption may be implemented by using, for example, Transport Layer Security (TLS) or any other suitable encryption scheme.</p>
<p id="p0022" num="0022"><figref idref="f0002">FIG. 2</figref> shows a high-level embodiment of split device drivers' implementation and operation, which, though not explicitly shown, may involve TLS encryption for network communications. The split device driver on Cloud Computer 1 (CC1) 200 contains two parts: the driver that interfaces with the program, and the driver that interfaces with the network. Similarly, the split device driver on Trusted Computer 1 (TC1) 210 contains two parts: the driver that interfaces with the network, Network Interface 1 212, and the driver that interfaces with the input device, Input Device Driver 1 214. CC1 200 executes the "x=in()" input operation by making use of the split device driver scheme. For the input operation, the driver that interfaces with the program generates an input request 202. This input request 202 is passed to the driver that interfaces with the network for TLS encryption and transmission to TC1 210. Network Interface 1 212 receives the request and passes it to Input Device Driver 1 214. When a response is received from the input device, Input Device 1 220, the response is passed by Input Device<!-- EPO <DP n="8"> --> Driver 1 214 to Network Interface 1 212. Network Interface 1 212 encrypts the response using TLS and transmits the response 222 to CC1 200. The network driver on CC1 200 forwards the TLS decrypted response 222 to the program interface driver, which in turn forwards it to the waiting program. The program assigns the received input to the variable 'x' and continues execution. Also shown in <figref idref="f0002">FIG. 2</figref> is how output may be performed using split device drivers between Cloud Computer 4 (CC4) 230 and Trusted Computer 4 (TC4) 240. The operation of the split device drivers for output is similar to the input operation except that instead of receiving input from the device, the computers receive a status message 252.</p>
<p id="p0023" num="0023">Each operation of the series of operations, or each shred, may be encrypted. Each shred may be encrypted using a symmetric-key encryption scheme such as Advanced Encryption Standard (AES) Galois Counter Mode (GCM) or any other suitable scheme. A symmetric-key encryption uses the shared key(s) of the at least one other computer such that each shred is encrypted using a different key. Such a scheme permits decryption of a shred only on the other computer for which the shred is intended, but hides the rest of the program from any other computers.</p>
<p id="p0024" num="0024">Each data value of each operation of the series of operations may be encrypted. Encrypting the data values may be performed using a symmetric-key scheme, such as AES GCM, a public-key scheme, such as RSA, or any other suitable scheme. Such an encryption is performed on both the trusted computer and the at least one other computer. If a symmetric-key scheme is used, the secret key used is the shared key of the link between the sender and receiver of the data. If a public-key scheme is used, the sender uses the public key of the receiver for encryption, and the receiver uses its private key for decryption. Such schemes enable the at least one other computer to decrypt the data that it needs for computation, but hides all other data from it.</p>
<p id="p0025" num="0025"><figref idref="f0003">FIG. 3</figref> shows an embodiment of symmetric-key encryption and decryption operations for the shreds of the code and data in the example program of <figref idref="f0001">FIG. 1</figref>. <figref idref="f0003">FIG. 3</figref>, like <figref idref="f0002">FIG. 2</figref>, does not explicitly show the TLS encryption and decryption of the communication packets. The four computers involved in the computation of the program, Trusted Computer 1 (TC1) 310, Cloud Computer 2 (CC2) 320, Cloud Computer 3 (CC3) 330, and Trusted Computer 4 (TC4) 340, have secret keys K1, K2, K3, and K4, respectively, that are known to Trusted Computer 0 (TC0) 300. The shredded program code is encrypted on TC0 300 during the shredding operation using shared keys K1, K2, K3, and K4. For example, the statement "in'=Enc(K1, in)" on TC0 300 denotes the encryption of the code for "in" using key K1 to produce the encrypted code "in"'. The corresponding decryption operation on TC1 310 is<!-- EPO <DP n="9"> --> "in=Dec(K1, in')" and this decryption produces the code for the "in" operation. TC1 310 is not able to decrypt any other part of the encrypted program because TC1 310 only knows key K1, and attempting to decrypt some other portion of the code using key K1 would not produce valid code. This encrypting and decrypting process is repeated for all shreds using the keys of each computer sent a shred for computation, allowing each computer access to only the shred it is meant to compute. The communication links between the computers also have shared keys that are known only to the sender and receiver of data. In this case, the shared keys for the communication links are K12, K23, and K34. For example, shared key K12 is used by TC1 310 to encrypt input 'x' to ciphertext 'x", and x' is decrypted using key K12 on CC2 320 to yield 'x'. This process is used from computer to computer to ensure an attacker cannot intercept plaintext over the network.</p>
<p id="p0026" num="0026">Obfuscation should be used for additional security and may comprise data obfuscation, code obfuscation, or both. Obfuscation may involve modifying the code and/or data within each shred to hide the original code and data from an attacker at an other computer. Code obfuscation uses obfuscating transformations to hide the logic of the original program from an attacker that has complete visibility of a shred's code as well as the instructions and data during shred execution. Data obfuscation transforms the data so that shredded code executes on obfuscated data values such that it is difficult for an attacker to recover the unobfuscated data value; blinding is a type of data obfuscation.</p>
<p id="p0027" num="0027">Obfuscation with shredding involves obfuscating each operation of the series of operations before sending each operation to a respective other computer and unobfuscating the received computed outcome of the computer program. The method of obfuscation differs depending on the level of shredding, and shredding may be performed on at least four different levels: gate level, hardware-unit level, instruction level, encryption-scheme level, and any other scheme allowing the program to be broken into units.</p>
<p id="p0028" num="0028"><figref idref="f0004">FIG. 4</figref> shows an example of obfuscating the program "z = a * x + y" across four computers. The aim of obfuscation is to hide the values of inputs 'a', 'x', and 'y' and output 'z' from attackers at Cloud Computer 2 (CC2) 410 and Cloud Computer 3 (CC3) 420. Trusted Computer 1 (TC1) 400 introduces three random values, 'r', 's', and 't', that are used as one-time pads for obfuscating the values of inputs 'a', 'x', and 'y', respectively. The operation used for obfuscation depends on the use of the variable. For example, variables 'a' and 'x' are multiplied, so the obfuscation operation multiplies 'a' and 'x' by their pad values 'r' and 's', whereas variable 'y' is an addend, so the obfuscation operation adds one-time pad 't'. CC2 410 and CC3 420 perform computation using obfuscated values 'a", 'x", and 'y" to compute 'b" and 'c",<!-- EPO <DP n="10"> --> respectively. CC3 420 performs the unobfuscation of 'b" by dividing by 'r' and 's', and Trusted Computer 4 (TC4) 430 performs the unobfuscation of the value 'c" by subtracting the pad 't'. These procedures ensure that an attacker can never see the actual value of the variables involved.</p>
<p id="p0029" num="0029">Gate-level shredding is the finest level of shredding and offers perfect secrecy because it is impossible for an attacker who observes a single other computer to understand the calculation or recover the original inputs or outputs of the calculation. However, it is the slowest level of shredding and does not offer the ability to perform I/O operations on other computers. At this level, the program is divided into a circuit consisting of AND, OR, NAND, NOR, and NOT gates, and the NOT gates may be converted to NAND gates with equal input to ensure each gate operation has two operands. In this manner, the series of operations the program has been divided into are circuit gate operations, with each circuit gate operation having an operator, a first operand, and a second operand.</p>
<p id="p0030" num="0030">In an embodiment, each gate in the circuit of gate operations is obfuscated and shredded across two other computers. For each gate operation, the process involves the trusted computer obfuscating the first operand with a first random value and obfuscating the second operand with a second random value. Then, the obfuscated operands are sent to a first computer with instructions for the first computer to compute a plurality of results of a plurality of operations using the obfuscated operands and send the plurality of results to a second computer. The trusted computer sends the second computer instructions: to choose a result of the plurality of results based upon the operator, the first random value, and the second random value; to obfuscate the chosen result with a third random value; and to send the chosen result to a different computer, which may be a trusted computer or another computer.</p>
<p id="p0031" num="0031"><figref idref="f0005">FIG. 5</figref> shows an example embodiment of shredding a gate computation across two other computers, namely Cloud Computer 1 (CC1) 510 and Cloud Computer 2 (CC2) 520. In this example, the gate operation "g = a &amp; b" is the current shred to be executed. Like <figref idref="f0004">FIG. 4</figref>, this embodiment uses one-time pads, but with random values 'r', 's', and 'u'. Trusted Computer (TC) 500 generates an obfuscated program to perform "g = a &amp; b" as follows. First, TC 500 selects two random bits, 'r' and 's', to obfuscate 'a' and 'b', respectively. It then calculates "c = a ^ r" and "d = b ^ s" wherein the '^' operator denotes an XOR operation. TC 500 then sends 'c' and 'd' to CC1 510. CC1 510 computes four temporary values: e1=c &amp; d; e2=c &amp; !d; e3=c !d; and e4=c d. CC1 510 then sends {e1, e2, e3, e4} to CC2 520. CC2 520 executes one of the following programs based upon the values of 'r' and 's' and uses a random bit 'u' to obfuscate the result: if {r = 0, s = 0}, then f = e1 ^ u; if {r = 0, s = 1}, then f = e2 ^ u; if {r = 1, s = 0}, then<!-- EPO <DP n="11"> --> f = !e3 ^ u; and if {r = 0, s = 0}, then f = !e4 ^ u. CC2 520 then sends f to TC 500. TC 500 unobfuscates the result by computing "g = f ^ u".</p>
<p id="p0032" num="0032">In the example embodiment of <figref idref="f0005">FIG. 5</figref>, TC 500 computes three XOR operations for obfuscating the data while CC1 510 and CC2 520 perform the computations. Neither CC1 510 nor CC2 520 knows the input data, output data, or computation because CC1 510 performs four generic operations and CC2 520 selects the correct operation. Although it appears that the computation of AND or the result of the computation is revealed at CC2 520, careful examination shows that both the computation and the data are hidden. The program at CC2 520 is simply a pass through, or a negation, of one of the {e1, e2, e3, e4} values and is generated by the shredder program depending on the random values of 'r', 's', and 'u' that only it knows. Further, CC2 520 cannot know whether it is computing an AND or OR operation because, as <figref idref="f0006">FIG. 6</figref> shows, the following permutation of the variable names at CC1 510 causes CC2 520 to compute "a OR b": e4 = c &amp; d; e3 = c &amp; !d; e2 = c | !d; e1 = c | d. <figref idref="f0006">FIG. 6</figref>, calculating "g = a | b", is identical to <figref idref="f0005">FIG. 5</figref> in all respects other than the computation performed at CC2 620.</p>
<p id="p0033" num="0033">Similarly, a NAND or NOR operation may be computed by adding an additional NOT operation at CC2 520. As mentioned above, a NOT operation of a single bit can use a NAND operation with equal inputs. A similar method using a random bit 'r' to hide input and another random bit 'u' to hide output may be used to obfuscate a sequential circuit that stores a single bit. Thus, any circuit can be obfuscated by introducing a one-time pad (consisting of all the random values of the bits used to hide inputs and outputs) on the TC 500 and generating two shreds to execute the circuit under that one-time pad. This scheme is secure as long as the two shreds are not simultaneously visible to an attacker.</p>
<p id="p0034" num="0034">The one-time pad method illustrated in <figref idref="f0005 f0006">FIGs. 5-6</figref> is not secure if the circuit is used multiple times because (1) values {e1, e2, e3, e4} that are visible at CC2 (520, 620) have a specific pattern for the four combinations of input variables 'c' and 'd' at CC1 (510, 610) and (2) the pattern of values {e1, e2, e3, e4} for an AND operation is different from the pattern of values {e1, e2, e3, e4} for an OR operation. An attacker at CC2 (520, 620) who collects and analyzes the four values {e1, e2, e3, e4} can determine the operation. To combat this, an additional four random bits 't1', 't2', 't3', and 't4' may be introduced to obfuscate the values of {e1, e2, e3, e4}. <figref idref="f0007">FIG. 7</figref> illustrates the computation using these new bits.</p>
<p id="p0035" num="0035"><figref idref="f0007">FIG. 7</figref> is identical to <figref idref="f0005">FIG. 5</figref>, but uses {t1, t2, t3, t4} for added obfuscation. In this example, Trusted Computer (TC) 700 obfuscates 'c' and 'd' and sends them to Cloud Computer 1 (CC1) 710, which computes {e1, e2, e3, e4} identically to <figref idref="f0005 f0006">FIGs. 5-6</figref>. However, e1 is now XORed with t1, e2 XORed with t2, e3 XORed with t3, and e4 XORed with t4 to<!-- EPO <DP n="12"> --> obfuscate the values of {e1, e2, e3, e4}. Generally, Cloud Computer 2 (CC2) 720, or the computer processing the second shred, is either a pass-through or negation of a specific 'e' value, dependent on the operation being computed as well as the values of random bits 'r', 's', 'u', 't1', 't2', 't3', and 't4', as shown in the following table.
<tables id="tabl0001" num="0001">
<table frame="all">
<title>Table 1. Obfuscated Circuit-Gate Operation Selection</title>
<tgroup cols="5">
<colspec colnum="1" colname="col1" colwidth="21mm"/>
<colspec colnum="2" colname="col2" colwidth="25mm"/>
<colspec colnum="3" colname="col3" colwidth="25mm"/>
<colspec colnum="4" colname="col4" colwidth="25mm"/>
<colspec colnum="5" colname="col5" colwidth="25mm"/>
<thead>
<row>
<entry valign="top">{r, s}</entry>
<entry valign="top">AND</entry>
<entry valign="top">NAND</entry>
<entry valign="top">OR</entry>
<entry valign="top">NOR</entry></row></thead>
<tbody>
<row>
<entry>{r=0, s=0}</entry>
<entry>f= e<sub>1</sub> ^ (t<sub>1</sub> ^ u)</entry>
<entry>f = !e<sub>1</sub> ^ (t<sub>1</sub> ^ u)</entry>
<entry>f = e<sub>4</sub> ^ (t<sub>4</sub> ^ u)</entry>
<entry>f = !e<sub>4</sub> ^ (t<sub>4</sub> ^ u)</entry></row>
<row>
<entry>{r=0, s=1}</entry>
<entry>f = e<sub>2</sub> ^ (t<sub>2</sub> ^ u)</entry>
<entry>f = !e<sub>2</sub> ^ (t<sub>2</sub> ^ u)</entry>
<entry>f= e<sub>3</sub> ^ (t<sub>3</sub> ^ u)</entry>
<entry>f = !e<sub>3</sub> ^ (t<sub>3</sub> ^ u)</entry></row>
<row>
<entry>{r = 1, s = 0}</entry>
<entry>f = !e<sub>3</sub> ^ (t<sub>3</sub> ^ u)</entry>
<entry>f= e<sub>3</sub> ^ (t<sub>3</sub> ^ u)</entry>
<entry>f = !e<sub>2</sub> ^ (t<sub>2</sub> ^ u)</entry>
<entry>f= e<sub>2</sub> ^ (t<sub>2</sub> ^ u)</entry></row>
<row>
<entry>{r = 1, s = 1}</entry>
<entry>f = !e<sub>4</sub> ^ (t<sub>4</sub> ^ u)</entry>
<entry>f = e<sub>4</sub> ^ (t<sub>4</sub> ^ u)</entry>
<entry>f = !e<sub>1</sub> ^ (t<sub>1</sub> ^ u)</entry>
<entry>f = e<sub>1</sub> ^ (t<sub>1</sub> ^ u)</entry></row></tbody></tgroup>
</table>
</tables>
In <figref idref="f0007">FIG. 7</figref>, CC2 720 selects one of the calculations under the AND column because the operation is "g = a &amp; b". Then, CC2 720 sends 'f' to TC 700, where TC 700 unobfuscates it for the final result.</p>
<p id="p0036" num="0036">Analysis of the four values of {e1, e2, e3, e4} for each of the four operations (AND, NAND, OR, NOR) shows that exactly the same 16 patterns (for the 16 values of {t1, t2, t3, t4}) appear for each of the four operations. Therefore, an attacker at CC2 720 cannot use these patterns to determine the operation. However, there is some leakage of information because an attacker who sees the program at CC2 720 can determine whether the values of 'r' and 's' are equal. This scheme for obfuscating an AND, NAND, OR, or NOR operation of two input bits uses a random key containing seven bits (r, s, t1, t2, t3, t4, u) to generate two shreds. The first shred always performs the same boolean operations, the second shred selects the correct operation, and the communication of the intermediate values between the two shreds is obfuscated. This process for obfuscating and computing any arbitrary circuit can be seen in <figref idref="f0008">FIG. 8</figref>. Each rectangle in <figref idref="f0008">FIG. 8</figref> represents a computer. The initial input is sent from a computer 800, labeled "Send Input", to a first computer 810, labeled "Compute 1", where a first shred calculates the operations and sends the operations to a second computer 820, labeled "Select 1", where a second shred selects the correct operation. The process continues (for example, at computers 830 and 840, labeled "Compute 2" and "Select 2" respectively, and then back to Compute 1 810 or another selected computer) until the result of the circuit is computed and sent to the computer 850 labeled "Receive Output".</p>
<p id="p0037" num="0037">Hardware-unit-level shredding offers less privacy than gate-level shredding, but executes at a faster speed. This level of shredding divides the program into a circuit comprising operations of hardware units that perform specific functions. Examples include integer addition, integer multiplication, integer comparison, and floating point multiplication, which are standard<!-- EPO <DP n="13"> --> hardware units in a generic computer. In this manner, the series of operations are mathematical operations, with each mathematical operation having an operator, a first operand, and a second operand. An attacker at an other computer can see the type of operation being performed, but cannot guess the precise operation. For example, an attacker may see that an integer addition is being performed, but cannot see the plain values of the operands or the result. Finally, like gate-level shredding, hardware-unit-level shredding does not offer the ability to perform I/O operations on other computers.</p>
<p id="p0038" num="0038">Instruction-level shredding divides the program into instructions such that each shred executes a subset of the instructions. Examples of instructions include x86 machine instructions and Java Virtual Machine (JVM) bytecodes. Like hardware-unit-level shredding, these instructions involve mathematical operations. However, unlike hardware-unit-level shredding, instruction-level shredding accommodates programs that perform I/O operations by using the aforementioned split device drivers.</p>
<p id="p0039" num="0039">In an embodiment, each mathematical operation of the series of operations the program has been divided into is obfuscated and shredded across two computers. For each mathematical operation, the process involves the trusted computer obfuscating the first operand with a first random value and obfuscating the second operand with a second random value. Then, the obfuscated operands are sent to a first computer with instructions for the first computer to compute a first result of an operation using the operator, the first obfuscated operand, and the second obfuscated operand. The first computer also receives a value from a second computer, computes a second result of an operation using the operator, the first result, and the value, and sends the second result to a different computer, which may be a trusted computer or another computer. The second computer knows the random values used to obfuscate the operands and final result and uses this knowledge to calculate the value sent to the first computer. In some embodiments involving an addition operation, the received value is a third random value minus the sum of the first random value and second random value. <figref idref="f0012">FIG. 12</figref>, described below, illustrates one such embodiment. In some embodiments involving a multiplication operation, the received value is a third random value divided by the product of the first random value and second random value. <figref idref="f0013">FIG. 13</figref>, described below, illustrates one such embodiment. Some embodiments might require transitioning an operation from a multiplicative obfuscation scheme to an additive multiplication scheme and vice versa. <figref idref="f0018">FIG. 18</figref>, described below, illustrates an embodiment transitioning from a multiplicative obfuscation scheme to an additive obfuscation scheme, and <figref idref="f0019">FIG. 19</figref>, also described below, illustrates an embodiment transitioning from an additive obfuscation scheme to a multiplicative obfuscation scheme.<!-- EPO <DP n="14"> --></p>
<p id="p0040" num="0040">Random values needed for obfuscation may be generated by the following method. The cycles of execution of the program are numbered so that a variable defined by an instruction executed at cycle 'i' is blinded by function "Key(i)". The function "Key(i)" generates a random floating point value that is not "too big or too small" in order to limit round-off error during floating point calculations. The random floating point value is also non-zero to prevent any division by zero during computation. The "Key" function is implemented using a fast stream cipher, such as Salsa20, that generates a random value for a nonce 'i'. Two secret seeds are used for the stream cipher: one seed for generating the additive blinding values, and a different seed for generating the multiplicative blinding values. Because each instruction in the program is an addition or a multiplication, but not both, the result of the execution is blinded using one of the two seeds. If the result of an instruction that is blinded in one scheme is used in an operation of the opposite scheme, a conversion operation is used to change schemes.</p>
<p id="p0041" num="0041">In the examples shown in <figref idref="f0012 f0013">FIGs. 12-13</figref>, the TCs (1200, 1230, 1300, and 1330) and CC3 (1220 and 1320) would know both seeds and CC2 (1210 and 1310) would not know any seed. In the examples shown in <figref idref="f0018 f0019">FIGs. 18-19</figref>, the TCs (1800, 1840, 1900, and 1940) and CC3 (1820 and 1920) would know both seeds, CC2 (1810 and 1910) would not know any seed, and CC4 (1830 and 1930) would know only the multiplicative seed.</p>
<p id="p0042" num="0042">Shredding performed at the encryption-scheme level encrypts each data value of each operation of the series of operations using homomorphic encryption schemes that depend on the operations that are performed on the data. Addition operations are encrypted using an Additive Homomorphic Encryption (AHE) scheme, such as Paillier, and multiplication operations are encrypted using a Multiplicative Homomorphic Encryption (MHE) scheme, such as El Gamal. When data encrypted in one scheme need to be operated on using an incompatible operation, transition encryption functions may be used to convert AHE data values to MHE data values and convert MHE data values to AHE data values. These transition functions may be shredded for added security by dividing a transition encryption function into a series of operations and sending each operation of the transition encryption function with accompanying instructions to at least one other computer, the accompanying instructions operative to compute a result of the respective operation and forward the result to another computer. <figref idref="f0014">FIG. 14</figref>, described below, shows an embodiment of a shredded transition encryption function from Paillier to El Gamal, and <figref idref="f0015">FIG. 15</figref>, also described below, shows an embodiment of a shredded transition encryption function from El Gamal to Paillier. It is also possible to compare two encrypted integers. <figref idref="f0016">FIG. 16</figref>, described below, shows an embodiment of a shredded comparison function<!-- EPO <DP n="15"> --> using Paillier encryption, and <figref idref="f0017">FIG. 17</figref>, also described below, shows an embodiment of a shredded comparison function using El Gamal encryption.</p>
<p id="p0043" num="0043"><figref idref="f0009">FIG. 9</figref> shows an example embodiment executing "z = a * x + b" using El Gamal and Paillier encryption schemes. Trusted Computer 1 (TC1) 900 encrypts the 'a' and 'x' values using El Gamal and the 'b' value using Paillier. The "EG()" function refers to encrypting with El Gamal, and the "EP()" functions refers to encrypting with Paillier. Cloud Computer 2 (CC2) 910 computes the multiplication "a * x" on the MHE-encrypted values to produce an MHE-encrypted value of 'y". CC2 910 then uses the shredded transition functions "GP1()", "GP2()", and "GP30" with Cloud Computer 3 (CC3) 920 to convert the El Gamal-encrypted value of 'y" to a Paillier-encrypted value, 'y''', and adds "b + y" by multiplying the AHE-encrypted values. Trusted Computer 4 (TC4) 930 then receives the Paillier-encrypted value of 'z' and decrypts it, using the decrypt Paillier function "DP()", for the solution. Shredded transition functions "GP1()", "GP2()", and "GP3()" are described more fully in respect to <figref idref="f0015">FIG. 15</figref>, below.</p>
<p id="p0044" num="0044">As previously mentioned, split device drivers enable input and output operations in shreds executing on other computers. As an additional security layer, it is preferable to allow shreds to only operate on encrypted data from I/O devices so that only trusted computers may see plain data from I/O devices. <figref idref="f0010">FIG. 10</figref> shows an example operation of a normal device driver interaction operating on a single computer, while, in contrast, <figref idref="f0011">FIG. 11</figref> shows a detailed example operation of a split device driver interaction between a trusted computer and a cloud computer.</p>
<p id="p0045" num="0045"><figref idref="f0010">FIG. 10</figref> shows an example operation of a normal device driver interaction operating on a single computer. The example application, Application 1000, shown in <figref idref="f0010">FIG. 10</figref> requests input from a keyboard, Keyboard Hardware 1020, and outputs that input to a console or screen, Console Hardware 1040. The process requires the eight steps labeled in <figref idref="f0010">FIG. 10</figref>. At step 1, the application requests a character from Kernel Keyboard Device Driver (KK) 1010 in the computer's kernel. At step 2, KK 1010 requests a character from Keyboard Hardware 1020. At step 3, Keyboard Hardware 1020 has received input and responds to KK 1010 with a character. At step 4, KK 1010 passes the character to the application to complete the input operation. At step 5, the application starts the output operation and sends the character to Kernel Console Device Driver (KC) 1030 in the computer's kernel. At step 6, KC 1030 sends the character to Console Hardware 1040. At step 7, Console Hardware 1040 prints the character and sends a status to KC 1030. At step 8, KC 1030 passes the status to Application 1000. At this stage, the output operation is now complete, and Application 1000 is aware of the status of the output, e.g., if it printed to the console screen, error, etc.<!-- EPO <DP n="16"> --></p>
<p id="p0046" num="0046"><figref idref="f0011">FIG. 11</figref> shows operation of an embodiment of a split device driver between Trusted Computer (TC) 1102 and Cloud Computer (CC) 1104 performing the same functions as <figref idref="f0010">FIG. 10</figref>: Executing Shred 1100 requires input from Keyboard Hardware 1160 (steps 1-12) and then outputs that input to Console Hardware 1162 (steps 13-24). Because CC 1104 must get input from a trusted computer and output to a trusted computer for security purposes (here, that is TC 1102), the device drivers are split between CC 1104 and TC 1102.</p>
<p id="p0047" num="0047">The input portion of <figref idref="f0011">FIG. 11</figref> is as follows. At step 1, Executing Shred 1100 requests a character from the split keyboard device driver in user mode, User Mode Keyboard Device Driver (CCUMK) 1110. At step 2, CCUMK 1110 uses Kernel Network Device Driver (CCKN) 1120 to request the character. At step 3, CCKN 1120 communicates with Kernel Network Device Driver on TC (TCKN) 1130. At step 4, TCKN 1130 requests a character from User Mode Keyboard Device Driver (TCUMK) 1140. At step 5, TCUMK 1140 requests a character from Kernel Keyboard Device Driver (TCKK) 1150. At step 6, TCKK 1150 requests a character from Keyboard Hardware 1160. At step 7, Keyboard Hardware 1160 has received input and responds to TCKK 1150 with a character. At step 8, TCKK 1150 sends the character to TCUMK 1140. At step 9, TCUMK 1140 encrypts the received character and sends it to TCKN 1130. At step 10, TCKN 1130 sends the encrypted character to CCKN 1120. At step 11, CCKN 1120 sends the encrypted character to CCUMK 1110. At step 12, CCUMK 1110 passes the encrypted character to Executing Shred 1100 to complete the input operation.</p>
<p id="p0048" num="0048">The output portion of <figref idref="f0011">FIG. 11</figref> is as follows and assumes that Executing Shred 1100 has received the encrypted character from the process of steps 1-12. At step 13, Executing Shred 1100 begins the output operation and sends the encrypted character to the split console device driver in user mode, User Mode Console Device Driver (CCUMC) 1112. At step 14, CCUMC 1112 uses CCKN 1120 to send the encrypted character. At step 15, CCKN 1120 communicates with TCKN 1130. At step 16, TCKN 1130 sends the encrypted character to User Mode Console Device Driver (TCUMC) 1142. At step 17, TCUMC 1142 decrypts the character and sends the plain character to Kernel Console Device Driver (TCKC) 1152. At step 18, TCKC 1152 sends the plain character to Console Hardware 1162. At step 19, Console Hardware 1162 prints the character and sends a status to TCKC 1152. At step 20, TCKC 1152 sends the status to TCUMC 1142. At step 21, TCUMC 1142 sends a status to TCKN 1130. At step 22, TCKN 1130 sends the status to CCKN 1120. At step 23, CCKN 1120 sends the status to CCUMC 1112. At step 24, CCUMC 1112 sends the status to Executing Shred 1100. At this stage, the output operation is now complete, and Executing Shred 1100 is aware of the status of the output, e.g., if it printed to the console screen, error, etc.<!-- EPO <DP n="17"> --></p>
<p id="p0049" num="0049">Other than the split drivers, an additional difference between Application 1000 in <figref idref="f0010">FIG. 10</figref> and Executing Shred 1100 in <figref idref="f0011">FIG. 11</figref> is that Executing Shred 1100 operates on encrypted data, and hence can execute on a computer that is observed by an attacker, here CC 1104. The key for encrypting and decrypting the data is only available on TC 1102, which uses the key in TCUMK 1140 and TCUMC 1142.</p>
<p id="p0050" num="0050">As previously mentioned, code obfuscation may be used to hide the logic of the original program and may be used in conjunction with data obfuscation. Data obfuscation may be better understood using <figref idref="f0012 f0013">FIGs. 12-13</figref>, and code obfuscation may include, but is not limited to, opcode substitution, function merging, control flow flattening, and decoy code, including opaque predicates.</p>
<p id="p0051" num="0051"><figref idref="f0012">FIG. 12</figref> illustrates an embodiment computing the sum "g = a + b" using data obfuscation. Trusted Computer 1 (TC1) 1200 selects two random numbers, 'r' and 's', to obfuscate 'a' and 'b', respectively. TC1 1200 computes "a + r" and "b + s" and assigns the results to variables 'c' and 'd', respectively. TC1 1200 then sends (c, d) to Cloud Computer 2 (CC2) 1210. CC2 1210 computes the sum "e = c + d" and requests blinding from Cloud Computer 3 (CC3) 1220. CC3 1220 is given knowledge of random values 'r' and 's' and also a third random value, 'u', used to blind the final result. CC3 1220 computes the value of "u - r - s" and assigns it to variable 'h', which it sends to CC2 1210. CC2 1210 receives the value 'h' from CC3 1220, computes "e + h", and assigns the result to variable 'f', which it sends to Trusted Computer 4 (TC4) 1230. TC4 1230 then unblinds the result by computing "f - u", completing the operation. So the TCs 1200 and 1230 use three random numbers, 'r', 's', and 'u', as keys for obfuscating the input data ('a' and 'b') and output data ('g') while the two cloud computers 1210 and 1220 compute the actual sum. No cloud computer knows the input or output data.</p>
<p id="p0052" num="0052"><figref idref="f0013">FIG. 13</figref> illustrates an embodiment computing the product "g = a * b" using data obfuscation. Trusted Computer 1 (TC1) 1300 selects two random numbers, 'r' and 's', to obfuscate 'a' and 'b', respectively. TC1 1300 computes "a * r" and "b * s" and assigns the results to variables 'c' and 'd', respectively. TC1 1300 then sends (c, d) to Cloud Computer 2 (CC2) 1310. CC2 1310 computes the product "e = c * d" and requests blinding from Cloud Computer 3 (CC3) 1320. CC3 1320 is given knowledge of random values 'r' and 's' and also a third random value, 'u', used to blind the final result. CC3 1320 computes the value of "u / (r * s)" and assigns it to variable 'h', which it sends to CC2 1310. CC2 1310 receives the value 'h' from CC3 1320, computes "e * h", and assigns the result to variable 'f', which it sends to Trusted Computer 4 (TC4) 1330. TC4 1330 then unblinds the result by computing "f / u",<!-- EPO <DP n="18"> --> completing the operation. So the TCs 1300 and 1330 use three random numbers, 'r', 's', and 'u', as keys for obfuscating the input data ('a' and 'b') and output data ('g') while the two cloud computers 1310 and 1320 compute the actual product. No cloud computer knows the input or output data.</p>
<p id="p0053" num="0053">Opcode substitution involves substituting random opcodes for the real opcodes, thwarting static disassembly of a shred. For a program divided into a series of operations comprising opcodes, a substitution map may be created that maps the program opcodes to a random permutation of opcodes. The substitution map may then be used to transform the series of opcodes into the random permutation of opcodes and sent to a remote computer for use in unobfuscating by the respective other computers. Unobfuscation may be performed by receiving, at the remote computer holding the substitution map, from an other computer, an index corresponding to a portion of the substitution map and sending, from the remote computer to the other computer, the portion of the substitution map. It may be seen symmetrically that an other computer may send, to the remote computer, an index corresponding to a portion of the substitution map, receive, from the remote computer, the portion of the substitution map, and transform, using the substitution map, the random permutation of opcodes into the original series of opcodes.</p>
<p id="p0054" num="0054">In an embodiment, opcode substitution with a substitution map may be used with a Java program. Java bytecodes have 256 opcodes, of which 51 opcodes (range 203-253) are not defined. A substitution map is introduced to map the original 256 opcodes to a random permutation of the opcodes. The substitution map is known to the computer that produces a shred as well as to a remote computer, but it is not known to the other computer that executes the shred using the permutated opcodes. The unused opcode 253 is used by the obfuscated programs as a GET MAP instruction. The GET MAP instruction takes a 32-bit index as an operand, which is sent by the other computer executing a shred to the remote computer. The remote computer returns a 256-byte result containing the substitution map to be used for that particular shred. The GET MAP instruction is inserted at the beginning of a shred as well as a user specified number of times within a shred. For security, there should be a large number of GET MAP instructions to thwart statistical analysis of a large section of code that uses the same map. For performance optimization, there should be a small number of GET MAP instructions within loops.</p>
<p id="p0055" num="0055">Function merging combines unrelated functions into a single function. The unrelated functions each have parameters and retain their respective behaviors inside the single function. To implement such a scheme, the single function takes all of the unrelated functions' parameters plus an additional parameter to select which behavior to perform. If the number of<!-- EPO <DP n="19"> --> unrelated functions is large, groups of somewhat-related functions may be merged so that there is a single merged function per group.</p>
<p id="p0056" num="0056">Control flow flattening, also known as chenxification, coverts a function into an infinite loop. To exit the loop, a switch statement is added that performs behavior identical to that of the original function.</p>
<p id="p0057" num="0057">Decoy code is used to increase the amount of code that an attacker would need to analyze. This may be done by inserting decoy code into the computer program. The decoy code may comprise original code of the computer program with a number of minor mutations. The minor mutations create statically undetectable errors, and the number of minor mutations may be user-specified. The decoy code may be part of an opaque predicate scheme. Such a scheme thwarts static analysis of a function by making the target statement dependent on an opaque predicate, which is a predicate that is easy to setup and execute, but difficult to analyze. Opaque predicates may exploit array aliasing, of which there are three types of predicates: always true, always false, and sometimes true. Always true predicates execute the original code in the "if' branch and decoy code in the "else" branch. Always false predicates execute decoy code in the "if' branch and the original code in the "else" branch. Sometimes true predicates execute the original code and an obfuscated version of the original code on the two branches.</p>
<p id="p0058" num="0058">As mentioned previously, <figref idref="f0014 f0015 f0016 f0017">FIGs. 14-17</figref> illustrate embodiments using Paillier and El Gamal encryption. For the embodiments in <figref idref="f0014 f0015 f0016 f0017">FIGs. 14-17</figref>, the following assumptions apply unless stated otherwise. Encryption of message 'm' in Paillier with a public key 'n' is defined as EP(m) = (n+1)<sup>m</sup>r<sup>n</sup> mod n<sup>2</sup>, where 'r' is a random non-zero integer that is less than the public key 'n' and is relatively prime to 'n'. Decryption of cipher 'c' in Paillier with private key (b, u) is defined as DP(c) = u((c<sup>b</sup> mod n<sup>2</sup> - 1) / n) mod n. Encryption of message 'm' in El Gamal with a public key (n, g, q, h) is defined as EG(m) = (g<sup>r</sup> mod n, m h<sup>r</sup> mod n), where 'r' is a random non-zero integer less than 'n' . Decryption of cipher (e, c) in El Gamal with private key 'x' is defined as DG(e, c) = e<sup>q - x</sup> c mod n.</p>
<p id="p0059" num="0059"><figref idref="f0014">FIG. 14</figref> shows an embodiment of a shredded transition encryption function from Paillier encryption to El Gamal encryption. Decrypt ciphertext 'c' from Paillier and encrypt into El Gamal is defined as:
<img id="ib0001" file="imgb0001.tif" wi="72" he="15" img-content="program-listing" img-format="tif"/>
Function "PG(c)" may be shredded into "PG1(c)", "PG2(a, c)", and "PG3(w)" using the following process. Values b1 and b2 are randomly selected such that the sum of b1 and b2 is<!-- EPO <DP n="20"> --> equal to b (b1 + b2 = b). Values u1 and u2 are randomly selected such that the product of u1 and u2 is equal to u mod n (u1 * u2 = u mod n). The functions are defined as follows:
<img id="ib0002" file="imgb0002.tif" wi="79" he="30" img-content="program-listing" img-format="tif"/>
Combining the functions yields function "PG_shred(c)":
<pre listing-type="program-listing">           PG_shred(c) =
                  let a = PG1(c)
                  let (v, w) = PG2(a, c)
                  let z =PG3(w)
                  in (v, z)</pre></p>
<p id="p0060" num="0060">In <figref idref="f0014">FIG. 14</figref>, Trusted Computer 1 (TC1) 1400 encrypts message 'm' with public key 'pk' into Paillier ciphertext 'c', which it then sends to Cloud Computer 2 (CC2) 1410. CC2 1410 calculates "PG1(c)" and assigns the result to 'a', and then sends 'a' and 'c' to Cloud Computer 3 (CC3) 1420. CC3 1420 calculates "PG2(a, c)" and assigns the result to (v, w), which it sends back to CC2 1410. CC2 1410 calculates "PG3(w)" and assigns the result to 'z', and then sends (v, z) to Trusted Computer 4 (TC4) 1430. TC4 1430 receives ciphertext (v, z), now in El Gamal encryption, and decrypts it with secret key 'sk' to reveal message 'm'. Neither CC2 1410 nor CC3 1420 know all randomly selected values 'b1', 'b2', 'u1' and 'u2'. In <figref idref="f0014">FIG. 14</figref>, the public key 'pk', is meant to substitute for 'n', and the secret key 'sk' is meant to substitute for 'x'.</p>
<p id="p0061" num="0061"><figref idref="f0015">FIG. 15</figref> shows an embodiment of a shredded transition encryption function from El Gamal to Paillier. Decrypt ciphertext (e, c) from El Gamal and encrypt into Paillier is defined as:
<img id="ib0003" file="imgb0003.tif" wi="48" he="15" img-content="program-listing" img-format="tif"/>
Function "GP(e,c)" may be shredded into "GP1(e)", "GP2(f)", and "GP3(v, c)" using the following process. Values x1 and x2 are randomly selected such that the product of x1 and x2 is equal to "q - x" (x1 * x2 = q - x). The functions are defined as follows:
<img id="ib0004" file="imgb0004.tif" wi="44" he="36" img-content="program-listing" img-format="tif"/><!-- EPO <DP n="21"> -->
Combining the functions yields function "GP_shred(e, c)":
<pre listing-type="program-listing">           GP_shred(e, c) =
                  let f= GP1(e)
                  let v = GP2(f)
                  in GP3(v, c)</pre></p>
<p id="p0062" num="0062">In <figref idref="f0015">FIG. 15</figref>, Trusted Computer 1 (TC1) 1500 encrypts message 'm' with public key 'pk' into El Gamal ciphertext (e,c), which it then sends to Cloud Computer 2 (CC2) 1510. CC2 1510 calculates "GP1(e)" and assigns the result to 'f', and then sends 'f' to Cloud Computer 3 (CC3) 1520. CC3 1520 calculates "GP2(f)" and assigns the result to 'v', which it sends back to CC2 1510. CC2 1510 calculates "GP3(v, c)" and assigns the result to 'z', and then sends 'z' to Trusted Computer 4 (TC4) 1530. TC4 1530 receives ciphertext 'z', now in Paillier encryption, and decrypts it with secret key 'sk' to reveal message 'm'. Neither CC2 1510 nor CC3 1520 know both randomly selected values 'xl' and 'x2'. In <figref idref="f0015">FIG. 15</figref>, the public key 'pk', is meant to substitute for (n, g, q, h), and the secret key 'sk' is meant to substitute for (b, u).</p>
<p id="p0063" num="0063"><figref idref="f0016">FIG. 16</figref> shows an embodiment of a shredded comparison function using Paillier encryption. If two integers (both less than n/2, where n is the public key) are encrypted in the Paillier scheme, order comparison between them may be defined as follows:
<img id="ib0005" file="imgb0005.tif" wi="73" he="40" img-content="program-listing" img-format="tif"/>
where "EQ" means "c<sub>1</sub> = c<sub>2</sub>", "GT" means "c<sub>1</sub> &gt; c<sub>2</sub>", and "LT" means "c<sub>1</sub> &lt; c<sub>2</sub>". Note that 'c' is the encrypted difference between 'c<sub>1</sub>' and 'c<sub>2</sub>' and 'd' is the decrypted difference between 'c<sub>1</sub>' and 'c<sub>2</sub>'. Function "CP(c<sub>1</sub>, c<sub>2</sub>)" may be shredded into "CP1(c<sub>1</sub>, c<sub>2</sub>)", "CP2(a, c)", and "CP3(b)" using the following process. Values b1 and b2 are randomly selected such that the sum of b1 and b2 is equal to b (b1 + b2 = b). Values u1 and u2 are randomly selected such that the product of u1 and u2 is equal to u mod n (u1 * u2 = u mod n). The functions are defined as follows:
<img id="ib0006" file="imgb0006.tif" wi="80" he="46" img-content="program-listing" img-format="tif"/><!-- EPO <DP n="22"> -->
<img id="ib0007" file="imgb0007.tif" wi="46" he="26" img-content="program-listing" img-format="tif"/>
Combining the functions yields function "CP_shred(c<sub>1</sub>, c<sub>2</sub>)":
<img id="ib0008" file="imgb0008.tif" wi="50" he="20" img-content="program-listing" img-format="tif"/>
In <figref idref="f0016">FIG. 16</figref>, Trusted Computer 1 (TC1) 1600 encrypts message 'm1' with public key 'pk' into Paillier ciphertext 'c1' and message 'm2' with public key 'pk' into Paillier ciphertext 'c2'. TC1 1600 then sends (c<sub>1</sub>, c<sub>2</sub>) to Cloud Computer 2 (CC2) 1610. CC2 1610 calculates "CP1(c<sub>1</sub>, c<sub>2</sub>)" and assigns the result to (a, c), and then sends (a, c) to Cloud Computer 3 (CC3) 1620. CC3 1620 calculates "CP2(a, c)" and assigns the result to 'b', which it sends to Cloud Computer 4 (CC4) 1630. CC4 1630 calculates "CP3(b)" and assigns the result to 'z', and then sends 'z' to CC2 1610. CC2 1610 receives 'z', and performs the conditionals to determine "EQ", "GT", or "LT", which may then be used for further calculations. No cloud computer knows all randomly selected values 'b1', 'b2', 'u1' and 'u2'. In <figref idref="f0016">FIG. 16</figref>, the public key 'pk', is meant to substitute for 'n'.</p>
<p id="p0064" num="0064"><figref idref="f0017">FIG. 17</figref> shows an embodiment of a shredded comparison function using El Gamal encryption. If two integers (both less than n/2, where n is the public key) are encrypted in the El Gamal scheme, order comparison between them may be defined as follows:
<img id="ib0009" file="imgb0009.tif" wi="44" he="21" img-content="program-listing" img-format="tif"/>
where "GP()" is the El Gamal-to-Paillier transition function defined in <figref idref="f0015">FIG. 15</figref> and "CP()" is the Paillier comparison function defined in <figref idref="f0016">FIG. 16</figref>. Function "CG((e<sub>1</sub>, c<sub>1</sub>), (e<sub>2</sub>, c<sub>2</sub>))" may be shredded as follows:
<img id="ib0010" file="imgb0010.tif" wi="54" he="21" img-content="program-listing" img-format="tif"/>
In <figref idref="f0017">FIG. 17</figref>, Trusted Computer 1 (TC1) 1700 encrypts message 'm1' with public key 'pk' into El Gamal ciphertext (e1, c1) and message 'm2' with public key 'pk' into El Gamal ciphertext (e2, c2). TC1 1700 then sends (e1, c1) and (e2, c2) to Cloud Computer 2 (CC2) 1710. CC2 1710 calculates "GP1(e1)" and assigns the result to 'f1' and "GP1(e2)" and assigns the result to 'f2',<!-- EPO <DP n="23"> --> and then sends 'f1' and 'f2' to Cloud Computer 3 (CC3) 1720. CC3 1720 calculates "GP2(f1)" and assigns the result to 'v1' and "GP2(f2)" and assigns the result to 'v2', and then sends 'v1' and 'v2' back to CC2 1710. CC2 1710 calculates "GP3(v1, c1)" and assigns the result to 'p1' and "GP3(v2, c2)" and assigns the result to 'p2'. CC2 1710 calculates "CP1(p1, p2)" and assigns the result to (a, c), and then sends (a, c) to Cloud Computer 3 (CC3) 1720. CC3 1720 calculates "CP2(a, c)" and assigns the result to 'b', which it sends to Cloud Computer 4 (CC4) 1730. CC4 1730 calculates "CP3(b)" and assigns the result to 'z', and then sends 'z' to CC2 1710. CC2 1710 receives 'z', and performs the conditionals to determine "EQ", "GT", or "LT", which may then be used for further calculations. No cloud computer knows all randomly selected values. In <figref idref="f0017">FIG. 17</figref>, the public key 'pk', is meant to substitute for (n, g, q, h).</p>
<p id="p0065" num="0065">As mentioned previously, some embodiments of shredding and obfuscating a mathematical operation might require transitioning an operation from a multiplicative obfuscation scheme to an additive multiplication scheme and vice versa. <figref idref="f0018 f0019">FIGs. 18-19</figref> illustrate two example embodiments of these transition functions.</p>
<p id="p0066" num="0066"><figref idref="f0018">FIG. 18</figref> illustrates an embodiment transitioning from a multiplicative obfuscation scheme to an additive obfuscation scheme. In this example embodiment, the program performs multiplicative blinding of 'a' with a random number 'r', but needs the additive blinding of 'a' with a random number 's'. The transition process is shredded for security. First, Trusted Computer 1 (TC1) 1800 and Trusted Computer 5 (TC5) 1840 select two random numbers, 'r' and 's', to blind 'a'. TC1 1800 computes "a * r" and assigns the result to variable 'c', which it then sends to Cloud Computer 2 (CC2) 1810. CC2 1810 requests multiplicative to additive blinding from Cloud Computer 3 (CC3) 1820. CC3 1820 is given knowledge of random values 'r' and 's', and computes "r * s", assigns the product to variable 'h', and sends 'h' to CC2 1810. CC2 1810 receives the value 'h' from CC3 1820, computes "c + h", and assigns the result to variable 'e', which it sends to Cloud Computer 4 (CC4) 1830. CC4 1830 then unblinds the product by computing "e / r", which it assigns to variable 'f', and sends 'f' to TC5 1840. Finally, TC5 1840 receives the additively-blinded value of a, which equals "a + s". The variable 'a' may be recovered by subtracting 's' from 'f'.</p>
<p id="p0067" num="0067"><figref idref="f0019">FIG. 19</figref> illustrates an embodiment transitioning from an additive obfuscation scheme to a multiplicative obfuscation scheme. The process is essentially the reverse process of that illustrated in <figref idref="f0018">FIG. 18</figref>. Note that, in order to keep the random seeds from being dispersed to more than the necessary computers, the arrows follow a reverse path from that of <figref idref="f0018">FIG. 18</figref>. In this manner for either transition, only the TCs (1800, 1840, 1900, and 1940) and CC3 (1820 and<!-- EPO <DP n="24"> --> 1920) would know both seeds, CC2 (1810 and 1910) would not know any seed, and CC4 (1830 and 1930) would know only the multiplicative seed.</p>
<p id="p0068" num="0068">In the example embodiment of <figref idref="f0019">FIG. 19</figref>, the program performs additive blinding of 'a' with a random number 's', but needs the multiplicative blinding of 'a' with a random number 'r'. The transition process is shredded for security. First, Trusted Computer 1 (TC1) 1900 and Trusted Computer 5 (TC5) 1940 select two random numbers, 'r' and 's', to blind 'a'. TC5 1940 computes "a + s" and assigns the result to variable 'c', which it then sends to Cloud Computer 4 (CC4) 1930. CC4 1930 then blinds the sum by computing "c * r", which it assigns to variable 'e', and sends 'e' to Cloud Computer 2 (CC2) 1910. CC2 1910 requests additive to multiplicative blinding from Cloud Computer 3 (CC3) 1920. CC3 1920 is given knowledge of random values 'r' and 's', and computes "r * s", assigns the product to variable 'h', and sends 'h' to CC2 1910. CC2 1910 receives the value 'h' from CC3 1920, computes "e - h", and assigns the result to variable 'f', which it sends to TC1 1900. Finally, TC1 1900 receives the multiplicatively-blinded value of a, which equals "a * r". The variable 'a' may be recovered by computing "f / r".</p>
<p id="p0069" num="0069">Shredding of the conversion from one blinding scheme to another, as illustrated in <figref idref="f0018 f0019">FIGs. 18-19</figref>, is used so that the plain value of 'a' cannot be computed by an attacker controlling any single cloud computer. During the shredded conversion, the multiplicative key 'r' is exposed to CC4 (1830 and 1930), but an attacker at this computer only sees the additively blinded value of 'a'. Similarly, although an attacker at CC2 (1810 and 1910) sees the multiplicatively blinded value of 'a', the lack of access to the multiplicative blinding key 'r' prevents computation of 'a'. Although both keys 'r' and 's' are exposed at CC3 (1820 and 1920), this computer only serves the product "r * s", and an attacker at CC3 (1820 and 1920) never sees either the additively blinded or multiplicatively blinded value of 'a'.</p>
<p id="p0070" num="0070">The above methods and processes (Method I) are effective against attackers with root access to a single other computer that record and analyze the executed programs, the in-memory data, and the files on disk to observe private information (Threat Level I). However, Method I may not be effective against an attacker that can modify the executing programs, memory, and files on the single other computer to disrupt execution (Threat Level II). To account for this, the above may be extended so that every shred is executed on multiple other computers (Method II). The intermediate data results from the multiple other computers would be checked for consistency, and computation is aborted if an inconsistency is detected. As long as the attacker does not gain control of all other computers that execute a particular shred, Method II is able to thwart attacks from an attacker at Threat Level II. Further, neither Method I<!-- EPO <DP n="25"> --> nor Method II is effective against an attacker that controls all of the other computers in a network (Threat Level III). Method II may be extended so that the other computers chosen for executing a single program span multiple administrative domains or multiple commercially distinct infrastructures (Method III). For example, the other computers may be chosen from different public cloud providers such as Google, Amazon, and/or Microsoft. As long as an attacker does not gain control of all of the domains or infrastructures chosen for a program, Method III is able to thwart attacks from an attacker at Threat Level III.</p>
<p id="p0071" num="0071">Privacy offered by the above methods and processes stems from the shredding of computation and data. The obfuscation and encryption operations add some overhead to the execution latency, but the main contribution to performance degradation is due to the communication latency of the network between the computers. Hence, it is important to minimize the number of messages as well as the size of the messages sent between the various computers involved.</p>
<p id="p0072" num="0072">The disclosures of each patent, patent application, and publication cited or described in this document are hereby incorporated herein by reference, in its entirety.</p>
<p id="p0073" num="0073">Those skilled in the art will appreciate that numerous changes and modifications can be made to the preferred embodiments of the invention as specified in the appended claims.</p>
</description>
<claims id="claims01" lang="en"><!-- EPO <DP n="26"> -->
<claim id="c-en-01-0001" num="0001">
<claim-text>A method for executing a computer program comprising:
<claim-text>dividing a computer program into a series of operations, the computer program being on a trusted computer connected to at least one other computer;</claim-text>
<claim-text>obfuscating, by the trusted computer, each operation of the series of operations before sending each operation to a respective other computer;</claim-text>
<claim-text>sending each operation of the series of operations with accompanying instructions to the at least one other computer, the accompanying instructions operative to compute a result of the respective operation and forward the result to another computer;</claim-text>
<claim-text>receiving, at the trusted computer, a computed outcome of the computer program; and</claim-text>
<claim-text>unobfuscating, by the trusted computer, the received computed outcome of the computer program.</claim-text></claim-text></claim>
<claim id="c-en-01-0002" num="0002">
<claim-text>The method of claim 1, wherein the series of operations are circuit gate operations, each circuit gate operation having an operator, a first operand, and a second operand;
<claim-text>optionally wherein the obfuscating each operation of the series of operations comprises:
<claim-text>obfuscating the first operand with a first random value; and</claim-text>
<claim-text>obfuscating the second operand with a second random value;</claim-text></claim-text>
<claim-text>optionally wherein the sending each operation of the series of operations with accompanying instructions to the at least one other computer comprises:
<claim-text>sending the obfuscated operands to a first computer with instructions comprising:
<claim-text>computing a plurality of results of a plurality of operations using the obfuscated operands; and</claim-text>
<claim-text>sending the plurality of results to a second computer;</claim-text></claim-text>
<claim-text>sending instructions to the second computer comprising:
<claim-text>choosing a result of the plurality of results based upon the operator, the first random value, and the second random value;</claim-text>
<claim-text>obfuscating the chosen result with a third random value; and</claim-text>
<claim-text>sending the chosen result to a different computer.</claim-text></claim-text></claim-text><!-- EPO <DP n="27"> --></claim-text></claim>
<claim id="c-en-01-0003" num="0003">
<claim-text>The method of claim 1, wherein the series of operations are computer mathematical operations, each computer mathematical operation having an operator, a first operand, and a second operand.</claim-text></claim>
<claim id="c-en-01-0004" num="0004">
<claim-text>The method of claim 3 wherein the obfuscating each operation of the series of operations before sending comprises:
<claim-text>obfuscating the first operand with a first random value; and</claim-text>
<claim-text>obfuscating the second operand with a second random value.</claim-text></claim-text></claim>
<claim id="c-en-01-0005" num="0005">
<claim-text>The method of claim 4 wherein the sending each operation of the series of operations with accompanying instructions to the at least one other computer comprises:<br/>
sending the operator and obfuscated operands to a first computer with instructions comprising:
<claim-text>computing a first result of an operation using the operator, the first obfuscated operand, and the second obfuscated operand;</claim-text>
<claim-text>receiving a value from a second computer;</claim-text>
<claim-text>computing a second result of an operation using the operator, the first result, and the value; and</claim-text>
<claim-text>sending the second result to a different computer.</claim-text></claim-text></claim>
<claim id="c-en-01-0006" num="0006">
<claim-text>The method of claim 4 wherein the obfuscation scheme of the first operand does not match the obfuscation scheme of the second operand.</claim-text></claim>
<claim id="c-en-01-0007" num="0007">
<claim-text>The method of claim 6 wherein a transition obfuscation function is used to convert the obfuscation scheme of the first operand to the obfuscation scheme of the second operand using a third random value.</claim-text></claim>
<claim id="c-en-01-0008" num="0008">
<claim-text>The method of claim 7 further comprising:
<claim-text>dividing the transition obfuscation function into a series of operations; and</claim-text>
<claim-text>sending each operation of the transition obfuscation function with accompanying instructions to at least one other computer, the accompanying instructions<!-- EPO <DP n="28"> --> operative to compute a result of the respective operation and forward the result to another computer.</claim-text></claim-text></claim>
<claim id="c-en-01-0009" num="0009">
<claim-text>The method of claim 8 wherein the sending each operation of the transition obfuscation function with accompanying instructions to at least one other computer comprises:<br/>
if the first operand is multiplicatively obfuscated:
<claim-text>sending the obfuscated operand to a first computer with instructions comprising:
<claim-text>receiving a value from a second computer;</claim-text>
<claim-text>computing a sum of the first obfuscated operand and the value; and</claim-text>
<claim-text>sending the sum to a third computer;</claim-text></claim-text>
<claim-text>sending instructions to a third computer comprising:
<claim-text>computing the quotient of the sum and the first random value; and</claim-text>
<claim-text>sending the quotient to a different computer;</claim-text>
if the first operand is additively obfuscated:
<claim-text>sending the obfuscated operand to a third computer with instructions comprising:
<claim-text>computing a product of the first obfuscated operand and the third random value; and</claim-text>
<claim-text>sending the product to a first computer;</claim-text></claim-text>
<claim-text>sending instructions to the first computer comprising:
<claim-text>receiving a value from a second computer;</claim-text>
<claim-text>computing a difference between the product and the value; and</claim-text>
<claim-text>sending the difference to a different computer.</claim-text></claim-text></claim-text></claim-text></claim>
<claim id="c-en-01-0010" num="0010">
<claim-text>The method of claim 9 wherein the value received from the second computer is the product of the first random value and the third random value.</claim-text></claim>
<claim id="c-en-01-0011" num="0011">
<claim-text>The method of claim 1, wherein the obfuscating comprises code obfuscation, data obfuscation, or both.<!-- EPO <DP n="29"> --></claim-text></claim>
<claim id="c-en-01-0012" num="0012">
<claim-text>The method of claim 11 wherein code obfuscation comprises:<br/>
if the series of operations comprises program opcodes:
<claim-text>generating a substitution map that maps the program opcodes to a random permutation of opcodes;</claim-text>
<claim-text>transforming the series of opcodes into the random permutation of opcodes via the substitution map; and</claim-text>
<claim-text>sending the substitution map to a remote computer for use in unobfuscating by the respective other computers.</claim-text></claim-text></claim>
<claim id="c-en-01-0013" num="0013">
<claim-text>The method of claim 12 wherein unobfuscating comprises:
<claim-text>receiving, at the remote computer from another computer, an index corresponding to a portion of the substitution map; and</claim-text>
<claim-text>sending, from the remote computer to the other computer, the portion of the substitution map.</claim-text></claim-text></claim>
<claim id="c-en-01-0014" num="0014">
<claim-text>The method of claim 12 wherein unobfuscating comprises:
<claim-text>sending, from another computer to the remote computer, an index corresponding to a portion of the substitution map;</claim-text>
<claim-text>receiving, at the other computer from the remote computer, the portion of the substitution map; and</claim-text>
<claim-text>transforming the random permutation of opcodes into the series of opcodes via the portion of the substitution map.</claim-text></claim-text></claim>
<claim id="c-en-01-0015" num="0015">
<claim-text>The method of claim 12 wherein code obfuscation if the series of operations comprises program opcodes further comprises:<br/>
combining unrelated functions into a single function.<br/>
optionally wherein the unrelated functions have parameters and retain their respective behaviors, the single function taking the parameters and an additional parameter to select which behavior to perform.<!-- EPO <DP n="30"> --></claim-text></claim>
<claim id="c-en-01-0016" num="0016">
<claim-text>The method of claim 12 wherein code obfuscation if the series of operations comprises program opcodes further comprises:<br/>
converting a function into an infinite loop, the infinite loop containing a switch statement and performing behavior identical to that of the function.</claim-text></claim>
<claim id="c-en-01-0017" num="0017">
<claim-text>The method of claim 12 wherein code obfuscation if the series of operations comprises program opcodes further comprises:<br/>
inserting decoy code into the computer program.</claim-text></claim>
<claim id="c-en-01-0018" num="0018">
<claim-text>The method of claim 17 wherein the decoy code is part of an opaque predicate scheme.</claim-text></claim>
<claim id="c-en-01-0019" num="0019">
<claim-text>The method of claim 17 wherein the decoy code comprises original code of the computer program with a number of minor mutations optionally wherein the number of minor mutations is user-specified.</claim-text></claim>
<claim id="c-en-01-0020" num="0020">
<claim-text>The method of claim 1 further comprising:<br/>
encrypting connections between the trusted computer and the at least one other computer.</claim-text></claim>
<claim id="c-en-01-0021" num="0021">
<claim-text>The method of claim 1 further comprising:
<claim-text>encrypting each data value of each operation of the series of operations;</claim-text>
<claim-text>wherein encrypting each data value of each operation is optionally performed with an additive homomorphic encryption scheme for addition operations and a multiplicative homomorphic encryption scheme for multiplication operations;</claim-text>
<claim-text>wherein transition encryption functions are optionally used to convert additive homomorphic encrypted data values to multiplicative homomorphic encrypted data values and convert multiplicative homomorphic encrypted data values to</claim-text>
<claim-text>additive homomorphic encrypted data values;</claim-text>
wherein the method optionally further comprises:
<claim-text>dividing a transition encryption function into a series of operations; and<!-- EPO <DP n="31"> --></claim-text>
<claim-text>sending each operation of the transition encryption function with accompanying instructions to at least one other computer, the accompanying instructions operative to compute a result of the respective operation and forward the result to another computer.</claim-text></claim-text></claim>
<claim id="c-en-01-0022" num="0022">
<claim-text>The method of claim 1 further comprising:<br/>
encrypting each operation of the series of operations.</claim-text></claim>
<claim id="c-en-01-0023" num="0023">
<claim-text>The method of claim 1 further comprising:<br/>
if, during computation of a result of an operation on a certain computer, the operation requires input from a device connected to a first trusted computer:
<claim-text>generating an input request at a program driver on the certain computer;</claim-text>
<claim-text>passing the input request from the program driver to a network driver;</claim-text>
<claim-text>sending the input request to the first trusted computer via the network driver;</claim-text>
<claim-text>receiving a response of the device at the network driver from the first trusted computer; and</claim-text>
<claim-text>passing the response from the network driver to the program driver for</claim-text>
<claim-text>use in the computation;</claim-text>
optionally wherein the received response is encrypted.</claim-text></claim>
<claim id="c-en-01-0024" num="0024">
<claim-text>The method of claim 1 further comprising:<br/>
if, during computation of a result of an operation on a certain computer, the operation requires input from a device connected to a first trusted computer:
<claim-text>receiving from the certain computer, at a network driver on the first trusted computer, a request for input from the device;</claim-text>
<claim-text>passing the request from the network driver to an input driver for the device;</claim-text>
<claim-text>passing a response from the device from the input driver to the network driver; and</claim-text>
<claim-text>sending the response to the certain computer via the network driver;<!-- EPO <DP n="32"> --></claim-text>
<claim-text>wherein the method optionally further comprises encrypting the response from the device before passing the response from the input driver to the network driver.</claim-text></claim-text></claim>
<claim id="c-en-01-0025" num="0025">
<claim-text>The method of claim 1 further comprising:<br/>
if, during computation of a result of an operation on a certain computer, the operation requires output from a device connected to a first trusted computer:
<claim-text>generating an output request at a program driver on the certain computer;</claim-text>
<claim-text>passing the output request from the program driver to a network driver;</claim-text>
<claim-text>sending the output request to the first trusted computer via the network driver;</claim-text>
<claim-text>receiving a status of the device at the network driver from the first trusted computer; and</claim-text>
<claim-text>passing the status from the network driver to the program driver for use in the computation;</claim-text>
<claim-text>wherein the output request optionally includes encrypted data.</claim-text></claim-text></claim>
<claim id="c-en-01-0026" num="0026">
<claim-text>The method of claim 1 further comprising:<br/>
if, during computation of a result of an operation on a certain computer, the operation requires output from a device connected to a first trusted computer:
<claim-text>receiving from the certain computer, at a network driver on the first trusted computer, a request for output to the device;</claim-text>
<claim-text>passing the request from the network driver to an output driver for the device;</claim-text>
<claim-text>passing a status from the device from the output driver to the network driver; and</claim-text>
<claim-text>sending the status to the certain computer via the network driver;</claim-text>
<claim-text>wherein the request optionally includes encrypted data;</claim-text>
<claim-text>and wherein the method optionally further comprises:<br/>
decrypting the encrypted data before passing the request from the network driver to the output driver.</claim-text></claim-text></claim>
<claim id="c-en-01-0027" num="0027">
<claim-text>The method of claim 1 further comprising:<!-- EPO <DP n="33"> -->
<claim-text>if, during computation of a result of an operation on a certain computer, the operation requires input from a device connected to a first trusted computer:
<claim-text>generating an input request at a program driver on the certain computer;</claim-text>
<claim-text>passing the input request from the program driver to a first network driver;</claim-text>
<claim-text>sending the input request to the first trusted computer via the first network driver;</claim-text>
<claim-text>receiving from the certain computer, at a second network driver on the first trusted computer, the input request;</claim-text>
<claim-text>passing the input request from the second network driver to an input driver for the device;</claim-text>
<claim-text>passing a response from the device from the input driver to the second network driver;</claim-text>
<claim-text>sending the response to the certain computer via the second network driver;</claim-text>
<claim-text>receiving the response of the device at the first network driver from the first trusted computer; and</claim-text>
<claim-text>passing the response from the first network driver to the program driver for use in the computation;</claim-text></claim-text>
<claim-text>wherein the method optionally further comprises:<br/>
encrypting the response from the device before passing the response from the input driver to the second network driver;</claim-text>
<claim-text>optionally wherein the received response from the first trusted computer is encrypted.</claim-text></claim-text></claim>
<claim id="c-en-01-0028" num="0028">
<claim-text>The method of claim 1 further comprising:
<claim-text>if, during computation of a result of an operation on a certain computer, the operation requires output from a device connected to a first trusted computer:
<claim-text>generating an output request at a program driver on the certain computer;</claim-text>
<claim-text>passing the output request from the program driver to a first network driver;</claim-text>
<claim-text>sending the output request to the first trusted computer via the first network driver;</claim-text>
<claim-text>receiving from the certain computer, at a second network driver on the first trusted computer, the output request;<!-- EPO <DP n="34"> --></claim-text>
<claim-text>passing the output request from the second network driver to an output driver for the device;</claim-text>
<claim-text>passing a status from the device from the output driver to the second network driver;</claim-text>
<claim-text>sending the status to the certain computer via the second network driver;</claim-text>
<claim-text>receiving the status at the first network driver from the first trusted computer; and</claim-text>
<claim-text>passing the status from the first network driver to the program driver for use in the computation;</claim-text></claim-text>
<claim-text>wherein the output request optionally includes encrypted data;</claim-text>
<claim-text>wherein the method optionally further comprises:<br/>
decrypting the encrypted data before passing the output request from the second network driver to the output driver.</claim-text></claim-text></claim>
<claim id="c-en-01-0029" num="0029">
<claim-text>The method of claim 1 wherein the at least one other computer is part of a cloud, optionally wherein: the cloud is untrusted, the cloud spans multiple administrative domains; or the cloud spans multiple commercially distinct infrastructures.</claim-text></claim>
<claim id="c-en-01-0030" num="0030">
<claim-text>The method of claim 1 wherein the at least one other computer is part of an enterprise network.</claim-text></claim>
<claim id="c-en-01-0031" num="0031">
<claim-text>The method of claim 1 wherein the at least one other computer is randomly selected from a plurality of computers, optionally wherein each computer of the plurality of computers is untrusted.</claim-text></claim>
<claim id="c-en-01-0032" num="0032">
<claim-text>The method of claim 1 wherein the at least one other computer is untrusted or wherein the at least one other computer is not the trusted computer.</claim-text></claim>
<claim id="c-en-01-0033" num="0033">
<claim-text>The method of claim 1 wherein the sending each operation of the series of operations with accompanying instructions to the at least one other computer comprises sending each operation to multiple computers for computation.<!-- EPO <DP n="35"> --></claim-text></claim>
<claim id="c-en-01-0034" num="0034">
<claim-text>A system comprising at least one trusted computer and at least one other computer, a first trusted computer of the at least one trusted computer having stored thereon computer instructions that during execution cause the first trusted computer to perform the method of any preceding claim.</claim-text></claim>
</claims>
<claims id="claims02" lang="de"><!-- EPO <DP n="36"> -->
<claim id="c-de-01-0001" num="0001">
<claim-text>Verfahren zum Ausführen eines Computerprogramms, das Folgendes umfasst:
<claim-text>Unterteilen eines Computerprogramms in eine Reihe von Operationen, wobei sich das Computerprogramm auf einem vertrauenswürdigen Computer befindet, der mit mindestens einem weiteren Computer verbunden ist;</claim-text>
<claim-text>Verschleiern durch den vertrauenswürdigen Computer jeder Operation der Reihe von Operationen vor einem Senden jeder Operation zu einem jeweiligen weiteren Computer;</claim-text>
<claim-text>Senden jeder Operation der Reihe von Operationen mit begleitenden Befehlen zu dem mindestens einen weiteren Computer, wobei die begleitenden Befehle betreibbar sind zum Berechnen eines Ergebnisses der jeweiligen Operation und Weiterleiten des Ergebnisses zu einem weiteren Computer;</claim-text>
<claim-text>Empfangen bei dem vertrauenswürdigen Computer eines berechneten Ergebnisses des Computerprogramms und</claim-text>
<claim-text>Entschleiern durch den vertrauenswürdigen Computer des empfangenen berechneten Ergebnisses des Computerprogramms.</claim-text></claim-text></claim>
<claim id="c-de-01-0002" num="0002">
<claim-text>Verfahren nach Anspruch 1, wobei die Reihe von Operationen Schaltungsgatteroperationen sind und jede Schaltungsgatteroperation einen Operator, einen ersten Operanden und einen zweiten Operanden besitzt;<!-- EPO <DP n="37"> -->
<claim-text>wobei das Verschleiern jeder Operation der Reihe von Operationen wahlweise Folgendes umfasst:
<claim-text>Verschleiern des ersten Operanden mit einem ersten Zufallswert und</claim-text>
<claim-text>Verschleiern des zweiten Operanden mit einem zweiten Zufallswert; und</claim-text></claim-text>
<claim-text>wobei das Senden jeder Operation der Reihe von Operationen mit begleitenden Befehlen zum mindestens einen weiteren Computer wahlweise Folgendes umfasst:
<claim-text>Senden der verschleierten Operanden zu einem ersten Computer mit Befehlen, die Folgendes umfassen:
<claim-text>Berechnen mehrerer Ergebnisse mehrerer Operationen unter Verwendung der verschleierten Operanden und</claim-text>
<claim-text>Senden der mehreren Ergebnisse zu einem zweiten Computer; und</claim-text></claim-text>
<claim-text>Senden von Befehlen zum zweiten Computer, die Folgendes umfassen:
<claim-text>Wählen eines Ergebnisses der mehreren Ergebnisse auf der Grundlage des Operators, des ersten Zufallswerts und des zweiten Zufallswerts;</claim-text>
<claim-text>Verschleiern des gewählten Ergebnisses mit einem dritten Zufallswert und</claim-text>
<claim-text>Senden des gewählten Ergebnisses zu einem anderen Computer.</claim-text></claim-text></claim-text></claim-text></claim>
<claim id="c-de-01-0003" num="0003">
<claim-text>Verfahren nach Anspruch 1, wobei die Reihe von Operationen mathematische Computeroperationen sind und jede mathematische Computeroperation einen Operator, einen ersten Operanden und einen zweiten Operanden besitzt.</claim-text></claim>
<claim id="c-de-01-0004" num="0004">
<claim-text>Verfahren nach Anspruch 3, wobei das Verschleiern jeder Operation der Reihe von Operationen vor dem Senden Folgendes umfasst:
<claim-text>Verschleiern des ersten Operanden mit einem ersten Zufallswert und</claim-text>
<claim-text>Verschleiern des zweiten Operanden mit einem zweiten Zufallswert.</claim-text><!-- EPO <DP n="38"> --></claim-text></claim>
<claim id="c-de-01-0005" num="0005">
<claim-text>Verfahren nach Anspruch 4, wobei das Senden jeder Operation der Reihe von Operationen mit begleitenden Befehlen zu dem mindestens einen weiteren Computer Folgendes umfasst:<br/>
Senden des Operators und der verschleierten Operanden zu einem ersten Computer mit Befehlen, die Folgendes umfassen:
<claim-text>Berechnen eines ersten Ergebnisses einer Operation unter Verwendung des Operators, des ersten verschleierten Operanden und des zweiten verschleierten Operanden;</claim-text>
<claim-text>Empfangen eines Werts von einem zweiten Computer;</claim-text>
<claim-text>Berechnen eines zweiten Ergebnisses einer Operation unter Verwendung des Operators, des ersten Ergebnisses und des Werts und</claim-text>
<claim-text>Senden des zweiten Ergebnisses zu einem anderen Computer.</claim-text></claim-text></claim>
<claim id="c-de-01-0006" num="0006">
<claim-text>Verfahren nach Anspruch 4, wobei das Verschleierungsschema des ersten Operanden nicht mit dem Verschleierungsschema des zweiten Operanden übereinstimmt.</claim-text></claim>
<claim id="c-de-01-0007" num="0007">
<claim-text>Verfahren nach Anspruch 6, wobei eine Übergangsverschleierungsfunktion verwendet wird, um unter Verwendung eines dritten Zufallswerts das Verschleierungsschema des ersten Operanden zum Verschleierungsschema des zweiten Operanden umzuwandeln.</claim-text></claim>
<claim id="c-de-01-0008" num="0008">
<claim-text>Verfahren nach Anspruch 7, das ferner Folgendes umfasst:
<claim-text>Unterteilen der Übergangsverschleierungsfunktion in eine Reihe von Operationen und</claim-text>
<claim-text>Senden jeder Operation der Übergangsverschleierungsfunktion mit begleitenden Befehlen zu mindestens einem weiteren Computer, wobei die begleitenden Befehle betreibbar sind zum Berechnen eines Ergebnisses der jeweiligen Operation und Weiterleiten des Ergebnisses zu einem weiteren Computer.</claim-text><!-- EPO <DP n="39"> --></claim-text></claim>
<claim id="c-de-01-0009" num="0009">
<claim-text>Verfahren nach Anspruch 8, wobei das Senden jeder Operation der Übergangsverschleierungsfunktion mit begleitenden Befehlen zu mindestens einem weiteren Computer Folgendes umfasst:<br/>
dann, wenn der erste Operand multiplikativ verschleiert ist:
<claim-text>Senden des verschleierten Operanden zu einem ersten Computer mit Befehlen, die Folgendes umfassen:
<claim-text>Empfangen eines Werts von einem zweiten Computer;</claim-text>
<claim-text>Berechnen einer Summe des ersten verschleierten Operanden und des Werts und</claim-text>
<claim-text>Senden der Summe zu einem dritten Computer;</claim-text></claim-text>
<claim-text>Senden von Befehlen zu einem dritten Computer, die Folgendes umfassen:<br/>
Berechnen des Quotienten der Summe und des ersten Zufallswerts und</claim-text>
<claim-text>Senden des Quotienten zu einem anderen Computer; und</claim-text>
<claim-text>dann, wenn der erste Operand additiv verschleiert ist:
<claim-text>Senden des verschleierten Operanden zu einem dritten Computer mit Befehlen, die Folgendes umfassen:
<claim-text>Berechnen eines Produkts des ersten verschleierten Operanden und des dritten Zufallswerts und</claim-text>
<claim-text>Senden des Produkts zu einem ersten Computer; und</claim-text></claim-text>
<claim-text>Senden von Befehlen zum ersten Computer, die Folgendes umfassen:
<claim-text>Empfangen eines Werts von einem zweiten Computer;</claim-text>
<claim-text>Berechnen einer Differenz zwischen dem Produkt und dem Wert und</claim-text>
<claim-text>Senden der Differenz zu einem anderen Computer.</claim-text></claim-text></claim-text></claim-text></claim>
<claim id="c-de-01-0010" num="0010">
<claim-text>Verfahren nach Anspruch 9, wobei der Wert, der vom zweiten Computer empfangen wird, das Produkt des ersten Zufallswerts und des dritten Zufallswerts ist.<!-- EPO <DP n="40"> --></claim-text></claim>
<claim id="c-de-01-0011" num="0011">
<claim-text>Verfahren nach Anspruch 1, wobei das Verschleiern eine Codeverschleierung und/oder eine Datenverschleierung umfasst.</claim-text></claim>
<claim id="c-de-01-0012" num="0012">
<claim-text>Verfahren nach Anspruch 11, wobei die Codeverschleierung Folgendes umfasst:<br/>
dann, wenn die Reihe von Operationen Programmbefehlscodes umfasst:
<claim-text>Erzeugen einer Ersetzungsabbildung, die die Programmbefehlscodes auf eine zufällige Permutation von Befehlscodes abbildet;</claim-text>
<claim-text>Umwandeln der Reihe von Befehlscodes in die zufällige Permutation von Befehlscodes mittels der Ersetzungsabbildung und</claim-text>
<claim-text>Senden der Ersetzungsabbildung zu einem entfernten Computer zur Verwendung beim Entschleiern durch die jeweiligen weiteren Computer.</claim-text></claim-text></claim>
<claim id="c-de-01-0013" num="0013">
<claim-text>Verfahren nach Anspruch 12, wobei das Entschleiern Folgendes umfasst:
<claim-text>Empfangen beim entfernten Computer von einem weiteren Computer eines Index, der einem Abschnitt der Ersetzungsabbildung entspricht; und</claim-text>
<claim-text>Senden vom entfernten Computer zum weiteren Computer des Abschnitts der Ersetzungsabbildung.</claim-text></claim-text></claim>
<claim id="c-de-01-0014" num="0014">
<claim-text>Verfahren nach Anspruch 12, wobei das Entschleiern Folgendes umfasst:
<claim-text>Senden von einem weiteren Computer zum entfernten Computer eines Index, der einem Abschnitt der Ersetzungsabbildung entspricht;</claim-text>
<claim-text>Empfangen beim weiteren Computer vom entfernten Computer des Abschnitts der Ersetzungsabbildung und</claim-text>
<claim-text>Umwandeln der zufälligen Permutation von Befehlscodes in der Reihe von Befehlscodes mittels des Abschnitts der Ersetzungsabbildung.</claim-text><!-- EPO <DP n="41"> --></claim-text></claim>
<claim id="c-de-01-0015" num="0015">
<claim-text>Verfahren nach Anspruch 12, wobei dann, wenn die Reihe von Operationen Programmbefehlscodes umfasst, die Codeverschleierung ferner Folgendes umfasst:
<claim-text>Kombinieren nicht in Beziehung stehender Funktionen in eine einzelne Funktion; wobei</claim-text>
<claim-text>wahlweise die nicht in Beziehung stehenden Funktionen Parameter besitzen und ihre jeweiligen Verhalten behalten und die einzelne Funktion die Parameter und einen zusätzlichen Parameter aufnimmt, um zu wählen, welches Verhalten durchgeführt werden soll.</claim-text></claim-text></claim>
<claim id="c-de-01-0016" num="0016">
<claim-text>Verfahren nach Anspruch 12, wobei dann, wenn die Reihe von Operationen Programmbefehlscodes umfasst, die Codeverschleierung ferner Folgendes umfasst:<br/>
Umwandeln einer Funktion in eine Endlosschleife, wobei die Endlosschleife eine Schaltanweisung enthält und ein Verhalten durchführt, das mit dem der Funktion identisch ist.</claim-text></claim>
<claim id="c-de-01-0017" num="0017">
<claim-text>Verfahren nach Anspruch 12, wobei dann, wenn die Reihe von Operationen Programmbefehlscodes umfasst, die Codeverschleierung ferner Folgendes umfasst:<br/>
Einsetzen von Täuschcode in das Computerprogramm.</claim-text></claim>
<claim id="c-de-01-0018" num="0018">
<claim-text>Verfahren nach Anspruch 17, wobei der Täuschcode Teil eines undurchsichtigen Prädikatenschemas ist.</claim-text></claim>
<claim id="c-de-01-0019" num="0019">
<claim-text>Verfahren nach Anspruch 17, wobei der Täuschcode ursprünglichen Code des Computerprogramms mit mehreren geringfügigen Veränderungen umfasst, wobei wahlweise die Anzahl von geringfügigen Veränderungen vom Anwender festgelegt wird.</claim-text></claim>
<claim id="c-de-01-0020" num="0020">
<claim-text>Verfahren nach Anspruch 1, das ferner Folgendes umfasst:<br/>
Verschlüsseln von Verbindungen zwischen dem vertrauenswürdigen Computer und dem mindestens einen weiteren Computer.<!-- EPO <DP n="42"> --></claim-text></claim>
<claim id="c-de-01-0021" num="0021">
<claim-text>Verfahren nach Anspruch 1, das ferner Folgendes umfasst:
<claim-text>Verschlüsseln jedes Datenwerts jeder Operation der Reihe von Operationen; wobei</claim-text>
<claim-text>das Verschlüsseln jedes Datenwerts jeder Operation wahlweise mit einem additiven homomorphen Verschlüsselungsschema für Additionsoperationen und einem multiplikativen homomorphen Verschlüsselungsschema für Multiplikationsoperationen durchgeführt wird;</claim-text>
<claim-text>wahlweise Übergangsverschlüsselungsfunktionen verwendet werden, um additiv homomorph verschlüsselte Datenwerte zu multiplikativ homomorph verschlüsselten Datenwerten umzuwandeln und multiplikativ homomorph verschlüsselte Datenwerte zu additiv homomorph verschlüsselten Datenwerten umzuwandeln; und</claim-text>
<claim-text>das Verfahren wahlweise ferner Folgendes umfasst:
<claim-text>Unterteilen einer Übergangsverschlüsselungsfunktion in eine Reihe von Operationen und</claim-text>
<claim-text>Senden jeder Operation der Übergangsverschlüsselungsfunktion mit begleitenden Befehlen zu mindestens einem weiteren Computer, wobei die begleitenden Befehle betreibbar sind zum Berechnen eines Ergebnisses der jeweiligen Operation und Weiterleiten des Ergebnisses zu einem weiteren Computer.</claim-text></claim-text></claim-text></claim>
<claim id="c-de-01-0022" num="0022">
<claim-text>Verfahren nach Anspruch 1, das ferner Folgendes umfasst:<br/>
Verschlüsseln jeder Operation der Reihe von Operationen.</claim-text></claim>
<claim id="c-de-01-0023" num="0023">
<claim-text>Verfahren nach Anspruch 1, das ferner Folgendes umfasst:<br/>
dann, wenn während der Berechnung eines Ergebnisses einer Operation in einem bestimmten Computer die Operation eine Eingabe von einer Vorrichtung, die mit einem ersten vertrauenswürdigen Computer verbunden ist, erfordert:
<claim-text>Erzeugen einer Eingabeanforderung bei einem Programmtreiber im bestimmten Computer;<!-- EPO <DP n="43"> --></claim-text>
<claim-text>Weiterleiten der Eingabeanforderung vom Programmtreiber zu einem Netztreiber;</claim-text>
<claim-text>Senden der Eingabeanforderung zum ersten vertrauenswürdigen Computer mittels des Netztreibers;</claim-text>
<claim-text>Empfangen einer Antwort der Vorrichtung beim Netztreiber vom ersten vertrauenswürdigen Computer und</claim-text>
<claim-text>Weiterleiten der Antwort vom Netztreiber zum Programmtreiber zur Verwendung in der Berechnung; wobei</claim-text>
<claim-text>die empfangene Antwort wahlweise verschlüsselt wird.</claim-text></claim-text></claim>
<claim id="c-de-01-0024" num="0024">
<claim-text>Verfahren nach Anspruch 1, das ferner Folgendes umfasst:<br/>
dann, wenn während der Berechnung eines Ergebnisses einer Operation in einem bestimmten Computer die Operation eine Eingabe von einer Vorrichtung, die mit einem ersten vertrauenswürdigen Computer verbunden ist, erfordert:
<claim-text>Empfangen vom bestimmten Computer bei einem Netztreiber im ersten vertrauenswürdigen Computer einer Anforderung einer Eingabe von der Vorrichtung;</claim-text>
<claim-text>Weiterleiten der Anforderung vom Netztreiber zu einem Eingabetreiber für die Vorrichtung;</claim-text>
<claim-text>Weiterleiten einer Antwort von der Vorrichtung vom Eingabetreiber zum Netztreiber und</claim-text>
<claim-text>Senden der Antwort zum bestimmten Computer mittels des Netztreibers; wobei</claim-text>
<claim-text>das Verfahren wahlweise ferner ein Verschlüsseln der Antwort der Vorrichtung vor dem Weiterleiten der Antwort vom Eingabetreiber zum Netztreiber umfasst.</claim-text></claim-text></claim>
<claim id="c-de-01-0025" num="0025">
<claim-text>Verfahren nach Anspruch 1, das ferner Folgendes umfasst:<br/>
dann, wenn während der Berechnung eines Ergebnisses einer Operation in einem bestimmten Computer die Operation eine Ausgabe von einer Vorrichtung, die mit einem ersten vertrauenswürdigen Computer verbunden ist, erfordert:
<claim-text>Erzeugen einer Ausgabeanforderung bei einem Programmtreiber im bestimmten Computer;<!-- EPO <DP n="44"> --></claim-text>
<claim-text>Weiterleiten der Ausgabeanforderung vom Programmtreiber zu einem Netztreiber;</claim-text>
<claim-text>Senden der Ausgabeanforderung zum ersten vertrauenswürdigen Computer mittels des Netztreibers;</claim-text>
<claim-text>Empfangen eines Status der Vorrichtung beim Netztreiber vom ersten vertrauenswürdigen Computer und</claim-text>
<claim-text>Weiterleiten des Status vom Netztreiber zum Programmtreiber zur Verwendung in der Berechnung; wobei</claim-text>
<claim-text>die Ausgabeanforderung wahlweise verschlüsselte Daten enthält.</claim-text></claim-text></claim>
<claim id="c-de-01-0026" num="0026">
<claim-text>Verfahren nach Anspruch 1, das ferner Folgendes umfasst:<br/>
dann, wenn während der Berechnung eines Ergebnisses einer Operation in einem bestimmten Computer die Operation eine Ausgabe von einer Vorrichtung, die mit einem ersten vertrauenswürdigen Computer verbunden ist, erfordert:
<claim-text>Empfangen von dem bestimmten Computer bei einem Netztreiber im ersten vertrauenswürdigen Computer einer Anforderung einer Ausgabe zur Vorrichtung;</claim-text>
<claim-text>Weiterleiten der Anforderung vom Netztreiber zu einem Ausgabetreiber für die Vorrichtung;</claim-text>
<claim-text>Weiterleiten eines Status von der Vorrichtung vom Ausgabetreiber zum Netztreiber und</claim-text>
<claim-text>Senden des Status zu dem bestimmten Computer mittels des Netztreibers; wobei</claim-text>
<claim-text>die Anforderung wahlweise verschlüsselte Daten enthält; und</claim-text>
<claim-text>das Verfahren wahlweise ferner Folgendes umfasst:<br/>
Entschlüsseln der verschlüsselten Daten vor dem Weiterleiten der Anforderung vom Netztreiber zum Ausgabetreiber.</claim-text></claim-text></claim>
<claim id="c-de-01-0027" num="0027">
<claim-text>Verfahren nach Anspruch 1, das ferner Folgendes umfasst:<br/>
dann, wenn während der Berechnung eines Ergebnisses einer Operation in einem bestimmten Computer die Operation eine Eingabe von einer Vorrichtung, die mit<!-- EPO <DP n="45"> --> einem ersten vertrauenswürdigen Computer verbunden ist, erfordert:
<claim-text>Erzeugen einer Eingabeanforderung bei einem Programmtreiber im bestimmten Computer;</claim-text>
<claim-text>Weiterleiten der Eingabeanforderung vom Programmtreiber zu einem ersten Netztreiber;</claim-text>
<claim-text>Senden der Eingabeanforderung zum ersten vertrauenswürdigen Computer mittels des ersten Netztreibers;</claim-text>
<claim-text>Empfangen vom bestimmten Computer bei einem zweiten Netztreiber im ersten vertrauenswürdigen Computer der Eingabeanforderung;</claim-text>
<claim-text>Weiterleiten der Eingabeanforderung vom zweiten Netztreiber zu einem Eingabetreiber für die Vorrichtung;</claim-text>
<claim-text>Weiterleiten einer Antwort von der Vorrichtung vom Eingabetreiber zum zweiten Netztreiber;</claim-text>
<claim-text>Senden der Antwort zum bestimmten Computer mittels des zweiten Netztreibers;</claim-text>
<claim-text>Empfangen der Antwort der Vorrichtung beim ersten Netztreiber vom ersten vertrauenswürdigen Computer und</claim-text>
<claim-text>Weiterleiten der Antwort vom ersten Netztreiber zum Programmtreiber zur Verwendung in der Berechnung; wobei</claim-text>
<claim-text>das Verfahren wahlweise ferner Folgendes umfasst:
<claim-text>Verschlüsseln der Antwort von der Vorrichtung vor dem Weiterleiten der Antwort vom Eingabetreiber zum zweiten Netztreiber; wobei</claim-text>
<claim-text>wahlweise die empfangene Antwort vom ersten vertrauenswürdigen Computer verschlüsselt wird.</claim-text></claim-text></claim-text></claim>
<claim id="c-de-01-0028" num="0028">
<claim-text>Verfahren nach Anspruch 1, das ferner Folgendes umfasst:<br/>
dann, wenn während der Berechnung eines Ergebnisses einer Operation in einem bestimmten Computer die Operation eine Ausgabe von einer Vorrichtung, die mit einem ersten vertrauenswürdigen Computer verbunden ist, erfordert:
<claim-text>Erzeugen einer Ausgabeanforderung bei einem Programmtreiber im bestimmten Computer;<!-- EPO <DP n="46"> --></claim-text>
<claim-text>Weiterleiten der Ausgabeanforderung vom Programmtreiber zu einem ersten Netztreiber;</claim-text>
<claim-text>Senden der Ausgabeanforderung zum ersten vertrauenswürdigen Computer mittels des ersten Netztreibers;</claim-text>
<claim-text>Empfangen vom bestimmten Computer bei einem zweiten Netztreiber im ersten vertrauenswürdigen Computer der Ausgabeanforderung;</claim-text>
<claim-text>Weiterleiten der Ausgabeanforderung vom zweiten Netztreiber zu einem Ausgabetreiber für die Vorrichtung;</claim-text>
<claim-text>Weiterleiten eines Status der Vorrichtung vom Ausgabetreiber zum zweiten Netztreiber;</claim-text>
<claim-text>Senden des Status zum bestimmten Computer mittels des zweiten Netztreibers;</claim-text>
<claim-text>Empfangen des Status beim ersten Netztreiber vom ersten vertrauenswürdigen Computer und</claim-text>
<claim-text>Weiterleiten des Status vom ersten Netztreiber zum Programmtreiber zur Verwendung in der Berechnung; wobei</claim-text>
<claim-text>die Ausgabeanforderung wahlweise verschlüsselte Daten enthält und</claim-text>
<claim-text>das Verfahren wahlweise ferner Folgendes umfasst:<br/>
Entschlüsseln der verschlüsselten Daten vor dem Weiterleiten der Ausgabeanforderung vom zweiten Netztreiber zum Ausgabetreiber.</claim-text></claim-text></claim>
<claim id="c-de-01-0029" num="0029">
<claim-text>Verfahren nach Anspruch 1, wobei der mindestens eine weitere Computer Teil einer Cloud ist und wahlweise: die Cloud nicht vertrauenswürdig ist, die Cloud mehrere administrative Domänen umfasst oder die Cloud mehrere kommerziell verschiedene Infrastrukturen umfasst.</claim-text></claim>
<claim id="c-de-01-0030" num="0030">
<claim-text>Verfahren nach Anspruch 1, wobei der mindestens eine weitere Computer Teil eines Unternehmensnetzes ist.</claim-text></claim>
<claim id="c-de-01-0031" num="0031">
<claim-text>Verfahren nach Anspruch 1, wobei der mindestens eine weitere Computer aus mehreren Computern zufällig gewählt ist und wahlweise jeder Computer der mehreren Computer nicht vertrauenswürdig ist.<!-- EPO <DP n="47"> --></claim-text></claim>
<claim id="c-de-01-0032" num="0032">
<claim-text>Verfahren nach Anspruch 1, wobei der mindestens eine weitere Computer nicht vertrauenswürdig ist oder der mindestens eine weitere Computer nicht der vertrauenswürdige Computer ist.</claim-text></claim>
<claim id="c-de-01-0033" num="0033">
<claim-text>Verfahren nach Anspruch 1, wobei das Senden jeder Operation der Reihe von Operationen mit begleitenden Befehlen zum mindestens einen weiteren Computer ein Senden jeder Operation zu mehreren Computern zur Berechnung umfasst.</claim-text></claim>
<claim id="c-de-01-0034" num="0034">
<claim-text>System, das mindestens einen vertrauenswürdigen Computer und mindestens einen weiteren Computer umfasst, wobei in einem ersten vertrauenswürdigen Computer des mindestens einen vertrauenswürdigen Computers Computerbefehle gespeichert sind, die während einer Ausführung den ersten vertrauenswürdigen Computer veranlassen, das Verfahren nach einem beliebigen vorhergehenden Anspruch durchzuführen.</claim-text></claim>
</claims>
<claims id="claims03" lang="fr"><!-- EPO <DP n="48"> -->
<claim id="c-fr-01-0001" num="0001">
<claim-text>Procédé d'exécution d'un programme informatique comprenant les étapes suivantes :
<claim-text>diviser un programme informatique en une série d'opérations, le programme informatique étant sur un ordinateur de confiance connecté à au moins un autre ordinateur ;</claim-text>
<claim-text>obscurcir, par l'ordinateur de confiance, chaque opération de la série d'opérations avant d'envoyer chaque opération à un autre ordinateur respectif ;</claim-text>
<claim-text>envoyer chaque opération de la série d'opérations avec des instructions d'accompagnement à l'au moins un autre ordinateur, les instructions d'accompagnement servant à calculer un résultat de l'opération respective et à transmettre le résultat à un autre ordinateur ;</claim-text>
<claim-text>recevoir, au niveau de l'ordinateur de confiance, un résultat calculé du programme informatique ; et</claim-text>
<claim-text>désobscurcir, par l'ordinateur de confiance, le résultat calculé reçu du programme informatique.</claim-text></claim-text></claim>
<claim id="c-fr-01-0002" num="0002">
<claim-text>Procédé selon la revendication 1, dans lequel la série d'opérations consiste en des opérations de porte de circuit, chaque opération de porte de circuit ayant un opérateur, un premier opérande, et un second opérande ;<br/>
<!-- EPO <DP n="49"> -->dans lequel, optionnellement, l'obscurcissement de chaque opération de la série d'opérations comprend les étapes suivantes :
<claim-text>obscurcir le premier opérande avec une première valeur aléatoire ; et</claim-text>
<claim-text>obscurcir le second opérande avec une deuxième valeur aléatoire ;</claim-text>
<claim-text>où, optionnellement, l'envoi de chaque opération de la série d'opérations avec des instructions d'accompagnement à l'au moins un autre ordinateur comprend :<br/>
l'envoi des opérandes obscurcis à un premier ordinateur avec des instructions comprenant :
<claim-text>le calcul d'une pluralité de résultats d'une pluralité d'opérations en utilisant les opérandes obscurcis ; et</claim-text>
<claim-text>l'envoi de la pluralité de résultats à un deuxième ordinateur ;</claim-text>
<claim-text>l'envoi des instructions au deuxième ordinateur comprenant :
<claim-text>le choix d'un résultat de la pluralité de résultats en fonction de l'opérateur, de la première valeur aléatoire et de la deuxième valeur aléatoire ; l'obscurcissement du résultat choisi avec une troisième valeur aléatoire ; et</claim-text>
<claim-text>l'envoi du résultat choisi à un ordinateur différent.</claim-text></claim-text></claim-text></claim-text></claim>
<claim id="c-fr-01-0003" num="0003">
<claim-text>Procédé selon la revendication 1, dans lequel les séries d'opérations sont des opérations mathématiques informatiques, chaque opération mathématique informatique ayant un opérateur, un premier opérande, et un second opérande.</claim-text></claim>
<claim id="c-fr-01-0004" num="0004">
<claim-text>Procédé selon la revendication 3, dans lequel l'obscurcissement de chaque opération de la série d'opérations avant l'envoi comprend :<!-- EPO <DP n="50"> -->
<claim-text>l'obscurcissement du premier opérande avec une première valeur aléatoire ; et</claim-text>
<claim-text>l'obscurcissement du second opérande avec une deuxième valeur aléatoire.</claim-text></claim-text></claim>
<claim id="c-fr-01-0005" num="0005">
<claim-text>Procédé selon la revendication 4, dans lequel l'envoi de chaque opération de la série d'opérations avec des instructions d'accompagnement à l'au moins un autre ordinateur comprend :<br/>
l'envoi de l'opérateur et des opérandes obscurcis à un premier ordinateur avec des instructions comprenant :
<claim-text>le calcul d'un premier résultat d'une opération en utilisant l'opérateur, le premier opérande obscurci et le second opérande obscurci ;</claim-text>
<claim-text>la réception d'une valeur d'un deuxième ordinateur ;</claim-text>
<claim-text>le calcul d'un second résultat d'une opération en utilisant l'opérateur, le premier résultat et la valeur ; et</claim-text>
<claim-text>l'envoi du second résultat à un ordinateur différent.</claim-text></claim-text></claim>
<claim id="c-fr-01-0006" num="0006">
<claim-text>Procédé selon la revendication 4, dans lequel le schéma d'obscurcissement du premier opérande ne correspond pas au schéma d'obscurcissement du second opérande.</claim-text></claim>
<claim id="c-fr-01-0007" num="0007">
<claim-text>Procédé selon la revendication 6, dans lequel une fonction d'obscurcissement de transition est utilisée pour convertir le schéma d'obscurcissement du premier opérande en schéma d'obscurcissement du second opérande en utilisant une troisième valeur aléatoire.</claim-text></claim>
<claim id="c-fr-01-0008" num="0008">
<claim-text>Procédé selon la revendication 7, comprenant en outre :
<claim-text>la division de la fonction d'obscurcissement de transition en une série d'opérations ; et<!-- EPO <DP n="51"> --></claim-text>
<claim-text>l'envoi de chaque opération de la fonction d'obscurcissement de transition avec des instructions d'accompagnement à au moins un autre ordinateur, les instructions d'accompagnement opérant pour calculer un résultat de l'opération respective et retransmettre le résultat à un autre ordinateur.</claim-text></claim-text></claim>
<claim id="c-fr-01-0009" num="0009">
<claim-text>Procédé selon la revendication 8, dans lequel l'envoi de chaque opération de la fonction d'obscurcissement de transition avec des instructions d'accompagnement à au moins un autre ordinateur comprend les étapes suivantes :
<claim-text>si le premier opérande est obscurci de manière multiplicative :<br/>
envoyer l'opérande obscurci à un premier ordinateur avec des instructions comprenant :
<claim-text>la réception d'une valeur d'un deuxième ordinateur ;</claim-text>
<claim-text>le calcul d'une somme du premier opérande obscurci et</claim-text>
<claim-text>de la valeur ; et</claim-text>
<claim-text>l'envoi de la somme à un troisième ordinateur ;</claim-text>
<claim-text>envoyer des instructions à un troisième ordinateur comprenant :
<claim-text>le calcul du quotient de la somme et de la première valeur aléatoire ; et</claim-text>
<claim-text>l'envoi du quotient à un ordinateur différent ;</claim-text>
<claim-text>si le premier opérande est obscurci de manière additive :<br/>
envoyer l'opérande obscurci à un troisième ordinateur avec des instructions comprenant :
<claim-text>le calcul d'un produit du premier opérande obscurci et</claim-text>
<claim-text>de la troisième valeur aléatoire ; et</claim-text>
<claim-text>l'envoi du produit à un premier ordinateur ;</claim-text>
<claim-text>envoyer des instructions au premier ordinateur, comprenant :<!-- EPO <DP n="52"> -->
<claim-text>la réception d'une valeur depuis un deuxième ordinateur ;</claim-text>
<claim-text>le calcul d'une différence entre le produit et la valeur ; et</claim-text>
<claim-text>l'envoi de la différence à un ordinateur différent.</claim-text></claim-text></claim-text></claim-text></claim-text></claim-text></claim>
<claim id="c-fr-01-0010" num="0010">
<claim-text>Procédé selon la revendication 9, dans lequel la valeur reçue du deuxième ordinateur est le produit de la première valeur aléatoire et de la troisième valeur aléatoire.</claim-text></claim>
<claim id="c-fr-01-0011" num="0011">
<claim-text>Procédé selon la revendication 1, dans lequel l'obscurcissement comprend l'obscurcissement du code, l'obscurcissement des données, ou les deux.</claim-text></claim>
<claim id="c-fr-01-0012" num="0012">
<claim-text>Procédé selon la revendication 11, dans lequel l'obscurcissement du code comprend les étapes suivantes :<br/>
si la série d'opérations comprend des codes d'opérations de programme :
<claim-text>générer une carte de substitution qui fait correspondre les codes d'opérations de programme à une permutation aléatoire de codes d'opérations ;</claim-text>
<claim-text>transformer la série de codes d'opérations en une permutation aléatoire de codes d'opérations par l'intermédiaire de la carte de substitution ; et</claim-text>
<claim-text>envoyer la carte de substitution à un ordinateur distant pour l'utiliser pour un désobscurcissement par les autres ordinateurs respectifs.</claim-text></claim-text></claim>
<claim id="c-fr-01-0013" num="0013">
<claim-text>Procédé selon la revendication 12, dans lequel le désobscurcissement comprend les étapes suivantes :
<claim-text>recevoir, au niveau de l'ordinateur distant, et depuis un autre ordinateur, un index correspondant à une partie de la carte de substitution ; et<!-- EPO <DP n="53"> --></claim-text>
<claim-text>envoyer, depuis l'ordinateur distant et vers l'autre ordinateur, la partie de la carte de substitution.</claim-text></claim-text></claim>
<claim id="c-fr-01-0014" num="0014">
<claim-text>Procédé selon la revendication 12, dans lequel le désobscurcissement comprend les étapes suivantes :
<claim-text>envoyer, depuis un autre ordinateur et vers l'ordinateur distant, un index correspondant à une partie de la carte de substitution ;</claim-text>
<claim-text>recevoir, au niveau de l'autre ordinateur et depuis l'ordinateur distant, la partie de la carte de substitution ; et</claim-text>
<claim-text>transformer la permutation aléatoire de codes d'opérations en la série de codes d'opérations par l'intermédiaire de la carte de substitution.</claim-text></claim-text></claim>
<claim id="c-fr-01-0015" num="0015">
<claim-text>Procédé selon la revendication 12, dans lequel l'obscurcissement de code, si la série d'opérations comprend des codes d'opérations de programme, comprend en outre les étapes suivantes :<br/>
combiner des fonctions non liées en une seule fonction, où, optionnellement, les fonctions non liées ont des paramètres et conservent leurs comportements respectifs, la fonction unique prenant les paramètres et un paramètre supplémentaire pour sélectionner le comportement à exécuter.</claim-text></claim>
<claim id="c-fr-01-0016" num="0016">
<claim-text>Procédé selon la revendication 12, dans lequel l'obscurcissement de code, si la série d'opérations comprend des codes d'opérations de programme, comprend en outre l'étape suivante :<br/>
convertir une fonction en une boucle infinie, la boucle infinie contenant une instruction de commutation et exécutant un comportement identique à celui de la fonction.<!-- EPO <DP n="54"> --></claim-text></claim>
<claim id="c-fr-01-0017" num="0017">
<claim-text>Procédé selon la revendication 12, dans lequel l'obscurcissement de code, si la série d'opérations comprend des codes d'opérations de programme, comprend en outre l'étape suivante :<br/>
insérer un code leurre dans le programme informatique.</claim-text></claim>
<claim id="c-fr-01-0018" num="0018">
<claim-text>Procédé selon la revendication 17, dans lequel le code leurre fait partie d'un schéma de prédicat opaque.</claim-text></claim>
<claim id="c-fr-01-0019" num="0019">
<claim-text>Procédé selon la revendication 17, dans lequel le code leurre comprend le code original du programme informatique avec un certain nombre de mutations mineures, où, optionnellement, le nombre de mutations mineures est spécifié par l'utilisateur.</claim-text></claim>
<claim id="c-fr-01-0020" num="0020">
<claim-text>Procédé selon la revendication 1, comprenant en outre l'étape suivante :<br/>
chiffrer des connexions entre l'ordinateur de confiance et l'au moins un autre ordinateur.</claim-text></claim>
<claim id="c-fr-01-0021" num="0021">
<claim-text>Procédé selon la revendication 1, comprenant en outre les étapes suivantes :
<claim-text>chiffrer chaque valeur de données de chaque opération de la série d'opérations ;</claim-text>
<claim-text>où le chiffrement de chaque valeur de données de chaque opération est optionnellement réalisé avec un schéma de chiffrement homomorphe additif pour les opérations d'addition et un schéma de chiffrement homomorphe multiplicatif pour les opérations de multiplication ;</claim-text>
<claim-text>où des fonctions de chiffrement de transition sont optionnellement utilisées pour convertir des valeurs de données chiffrées homomorphes additives en valeurs de données chiffrées homomorphes multiplicatives et convertir des valeurs de données chiffrées homomorphes<!-- EPO <DP n="55"> --> multiplicatives en valeurs de données chiffrées homomorphes additives ;</claim-text>
<claim-text>où le procédé comprend optionnellement en outre les étapes suivantes :
<claim-text>diviser une fonction de chiffrement de transition en une série d'opérations ; et</claim-text>
<claim-text>envoyer chaque opération de la fonction de chiffrement de transition avec des instructions d'accompagnement à au moins un autre ordinateur, les instructions d'accompagnement servant à calculer un résultat de l'opération respective et à retransmettre le résultat à un autre ordinateur.</claim-text></claim-text></claim-text></claim>
<claim id="c-fr-01-0022" num="0022">
<claim-text>Procédé selon la revendication 1, comprenant en outre l'étape suivante :<br/>
chiffrer chaque opération de la série d'opérations.</claim-text></claim>
<claim id="c-fr-01-0023" num="0023">
<claim-text>Procédé selon la revendication 1, comprenant en outre les étapes suivantes :<br/>
si, pendant le calcul du résultat d'une opération sur un certain ordinateur, l'opération nécessite une entrée depuis un dispositif connecté à un premier ordinateur de confiance :
<claim-text>générer une demande d'entrée au niveau d'un pilote de programme sur l'ordinateur donné ;</claim-text>
<claim-text>transmettre la demande d'entrée du pilote de programme à un pilote de réseau ;</claim-text>
<claim-text>envoyer la demande d'entrée au premier ordinateur de confiance par l'intermédiaire du pilote de réseau ;</claim-text>
<claim-text>recevoir une réponse du dispositif au niveau du pilote de réseau depuis le premier ordinateur de confiance ; et</claim-text>
<claim-text>transmettre la réponse du pilote de réseau au pilote de programme pour l'utiliser dans le calcul ;</claim-text>
<claim-text>où, optionnellement, la réponse reçue est chiffrée.</claim-text><!-- EPO <DP n="56"> --></claim-text></claim>
<claim id="c-fr-01-0024" num="0024">
<claim-text>Procédé selon la revendication 1, comprenant en outre les étapes suivantes :<br/>
si, pendant le calcul d'un résultat d'une opération sur un certain ordinateur, l'opération nécessite une entrée depuis un dispositif connecté à un premier ordinateur de confiance :
<claim-text>recevoir de l'ordinateur donné, au niveau d'un pilote de réseau sur le premier ordinateur de confiance, une demande d'entrée depuis le dispositif ;</claim-text>
<claim-text>transmettre la demande du pilote de réseau à un pilote d'entrée pour le dispositif ;</claim-text>
<claim-text>transmettre une réponse du dispositif du pilote d'entrée au pilote de réseau ; et</claim-text>
<claim-text>envoyer la réponse à l'ordinateur donné par l'intermédiaire du pilote de réseau ;</claim-text>
<claim-text>où le procédé comprend en outre, optionnellement, de chiffrer la réponse du dispositif avant de transmettre la réponse du pilote d'entrée au pilote de réseau.</claim-text></claim-text></claim>
<claim id="c-fr-01-0025" num="0025">
<claim-text>Procédé selon la revendication 1, comprenant en outre les étapes suivantes :<br/>
si, pendant le calcul du résultat d'une opération sur un certain ordinateur, l'opération nécessite une sortie depuis un dispositif connecté à un premier ordinateur de confiance :
<claim-text>générer une demande de sortie au niveau d'un pilote de programme sur l'ordinateur donné ;</claim-text>
<claim-text>transmettre la demande de sortie du pilote de programme à un pilote de réseau ;</claim-text>
<claim-text>envoyer la demande de sortie au premier ordinateur de confiance par l'intermédiaire du pilote de réseau ;</claim-text>
<claim-text>recevoir un état du dispositif au niveau du pilote de réseau depuis le premier ordinateur de confiance ; et<!-- EPO <DP n="57"> --> transmettre l'état du pilote de réseau au pilote de programme pour l'utiliser dans le calcul ;</claim-text>
<claim-text>où la demande de sortie comprend optionnellement des données chiffrées.</claim-text></claim-text></claim>
<claim id="c-fr-01-0026" num="0026">
<claim-text>Procédé selon la revendication 1, comprenant en outre les étapes suivantes :<br/>
si, pendant le calcul du résultat d'une opération sur un certain ordinateur, l'opération nécessite une sortie d'un dispositif connecté à un premier ordinateur de confiance :
<claim-text>recevoir de l'ordinateur donné, au niveau d'un pilote de réseau sur le premier ordinateur de confiance, une demande de sortie vers le dispositif ;</claim-text>
<claim-text>transmettre la demande du pilote de réseau à un pilote de sortie pour le dispositif ;</claim-text>
<claim-text>transmettre un état du dispositif du pilote de sortie au pilote de réseau ; et</claim-text>
<claim-text>envoyer l'état à l'ordinateur donné par l'intermédiaire du pilote de réseau ;</claim-text>
<claim-text>où la demande comprend optionnellement des données chiffrées ;</claim-text>
<claim-text>et où le procédé comprend en outre, optionnellement, l'étape suivante :<br/>
déchiffrer les données chiffrées avant de transmettre la demande du pilote de réseau au pilote de sortie.</claim-text></claim-text></claim>
<claim id="c-fr-01-0027" num="0027">
<claim-text>Procédé selon la revendication 1, comprenant en outre les étapes suivantes :<br/>
si, pendant le calcul du résultat d'une opération sur un certain ordinateur, l'opération nécessite une entrée depuis un dispositif connecté à un premier ordinateur de confiance :
<claim-text>générer une demande d'entrée au niveau d'un pilote de programme sur l'ordinateur donné ;<!-- EPO <DP n="58"> --></claim-text>
<claim-text>transmettre la demande d'entrée du pilote de programme à un premier pilote de réseau ;</claim-text>
<claim-text>envoyer la demande d'entrée au premier ordinateur de confiance par l'intermédiaire du premier pilote de réseau ;</claim-text>
<claim-text>recevoir de l'ordinateur donné, au niveau d'un second pilote de réseau sur le premier ordinateur de confiance, la demande d'entrée ;</claim-text>
<claim-text>transmettre la demande d'entrée du second pilote de réseau à un pilote d'entrée pour le dispositif ;</claim-text>
<claim-text>transmettre une réponse du dispositif du pilote d'entrée au second pilote de réseau ;</claim-text>
<claim-text>envoyer la réponse à l'ordinateur donné par l'intermédiaire du second pilote de réseau ;</claim-text>
<claim-text>recevoir la réponse du dispositif au niveau du premier pilote de réseau depuis le premier ordinateur de confiance ; et</claim-text>
<claim-text>transmettre la réponse du premier pilote de réseau au pilote de programme pour l'utiliser dans le calcul ;</claim-text>
<claim-text>où le procédé comprend en outre, optionnellement,</claim-text>
<claim-text>l'étape suivante :<br/>
chiffrer la réponse du dispositif avant de transmettre la réponse du pilote d'entrée au second pilote de réseau ; où, optionnellement, la réponse reçue du premier ordinateur de confiance est chiffrée.</claim-text></claim-text></claim>
<claim id="c-fr-01-0028" num="0028">
<claim-text>Procédé selon la revendication 1, comprenant en outre les étapes suivantes :<br/>
si, pendant le calcul du résultat d'une opération sur un certain ordinateur, l'opération nécessite une sortie depuis un dispositif connecté à un premier ordinateur de confiance :
<claim-text>générer une demande de sortie au niveau d'un pilote de programme sur l'ordinateur donné ;<!-- EPO <DP n="59"> --></claim-text>
<claim-text>transmettre la demande de sortie du pilote de programme à un premier pilote de réseau ;</claim-text>
<claim-text>envoyer la demande de sortie au premier ordinateur de confiance par l'intermédiaire du premier pilote de réseau ;</claim-text>
<claim-text>recevoir de l'ordinateur donné, au niveau d'un second pilote de réseau sur le premier ordinateur de confiance, la demande de sortie ;</claim-text>
<claim-text>transmettre la demande de sortie du second pilote de réseau à un pilote de sortie pour le dispositif ;</claim-text>
<claim-text>transmettre un état du dispositif du pilote de sortie au second pilote de réseau ;</claim-text>
<claim-text>envoyer l'état à l'ordinateur donné par l'intermédiaire du deuxième pilote de réseau ;</claim-text>
<claim-text>recevoir l'état au niveau du premier pilote de réseau depuis le premier ordinateur de confiance ; et</claim-text>
<claim-text>transmettre l'état du premier pilote de réseau au pilote de programme pour l'utiliser dans le calcul ;</claim-text>
<claim-text>où la demande de sortie comprend optionnellement des données chiffrées ;</claim-text>
<claim-text>où le procédé comprend en outre optionnellement l'étape suivante :<br/>
déchiffrer les données chiffrées avant de transmettre la demande de sortie du second pilote de réseau au pilote de sortie.</claim-text></claim-text></claim>
<claim id="c-fr-01-0029" num="0029">
<claim-text>Procédé selon la revendication 1, dans lequel l'au moins un autre ordinateur fait partie d'un nuage, dans lequel, optionnellement : le nuage n'est pas fiable, le nuage s'étend sur plusieurs domaines administratifs ; ou le nuage s'étend sur plusieurs infrastructures commercialement distinctes.<!-- EPO <DP n="60"> --></claim-text></claim>
<claim id="c-fr-01-0030" num="0030">
<claim-text>Procédé selon la revendication 1, dans lequel l'au moins un autre ordinateur fait partie d'un réseau d'entreprise.</claim-text></claim>
<claim id="c-fr-01-0031" num="0031">
<claim-text>Procédé selon la revendication 1, dans lequel l'au moins un autre ordinateur est sélectionné de manière aléatoire parmi une pluralité d'ordinateurs, où, optionnellement, chaque ordinateur de la pluralité d'ordinateurs n'est pas fiable.</claim-text></claim>
<claim id="c-fr-01-0032" num="0032">
<claim-text>Procédé selon la revendication 1, dans lequel l'au moins un autre ordinateur n'est pas fiable ou dans lequel l'au moins un autre ordinateur n'est pas l'ordinateur fiable.</claim-text></claim>
<claim id="c-fr-01-0033" num="0033">
<claim-text>Procédé selon la revendication 1, dans lequel l'envoi de chaque opération de la série d'opérations avec des instructions d'accompagnement à l'au moins un autre ordinateur comprend l'envoi de chaque opération à plusieurs ordinateurs pour le calcul.</claim-text></claim>
<claim id="c-fr-01-0034" num="0034">
<claim-text>Système comprenant au moins un ordinateur de confiance et au moins un autre ordinateur, un premier ordinateur de confiance de l'au moins un ordinateur de confiance stockant des instructions informatiques qui, lors de leur exécution, amènent le premier ordinateur de confiance à exécuter le procédé de l'une quelconque des revendications précédentes.</claim-text></claim>
</claims>
<drawings id="draw" lang="en"><!-- EPO <DP n="61"> -->
<figure id="f0001" num="1"><img id="if0001" file="imgf0001.tif" wi="95" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="62"> -->
<figure id="f0002" num="2"><img id="if0002" file="imgf0002.tif" wi="150" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="63"> -->
<figure id="f0003" num="3"><img id="if0003" file="imgf0003.tif" wi="145" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="64"> -->
<figure id="f0004" num="4"><img id="if0004" file="imgf0004.tif" wi="144" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="65"> -->
<figure id="f0005" num="5"><img id="if0005" file="imgf0005.tif" wi="143" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="66"> -->
<figure id="f0006" num="6"><img id="if0006" file="imgf0006.tif" wi="143" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="67"> -->
<figure id="f0007" num="7"><img id="if0007" file="imgf0007.tif" wi="139" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="68"> -->
<figure id="f0008" num="8"><img id="if0008" file="imgf0008.tif" wi="134" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="69"> -->
<figure id="f0009" num="9"><img id="if0009" file="imgf0009.tif" wi="132" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="70"> -->
<figure id="f0010" num="10"><img id="if0010" file="imgf0010.tif" wi="154" he="188" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="71"> -->
<figure id="f0011" num="11"><img id="if0011" file="imgf0011.tif" wi="159" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="72"> -->
<figure id="f0012" num="12"><img id="if0012" file="imgf0012.tif" wi="139" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="73"> -->
<figure id="f0013" num="13"><img id="if0013" file="imgf0013.tif" wi="140" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="74"> -->
<figure id="f0014" num="14"><img id="if0014" file="imgf0014.tif" wi="154" he="224" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="75"> -->
<figure id="f0015" num="15"><img id="if0015" file="imgf0015.tif" wi="154" he="226" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="76"> -->
<figure id="f0016" num="16"><img id="if0016" file="imgf0016.tif" wi="154" he="219" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="77"> -->
<figure id="f0017" num="17"><img id="if0017" file="imgf0017.tif" wi="148" he="233" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="78"> -->
<figure id="f0018" num="18"><img id="if0018" file="imgf0018.tif" wi="152" he="227" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="79"> -->
<figure id="f0019" num="19"><img id="if0019" file="imgf0019.tif" wi="151" he="227" img-content="drawing" img-format="tif"/></figure>
</drawings>
<ep-reference-list id="ref-list">
<heading id="ref-h0001"><b>REFERENCES CITED IN THE DESCRIPTION</b></heading>
<p id="ref-p0001" num=""><i>This list of references cited by the applicant is for the reader's convenience only. It does not form part of the European patent document. Even though great care has been taken in compiling the references, errors or omissions cannot be excluded and the EPO disclaims all liability in this regard.</i></p>
<heading id="ref-h0002"><b>Patent documents cited in the description</b></heading>
<p id="ref-p0002" num="">
<ul id="ref-ul0001" list-style="bullet">
<li><patcit id="ref-pcit0001" dnum="US2012185946A"><document-id><country>US</country><doc-number>2012185946</doc-number><kind>A</kind></document-id></patcit><crossref idref="pcit0001">[0004]</crossref></li>
</ul></p>
</ep-reference-list>
</ep-patent-document>
