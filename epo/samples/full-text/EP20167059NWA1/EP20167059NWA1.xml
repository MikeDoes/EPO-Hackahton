<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE ep-patent-document PUBLIC "-//EPO//EP PATENT DOCUMENT 1.5.1//EN" "ep-patent-document-v1-5-1.dtd">
<!-- This XML data has been generated under the supervision of the European Patent Office -->
<ep-patent-document id="EP20167059A1" file="EP20167059NWA1.xml" lang="en" country="EP" doc-number="3889764" kind="A1" date-publ="20211006" status="n" dtd-version="ep-patent-document-v1-5-1">
<SDOBI lang="en"><B000><eptags><B001EP>ATBECHDEDKESFRGBGRITLILUNLSEMCPTIESILTLVFIROMKCYALTRBGCZEEHUPLSKBAHRIS..MTNORSMESMMAKHTNMD..........</B001EP><B005EP>J</B005EP><B007EP>BDM Ver 2.0.12 (4th of August) -  1100000/0</B007EP></eptags></B000><B100><B110>3889764</B110><B120><B121>EUROPEAN PATENT APPLICATION</B121></B120><B130>A1</B130><B140><date>20211006</date></B140><B190>EP</B190></B100><B200><B210>20167059.3</B210><B220><date>20200331</date></B220><B250>en</B250><B251EP>en</B251EP><B260>en</B260></B200><B400><B405><date>20211006</date><bnum>202140</bnum></B405><B430><date>20211006</date><bnum>202140</bnum></B430></B400><B500><B510EP><classification-ipcr sequence="1"><text>G06F   7/58        20060101AFI20200804BHEP        </text></classification-ipcr></B510EP><B520EP><classifications-cpc><classification-cpc sequence="1"><text>G06F   7/582       20130101 FI20200731BHEP        </text></classification-cpc></classifications-cpc></B520EP><B540><B541>de</B541><B542>PARALLELE ERZEUGUNG EINER ZUFALLSMATRIX</B542><B541>en</B541><B542>PARALLEL GENERATION OF A RANDOM MATRIX</B542><B541>fr</B541><B542>GÉNÉRATION PARALLÈLE D'UNE MATRICE ALÉATOIRE</B542></B540><B590><B598>1</B598></B590></B500><B700><B710><B711><snm>Koninklijke Philips N.V.</snm><iid>101851185</iid><irf>2020P00161EP</irf><adr><str>High Tech Campus 52</str><city>5656 AG Eindhoven</city><ctry>NL</ctry></adr></B711></B710><B720><B721><snm>Garcia Morchon, Oscar</snm><adr><str>c/o Philips International B.V. - Intellectual
Property &amp; Standards High Tech Campus 5</str><city>5656 AE Eindhoven</city><ctry>NL</ctry></adr></B721><B721><snm>Tolhuizen, Ludovicus Marinus Gerardus Maria</snm><adr><str>c/o Philips International B.V. - Intellectual
Property &amp; Standards High Tech Campus 5</str><city>5656 AE Eindhoven</city><ctry>NL</ctry></adr></B721></B720><B740><B741><snm>Philips Intellectual Property &amp; Standards</snm><iid>101808802</iid><adr><str>High Tech Campus 5</str><city>5656 AE Eindhoven</city><ctry>NL</ctry></adr></B741></B740></B700><B800><B840><ctry>AL</ctry><ctry>AT</ctry><ctry>BE</ctry><ctry>BG</ctry><ctry>CH</ctry><ctry>CY</ctry><ctry>CZ</ctry><ctry>DE</ctry><ctry>DK</ctry><ctry>EE</ctry><ctry>ES</ctry><ctry>FI</ctry><ctry>FR</ctry><ctry>GB</ctry><ctry>GR</ctry><ctry>HR</ctry><ctry>HU</ctry><ctry>IE</ctry><ctry>IS</ctry><ctry>IT</ctry><ctry>LI</ctry><ctry>LT</ctry><ctry>LU</ctry><ctry>LV</ctry><ctry>MC</ctry><ctry>MK</ctry><ctry>MT</ctry><ctry>NL</ctry><ctry>NO</ctry><ctry>PL</ctry><ctry>PT</ctry><ctry>RO</ctry><ctry>RS</ctry><ctry>SE</ctry><ctry>SI</ctry><ctry>SK</ctry><ctry>SM</ctry><ctry>TR</ctry></B840><B844EP><B845EP><ctry>BA</ctry></B845EP><B845EP><ctry>ME</ctry></B845EP></B844EP><B848EP><B849EP><ctry>KH</ctry></B849EP><B849EP><ctry>MA</ctry></B849EP><B849EP><ctry>MD</ctry></B849EP><B849EP><ctry>TN</ctry></B849EP></B848EP></B800></SDOBI>
<abstract id="abst" lang="en">
<p id="pa01" num="0001">Some embodiments are directed to a cryptographic generation device for generating a random matrix. A random number initiation function may be executed in parallel for a number of random generating processes to obtain a random number state for each. Parallel random number generating processes together produce at least as many random numbers as elements in the random matrix.
<img id="iaf01" file="imgaf001.tif" wi="165" he="90" img-content="drawing" img-format="tif"/></p>
</abstract>
<description id="desc" lang="en"><!-- EPO <DP n="1"> -->
<heading id="h0001">FIELD OF THE INVENTION</heading>
<p id="p0001" num="0001">The presently disclosed subject matter relates to a cryptographic generation device for generating a random matrix, a cryptographic generation method for generating a random matrix, a computer readable medium</p>
<heading id="h0002">BACKGROUND OF THE INVENTION</heading>
<p id="p0002" num="0002">One way to address problems with key distribution is to use so-called asymmetric cryptography. In asymmetric cryptography, a key pair is used which comprises a public-key and a private-key. For this reason, asymmetric cryptography is also called public-key cryptography.</p>
<p id="p0003" num="0003">The public keys may be disseminated widely, but private keys are typically known only to few parties, e.g., only to its owner. The public key can be used to encrypt messages which can only be decrypted with the private key. In a public key encryption system, any person can encrypt a message using the receiver's public key. The encrypted message can only be decrypted with the receiver's private key. It is computationally impractical to find the private key from its corresponding public key. The public key and private key are referred to as a key pair.</p>
<p id="p0004" num="0004">Known public key encryption systems rely on cryptographic algorithms based on mathematical problems that currently admit no efficient solution. For example, the RSA public-key encryption system relies on the difficulty of integer factorization. Public key encryption based on elliptic curves relies on the difficulty of discrete logarithms.</p>
<p id="p0005" num="0005">Quantum computers pose a significant threat to modern cryptography. The two most widely adopted public key cryptosystems, namely, RSA and Elliptic Curve Cryptography (ECC), will be broken by general purpose quantum computers. Lattice-based cryptography may be used as a quantum-computer resistant alternative. Many lattice-based cryptography systems have been proposed.</p>
<p id="p0006" num="0006">For example, one such lattice-based system is called Round5. Round5 is a submission in the second round of NIST's Post-Quantum Cryptography. A description of Round5 can be found on the NIST page: <u>https://csrc.nist.gov/projects/post-quantum-cryptography/round-2-submissions.</u><!-- EPO <DP n="2"> --> The description document is titled "<nplcit id="ncit0001" npl-type="s"><text>Round5: KEM and PKE based on (Ring) Learning with Rounding", dated Thursday 28th March 2019</text></nplcit>. A description of Round5 can also be found on Cryptology ePrint archive: Report 2018/725, e.g., Version: 20190126:102712. Yet a further description can be found in the article "<nplcit id="ncit0002" npl-type="s"><text>Round5: KEM and PKE based on (Ring) Learning with Rounding Tuesday 18th February, 2020", available at https://round5.org/doc/Round5_Submission022020.pdf.</text></nplcit> These documents are included herein by reference. The latter document will be referred to as 'Round5'.</p>
<p id="p0007" num="0007">Other lattice-based cryptography documents are: <nplcit id="ncit0003" npl-type="s"><text>FrodoKEM, "Frodo-KEM: Learning With Errors Key Encapsulation", dated March 30, 2019</text></nplcit>, a description of which can be found as second round NIST candidates at the NIST page mentioned above, and which is included herein by reference. Descriptions of these are included herein from the NIST second round candidate proposals, as well, and are included herein by reference.</p>
<p id="p0008" num="0008">For example, a second cryptographic device may be configured to use a public key of a first cryptographic device to derive a raw key. The raw key may be used to encapsulate a message, typically, a key seed, or pre-key, which in turn may be used to protect communication between the first and second cryptographic device. A lattice-based system may be set up such that both devices can derive the same raw key, or at least raw keys that are so close that they can nevertheless be used to encapsulate and recover the same key seed. A public-private key scheme may be used to derive an ephemeral symmetric key, which in turn may be used for confidentiality and/or integrity protection.</p>
<p id="p0009" num="0009">Cryptographic schemes based on an unstructured lattice, e.g., Round5 in its unstructured parameter sets R5N1* and FrodoKEM, typically require the generation of a large random matrix. The random matrix may be used to derive a public key from a private key. Although transmission of such a matrix can be avoided by sending a seed instead of the matrix itself, the matrix generation may be an important part of the computation costs. It is desired to further reduce the effort required to generate a random matrix.</p>
<heading id="h0003">SUMMARY OF THE INVENTION</heading>
<p id="p0010" num="0010">A cryptographic generation device is provided for generating a random matrix. To generate the random elements in the matrix, the device has access to two functions: a random number initiation function and a random number generation function. The former takes a seed as input and produces a state of the random number generation function. The former takes a state and computes one or more random numbers. The generated random numbers are also known as pseudo random numbers, as they are generated from a seed.<!-- EPO <DP n="3"> --></p>
<p id="p0011" num="0011">Interestingly, the processor system, e.g., one or more microprocessors, electronic memory and the like, may be arranged to support a number of parallel random number generating processes. In an advantageous arrangement, the matrix elements may be generated by executing in parallel the random number initiation function for each random number generating process once. This reduces the overhead caused by the initiation function.</p>
<p id="p0012" num="0012">In an embodiment, parallel random number generating processes are supported by storing multiple random number states in a single register, e.g., a data vector or vector register. Single Instruction Multiple Data (SIMD) instructions may operate on the data vector(s). The SIMD instructions may be used in the initiation or generation function; when these are executed on the vectors multiple streams of random numbers are generated in parallel. For example, a number of parallel initiation or generation functions may be implemented in a sequence of software instructions arranged to be executed by a processor system, e.g., by a microprocessor or a core of a microprocessor. The sequence of software instructions may comprise multiple vector instructions, e.g., SIMD instructions.</p>
<p id="p0013" num="0013">For example, each parallel random number generating processes may be associated with a part of the matrix which is filled by the process. For example, a part may comprise more elements than a single row or column, e.g., multiple rows or columns.</p>
<p id="p0014" num="0014">The random matrix may be used in a lattice-based cryptographic public-private key protocol, some examples of which are referred to in the background and some examples are described herein. For example, the request to generate a random matrix may be received from another device, which may also supply the seed.</p>
<p id="p0015" num="0015">The generation device is an electronic device, e.g., set-top box, smart-card, computer, etc. It may be a mobile electronic device, e.g., mobile phone. The generation method described herein may be applied in a wide range of practical applications, in particular in lattice-based cryptographic protocols. Such protocols may be used for protected communication between devices. For example, such a protocol may produce a symmetric key K shared between the two devices. The symmetric key may be used to encrypt a message, or to protect integrity of the message, e.g., by computing a message authentication code. For example, an e-mail message may be encrypted by the key <i>K,</i> etc.</p>
<p id="p0016" num="0016">An embodiment of the method may be implemented on a computer as a computer implemented method, or in dedicated hardware, or in a combination of both. Executable code for an embodiment of the method may be stored on a computer program product. Examples of computer program products include memory devices, optical storage devices, integrated circuits, servers, online software, etc. Preferably, the computer program<!-- EPO <DP n="4"> --> product comprises non-transitory program code stored on a computer readable medium for performing an embodiment of the method when said program product is executed on a computer.</p>
<p id="p0017" num="0017">In an embodiment, the computer program comprises computer program code adapted to perform all or part of the steps of an embodiment of the method when the computer program is run on a computer. Preferably, the computer program is embodied on a computer readable medium.</p>
<p id="p0018" num="0018">Another aspect of the presently disclosed subject matter provides a method of making the computer program available for downloading. This aspect is used when the computer program is uploaded into, e.g., Apple's App Store, Google's Play Store, or Microsoft's Windows Store, and when the computer program is available for downloading from such a store.</p>
<heading id="h0004">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p0019" num="0019">Further details, aspects, and embodiments will be described, by way of example, with reference to the drawings. Elements in the figures are illustrated for simplicity and clarity and have not necessarily been drawn to scale. In the Figures, elements which correspond to elements already described may have the same reference numerals. In the drawings,
<ul id="ul0001" list-style="none" compact="compact">
<li><figref idref="f0001">Fig. 1</figref> schematically shows an example of an embodiment of a generation device,</li>
<li><figref idref="f0001">Fig. 2</figref> schematically shows an example of an embodiment of a matrix,</li>
<li><figref idref="f0002">Fig. 3a</figref> schematically shows an example of an embodiment of a vector register,</li>
<li><figref idref="f0002">Fig. 3b</figref> schematically shows an example of an embodiment of multiple vector registers,</li>
<li><figref idref="f0003">Figs. 3c</figref> and <figref idref="f0004">3d</figref> schematically show an example of an embodiment of multiple vector registers,</li>
<li><figref idref="f0005">Fig. 4</figref> schematically shows an example of public-key encryption and of private-key decryption,</li>
<li><figref idref="f0006">Fig. 5</figref> schematically shows an example of generation method for generating a random matrix,</li>
<li><figref idref="f0006">Fig. 6a</figref> schematically shows a computer readable medium having a writable part comprising a computer program according to an embodiment,<!-- EPO <DP n="5"> --></li>
<li><figref idref="f0006">Fig. 6b</figref> schematically shows a representation of a processor system according to an embodiment.</li>
</ul></p>
<heading id="h0005"><u>List of Reference Numerals in figures 1-3b, 6a and 6b:</u></heading>
<p id="p0020" num="0020">
<dl id="dl0001" compact="compact">
<dt>100</dt><dd>a generation device</dd>
<dt>110</dt><dd>an input interface</dd>
<dt>120</dt><dd>a processor system</dd>
<dt>122</dt><dd>a random number initiation function</dd>
<dt>124</dt><dd>a random number generation function</dd>
<dt>130</dt><dd>an output interface</dd>
<dt>200</dt><dd>a matrix</dd>
<dt>261</dt><dd>an element</dd>
<dt>211-232</dt><dd>a row</dd>
<dt>251, 252</dt><dd>a column</dd>
<dt>210, 220, 230</dt><dd>a part</dd>
<dt>300, 320</dt><dd>a vector register</dd>
<dt>310, 330</dt><dd>an instruction</dd>
<dt>301-303</dt><dd>a random number state</dd>
<dt>321-323</dt><dd>a random number state</dd>
<dt>340-342</dt><dd>vector registers</dd>
<dt>301-309</dt><dd>a state word</dd>
<dt>351,352</dt><dd>an instruction</dd>
</dl>
<dl id="dl0002" compact="compact">
<dt>1000</dt><dd>a computer readable medium</dd>
<dt>1010</dt><dd>a writable part</dd>
<dt>1020</dt><dd>a computer program</dd>
<dt>1110</dt><dd>integrated circuit(s)</dd>
<dt>1120</dt><dd>a processing unit</dd>
<dt>1122</dt><dd>a memory</dd>
<dt>1124</dt><dd>a dedicated integrated circuit</dd>
<dt>1126</dt><dd>a communication element</dd>
<dt>1130</dt><dd>an interconnect</dd>
<dt>1140</dt><dd>a processor system</dd>
</dl><!-- EPO <DP n="6"> --></p>
<heading id="h0006">DETAILED DESCRIPTION OF THE EMBODIMENTS</heading>
<p id="p0021" num="0021">While the presently disclosed subject matter is susceptible of embodiment in many different forms, there are shown in the drawings and will herein be described in detail one or more specific embodiments, with the understanding that the present disclosure is to be considered as exemplary of the principles of the presently disclosed subject matter and not intended to limit it to the specific embodiments shown and described. In the following, for the sake of understanding, elements of embodiments are described in operation. However, it will be apparent that the respective elements are arranged to perform the functions being described as performed by them.</p>
<p id="p0022" num="0022">Further, the presently disclosed subject matter is not limited to the embodiments, as feature described herein or recited in mutually different dependent claims may be combined.</p>
<p id="p0023" num="0023"><figref idref="f0001">Fig. 1</figref> schematically shows an example of an embodiment of a generation device 100. Cryptographic generation device 100 is configured for generating a random matrix. Generation device 100 comprises a processor system 120. Generation device 100 may comprise an input interface 110 and/or an output interface 130.</p>
<p id="p0024" num="0024">As will be set out herein, there are a number of cryptographic applications that require the use of an unstructured matrix, typically represented by a random matrix. Generating such a random matrix can be a significant part of the overall computation. For example, the cryptographic application may be a public-private key algorithm, e.g., the encryption of a message m, wherein the message may be a key for sharing, e.g., by encapsulation.</p>
<p id="p0025" num="0025">Typically, a cryptographic application will involve another device, although this is not necessary, e.g., for local encryption of storage, e.g., encryption of a backup storage or the like. The other computer may be, e.g., another generation device, typically configured to generate the same random matrix, e.g., by generating from the same seed.</p>
<p id="p0026" num="0026">Device 100 may communicate with other devices over a computer network. The computer network may be an internet, an intranet, a LAN, a WLAN, etc. The computer network may be the Internet. The computer network may be wholly or partly wired, and/or wholly or partly wireless. For example, the computer network may comprise Ethernet connections. For example, the computer network may comprise wireless connections, such as Wi-Fi, ZigBee, and the like. The devices may comprise a connection interface which is arranged to communicate with other devices as needed. For example, the connection interface may comprise a connector, e.g., a wired connector, e.g., an Ethernet connector, an optical<!-- EPO <DP n="7"> --> connector, etc., or a wireless connector, e.g., an antenna, e.g., a Wi-Fi, 4G or 5G antenna. In device 100, the communication interface may be used to receive digital messages. The digital message may comprise one or more of a public key, a seed, an encapsulated message, etc. The digital messages may be received in electronic form.</p>
<p id="p0027" num="0027">The execution of the generation device and/or generation methods may be implemented in a processor system, e.g., one or more processor circuits, examples of which are shown herein. The figures show some of the functional units that may be functional units of the processor system. For example, the figures may be used as a blueprint of a possible functional organization of the processor system. The processor circuit(s) is not shown separate from the units in the figures. For example, the functional units may be wholly or partially implemented in computer instructions that are stored at device 100, e.g., in an electronic memory of device 100, and are executable by a microprocessor of device 100. In hybrid embodiments, functional units are implemented partially in hardware, e.g., as coprocessors, and partially in software stored and executed on device 100. There may be more or even much more functional units in generation device 100. Generation device 100 may be configured for other tasks, e.g., cryptographic tasks, communication tasks, but also other tasks. <figref idref="f0001">Fig. 1</figref> shows functional units for random number initiation function 122, and a random number generation function 124. Typically, the random number initiation and generation functions are deterministic functions.</p>
<p id="p0028" num="0028"><figref idref="f0001">Fig. 1</figref> shows an input interface 110 which may be configured for receiving a request for the random matrix. The request may be received from another device, e.g., as part of a cryptographic protocol. For example, in lattice-based cryptography typically two communicating device compute in the same lattice represented by the same matrix. In case the lattice is unstructured, a random matrix may be used. For example, the request may comprise a seed from which the random matrix is to be generated, thus ensuring that both devices use the same matrix. The interface may also be an internal interface. For example, the generation device may be configured for a cryptographic algorithm, part of which is the generation of a random matrix; this may thus call the input interface internally to generate a random matrix, when one is needed.</p>
<p id="p0029" num="0029">The matrix is often square, but this is not necessary; many lattice-based algorithms will work with a non-square matrix, even if typically performed with a square matrix. It will be assumed herein that the random matrix is square with the understanding that a skilled person can easily adapt embodiments to a non-square matrix; for example, by partitioning the elements of the non-square matrix in multiple parts.<!-- EPO <DP n="8"> --></p>
<p id="p0030" num="0030"><figref idref="f0001">Fig. 2</figref> schematically shows an example of an embodiment of a matrix 200. Elements of the matrix are denoted as small squares. One of the elements has the reference numeral 261. Matrix 200 will be further discussed below. Matrix 200 may have at least 100, at least 500, at least 1000 rows, etc. Matrix elements may comprise at least one random number; e.g., a random number of at least 8 or 16 bits, etc. A matrix element may comprise multiple random numbers, e.g., coefficients of a polynomial.</p>
<p id="p0031" num="0031">Returning to <figref idref="f0001">Fig. 1</figref>. To fill the random matrix with random numbers, processor system 120 is configured to support random number generating processes. In fact, processor system 120 is arranged to support a number of parallel random number generating processes for generating the elements of the random matrix; the number of parallel random number generating processes is at least 2. For example, in some embodiments, the number may be 4, 8, 16, etc. The parallel random number generating processes may be parallel process supported by multiple cores, may also be supported by vector instructions that operate on multiple data elements in a data vector in parallel. Preferably, such vector instructions may be so-called SIMD instructions, but may also be supported by bit-slicing implementations.</p>
<p id="p0032" num="0032">If needed to distinguish between the two types of parallelism they are referred to as multi-core parallelism or vector parallelism. In embodiments, each type of parallelism may be implemented, e.g., multi-core parallelism, vector parallelism, or multi-core parallelism, in combination with vector parallelism. Note that vector parallelism may be used on a multi-core machine without using the multi-cores, or not all of them, and vice-versa. For example, in an embodiment using multi-core parallelism the number of supported random number generating processes may be equal to the number of supported cores of the processor system.</p>
<p id="p0033" num="0033">For example, in an embodiment using vector parallelism the number of supported random number generating processes may be equal to the number of data elements in a vector that represent a state of a random number generator. For example, in an embodiment using both types of parallelism the number of supported random number generating processes may be equal to the product of the above two numbers.</p>
<p id="p0034" num="0034">To generate random numbers the processor system may be configured with two functions: a random number initiation function 122 and a random number generation function 124.</p>
<p id="p0035" num="0035">A random number initiation function may also be referred to as an absorb function, as it absorbs entropy into a state of the random number generation function. The random number generation function may also be referred to as an expand function, since it<!-- EPO <DP n="9"> --> expands the entropy concentrated in the state into a stream of random numbers. The functions may be a so-called sponge construction. A sponge construction proceeds in two phases: the absorbing phase, e.g., in the random number initiation function, followed by the squeezing phase, e.g. in the random number generation function.</p>
<p id="p0036" num="0036">The random number initiation function and a random number generation function may be implemented as a deterministic random number generating, in particular a so-called, deterministic random bit generating (drbg) function. The function may include a first step to initialize the drbg and a second step to generate pseudorandom data. These functions can be built using a hash function or a block cipher. A random bit generating function, may be configured to generate multiple bits and/or may be called multiple times, to generate a desired number of bits, e.g., to fill a part of the matrix.</p>
<p id="p0037" num="0037">The random number initiation function may be configured to receive a seed and to generate a random number state, e.g., a random number generating function state. The seed may be received from another device, process or software routine; for example, the input interface may be configured for receiving the seed. For example, the seed may be generated by the generation device. For example, entropy may be collected from a true random number generator, from not-entirely deterministic processes running on the generation device, and from other sources. The bit-size of the seed does not need to equal the bit-size of the state. For example, the initiation function may be configured to accept seeds of different size, but to produce a state of a fixed size, e.g. 64 bits; For example, the seed may be hashed into the state.</p>
<p id="p0038" num="0038">The random number generation function may be configured to generate random numbers in conjunction with updating a random number state. For example, this may update the seed to a new seed and produce a new random number. The bit-size of the random number may be the same as the bit-size of matrix element. For example, both a matrix element and a generated random number may be 16 bits. The generated random number may also be smaller. In the latter case multiple random numbers may be generated for an element. For example, the generated random number may be only 1 bit large; to fill a 16-bit matrix element, 16 bits would have to be generated by 16 application of the generation function.</p>
<p id="p0039" num="0039">The random number generation function may be configured to receive the number of random numbers that are needed as an input parameter, or the number of desired random number may be hard coded in the random number generation function. This has the advantage that the random number generation function needs to be called only once for each supported parallel random number generation process.<!-- EPO <DP n="10"> --></p>
<p id="p0040" num="0040">To fill the random matrix with random numbers, the processor system may be configured to initiate the number of supported parallel random number generating processes. In each parallel process a stream of random numbers will be produced. Each stream filling a part of the matrix. For each random number generating process executing in parallel the random number initiation function is called to obtain a random number state for each random number generating process.</p>
<p id="p0041" num="0041">Thus, say, if four parallel processes are supported the initiating function may be called four times in parallel. In an embodiment, this is vector parallelism, though the other mentioned parallelism types are also possible.</p>
<p id="p0042" num="0042">After the initiating, for each random number generating process executing in parallel the random number generation function is called in parallel. The parallel random number generating processes together produce at least as many random numbers as elements in the random matrix. Thus if n parallel processes are supported the initiating function may be called n times, though all of them in parallel. The number of calls to the generating function may vary. For example, a single call for each process may be sufficient, e.g., if the generation function produces a sufficient number of random numbers, e.g., ┌<i>d</i><sup>2</sup>/<i>n</i>┐ of them. If the generation function produces fewer random numbers, then more calls may be used. For example, <i>d</i><sup>2</sup> such calls might be made, if the bit-size of the generation function output and of a matrix element are equal; Due to parallelism this may take about the time of ┌<i>d</i><sup>2</sup>/<i>n</i>┐calls. Thus, the overhead incurred by the random number initiation function is minimized, while the potential for parallelism is maximized.</p>
<p id="p0043" num="0043">In an implementation it is preferred to generate whole rows. For example, the generation function may be configured to produce <i>d</i>┌<i>d</i>/<i>n</i>┐random numbers, that is d<sup>∗</sup>ceil(d/n). An advantage of generating whole rows, is that the random matrix can be generated on the fly, performing the matrix multiplication in place; note that the matrix multiplication may also be vectorized.</p>
<p id="p0044" num="0044">For example, one way of performing the multiplication of matrix A of size <i>d</i> × <i>d</i> with a secret vector of length <i>d</i> is shown below. This assumes that we can perform <i>n</i> = 4 operations in parallel.
<pre listing-type="program-listing">               initialize_4x()
               for (i = 0; i &lt; d ; i+=4){
                  4rows = Generate _4x(d)
                  B[i:i+3] = vector_multiplication_4x(4rows, secret)
               }<!-- EPO <DP n="11"> -->
               for (i=floor(d/4); i &lt; d; i++){
                  row = Generate (d)
                  B[i] = vector_multiplication(row, secret)
               }</pre></p>
<p id="p0045" num="0045">In the above code-example, first the function to generate A in parallel is initialized; in this case using four vector-parallel processes (in this example using initialize_4x); for example, the initialization may generate four states for the four random number generation processes. In the first loop, 4 rows are generated together in parallel (in this example using Generate_4x(d)). Then the function vector_multiplication_4x() is called. The latter function takes those generated four rows (in this example 4rows) and multiplies them with the secret, thus filling 4 positions of the result B. For example, secret may be a vector, or a matrix; typically secret represents a private key.</p>
<p id="p0046" num="0046">The second loop may be added, if d might not be a multiple of 4, so that the last row(s) are done one by one. Alternatively, we can make B a few rows longer and discard the last values, those having index &gt; d.</p>
<p id="p0047" num="0047">Once a sufficient number of random numbers are generated, the random matrix may be assembled. Assembling the random matrix may be done during random number production. The finished random number matrix may be stored at the generation device. The finished random number matrix may be sent over an output interface 130. For example, the random number matrix may be returned to the device or process that requested the random number matrix over the input interface. The matrix may be used internally.</p>
<p id="p0048" num="0048">In an embodiment, the generation device is the second device in a cryptographic protocol. A first device may request the second device to participate and, as part thereof, request a random number matrix. The second device will proceed to generate the random number matrix but may not return the random matrix to the caller; instead the random number matrix is used to compute cryptographic objects in the protocol. For example, in a typical application of the random number matrix, a private key in the form of a vector may be converted into a public key by a multiplication with the random matrix. Note that the latter multiplication is typically a so-called noisy multiplication, in which the multiplication result is not exact. A noisy multiplication may be made from a regular multiplication by explicitly adding noise to the end result, but also implicitly by rounding the<!-- EPO <DP n="12"> --> result. Note that the multiplication is typically in a finite field or ring. For example, rounding may be achieved by mapping the multiplication result to a smaller field or ring.</p>
<p id="p0049" num="0049">In an embodiment, the random matrix elements are elements from a finite field or ring, e.g., the numbers modulo a modulus. In an embodiment, a matrix element may comprise multiple random elements, which may themselves be organized as vectors or polynomials, that can be regarded as elements of a finite field or ring extended with a formal variable, e.g., x, and modulo both a modulus (an integer) and modulo a polynomial.</p>
<p id="p0050" num="0050">Various known schemes for initiating and generation functions are available. In particular, schemes which derive a state from a seed, and which generate a sequence of random numbers by updating the state and deriving a random number. Random numbers that are generated from a seed are also referred to as pseudo random numbers. These functions may be implemented as: absorb(seed) and expand(len). Absorb(seed) taking a seed and absorbing it into an internal context, e.g., the state; expand(len) squeezes the absorbed context to generate len bytes of pseudorandom data. For example, both functions could be based on a hash or symmetric block cipher, etc.</p>
<p id="p0051" num="0051">Efficient choices for the initiation and generation function may be taken from FIPS202. For example, the initiation function may be taken to be one of the family of Keccak functions. The generation function may be an extendable-output function (XOF), e.g., SHAKE128 or SHAKE256.</p>
<p id="p0052" num="0052">Similar functions may be found in NIST Special Publication 800-185, where the cSHAKE scheme is described. cSHAKE is a customizable variant of the SHAKE function, as defined FIPS 202. In SP800-185 several algorithms are mentioned in addition to cSHAKE that may also be used. For example, in an embodiment, TupleHash in SP800-185 is used. TupleHash encodes a sequence of input strings in an unambiguous way, then encodes the requested output length at the end of the string and passes the result into cSHAKE. Since both cSHAKE and TupleHash build on the sponge function, the functions can be divided into an initiation and generation subfunctions.</p>
<p id="p0053" num="0053">TupleHash may be called as TupleHash(X, L, S) where X is a Tuple of n bit strings X[1], ..., X[n] that serve as input. L is the desired output length, and S is an optional customization string. X can include an index or the index can be the customization string. TupleHash encodes this input data in an unambiguous way and passes it to cSHAKE. Thus, it is possible to instead of calling TupleHash() a single time, call it, e.g., 4 times and run all those instances in parallel.<!-- EPO <DP n="13"> --></p>
<p id="p0054" num="0054"><figref idref="f0002">Fig. 3a</figref> schematically shows an example of an embodiment of a vector register. Shown in <figref idref="f0002">Fig. 3a</figref> is a vector register 300. Vector register comprises multiple data elements on which the processor system can act in parallel. In the data elements a random number state may be stored. Shown in figure 300 are random number states 301, 302 and 303. There may be fewer, e.g. two random states, there may be more than 3 random number states, e.g., 4 or 8. Also shown in figure 300 is an instruction 310 which is shown to act simultaneously on each of the states. As the states are typically different to begin with, the instructions will produce different results. The instructions or sequence of instructions may be configured to produce for each state stored in vector register 300 both (at least one) random number and an update of the state. The updated state may be stored in the same register 300; instead a further vector register may be employed to store the new states. Likewise, further vector register(s) may be used to store the generated random values, and/or temporary values.</p>
<p id="p0055" num="0055">Note that using the vector register allows the parallel generation of random values, even if only one core is available. Depending on the vector register type, the number of available processes may be computed by dividing a vector register size, e.g., bit-size by the random number state size, e.g., bit-size. For example, for a 256-bit vector and a 64-bit random number state, 4 parallel processes may be supported. For example, for a 512-bit vector and a 64-bit random number state, 8 parallel processes may be supported.</p>
<p id="p0056" num="0056">For example, the generation device, in particular the processor system may be arranged with Single Instruction Multiple Data (SIMD) instructions operating on data vectors. For example, the data vector may be arranged to store multiple random number states for multiple of the supported parallel random number generating processes.</p>
<p id="p0057" num="0057">In order to create different streams of random numbers the streams may be initiated with different states. For example, the random number initiation function may be configured to generate multiple random number states. Each operation modifying the state works in words of, e.g., 64 bits, thus four states can be modified simultaneously if, e.g., 256-bit vector instructions are available. In the generation of the states, the same seed can be used but each state is personalized with a unique number. For example, a process i may be initiated with a seed s<sub>i</sub> = (<i>s, a<sub>i</sub></i>)<i>.</i> wherein <i>a<sub>i</sub></i> is a unique number. For example, one may take <i>a<sub>i</sub></i> = <i>i.</i> Seed s may be obtained from the input interface. Seed s may be generated at generation device, e.g., from locally generated entropy; Seed s may be received from another cryptographic generation device, e.g., to ensure that both devices generate the same random matrix.<!-- EPO <DP n="14"> --></p>
<p id="p0058" num="0058">For example, one may initiate a first data vector with t copies of seed s, wherein t is the number of parallel process supported by the size of a data vector. A second data vector may be initiated with <i>t</i> values <i>a<sub>i</sub>.</i> Vector instruction may now compute a data vector from the first and second vector that contains states for each of the t processes. If vector instructions on multiple vector registers are not supported, one could instead load a single data vector with the different values <i>a<sub>i</sub>.</i> The value s may be accommodated in the instructions that operates on the data vector. This is possible since s is the same for each process.</p>
<p id="p0059" num="0059">Alternatively, a state may be stored in multiple words. For example, the number of parallel process <i>t</i> supported may be the size of a data vector divided by the size of a word of the state. A state may comprise multiple words. The updating of the state and deriving a new random number therefrom may be defined in a sequence of computations on the words. For example, state may comprise 25 words of each 64 bits. Both the initiation and the generation algorithm operate on the words. This means that these computations can be performed in parallel as well. In this case, the number of words that can be stored and operated in a data vector at the same time may determine the number of parallel processes.</p>
<p id="p0060" num="0060">For example, in an embodiment, the initiating function is configured to arrange a number of random number states in a data vector, comprising loading a corresponding number of different numbers associated with the processes into the states, e.g., indices, salts, nonces, or the like, applying a sequence of instructions to the data vector, wherein the same instructions are applied to the multiple states, the sequence of instructions depending on a seed. After the sequence of instructions finished each state is computed from the seed and the different number. In an embodiment, a state may fit in a single word. For example, one may use a 64 bit wide state. However, in an embodiment, multiple words may be used, e.g., multiple times 64 bits.</p>
<p id="p0061" num="0061">The instruction may have multiple operands, at most one of which is a data vector; nevertheless, one or more of the operands may depend on the seed, e.g., comprise the seed or part thereof, e.g., hard coded in the instructions or loaded from a memory. On the other hand, if instructions may apply to multiple data vectors, then the sequence of instructions may be applied to two data vectors, one with multiple copies of an identical seed, the other as above with multiple different numbers. The same applies to embodiments in which the state comprises multiple words. For example, an operation which is to be performed on a word of the state, two words of the state a word of the state and another<!-- EPO <DP n="15"> --> operand, etc., may be performed a data vector containing that word of multiple states, or on two data vectors each containing that word of multiple states.</p>
<p id="p0062" num="0062">Once a data vector, such as data vector 300 has been initiated, preferably with a different state for each process. For example, data vector 300 may comprise 4 or 8 states, etc., to support 4 or 8 parallel streams of random number generation. For example, random number generation function may be configured to generate multiple random numbers in conjunction with updating multiple random number states in a vector.</p>
<p id="p0063" num="0063">Some embodiments use the so-called AVX instruction set or its successor the AVX2 instruction set. The Advanced Vector Extensions (AVX, also known as Sandy Bridge New Extensions) are extensions to the x86 instruction set architecture for microprocessors from Intel and AMD proposed by Intel in March 2008 and first supported by Intel with the Sandy Bridge processor shipping in Q1 2011. AVX2 expands most integer commands to 256 bits and introduces fused multiply-accumulate (FMA) operations. AVX-512 expands AVX to 512-bit support. The Advanced Vector Extensions 2 (AVX2), are also known as Haswell New Instructions, and are an expansion of the AVX instruction set. They are introduced in Intel's Haswell microarchitecture.</p>
<p id="p0064" num="0064"><figref idref="f0002">Fig. 3b</figref> schematically shows an example of an embodiment of multiple vector registers. Shown in <figref idref="f0002">Fig. 3b</figref> are vector register 300 and 320; there may be multiple registers. Each register is operated by a separate core or microprocessor so that multi-core parallelism is obtained in addition to the vector parallelism that is enabled by the data vectors themselves. Register 320 may be similar to register 310, e.g., also storing state 321-323, though having different values.</p>
<p id="p0065" num="0065">For example, an instruction 310 operates on each of the states stored in data vector 300 while an instruction 330 operates on each of the states stored in data vector 330. Instructions 310 and 330 are executed in parallel on different cores. Instruction 310 operates on each one of the states 301-303 in parallel using vector instructions. Instruction 330 operates on each one of the states 321-323 in parallel using vector instructions. Nevertheless, the instructions operating on register 310 and 330 may be the same, e.g., instruction 310 and 330 may be the same.</p>
<p id="p0066" num="0066">By employing both multi-core parallelism in addition to the vector parallelism, the number of supported processes is multiplied.</p>
<p id="p0067" num="0067"><figref idref="f0003">Figs. 3c</figref> and <figref idref="f0004">3d</figref> schematically show an example of an embodiment of multiple vector registers. Shown in <figref idref="f0003">Fig. 3c</figref> are vectors 340, 341 and 342. In the embodiments illustrated by <figref idref="f0003">Fig. 3c</figref> a random number state comprises multiple words. For example, random<!-- EPO <DP n="16"> --> number state 341 comprises words 301, 304 and 307, and possibly more. A second state for a second random number generation process may comprise words 302, 305 and 308, etc. In this case, a state comprises multiple words.</p>
<p id="p0068" num="0068">To operate on the state, e.g., to initiate them or to generate random numbers and/or update them, an instruction 351 may operate on words 301, 302 and 303. For example, the words 301-303 may be loaded in a data vector 340. The instruction 351 is performed on each of the elements in data vector 340, e.g., on words 301, 302 and on 303 separately. For example, instruction 351 may be a load instruction, a negation instruction and so on.</p>
<p id="p0069" num="0069">Likewise, as shown in <figref idref="f0004">Fig. 3d</figref>, an instruction 352 may operate on two vectors, e.g., vectors 340 and 341. For example, instruction 352 may operate on words 301 and 304; on words 302 and 305; and on 303 and 306. For example, instruction 352 may be an XOR instruction, an ADD instruction, and on.</p>
<p id="p0070" num="0070">Note that not all parts of the states need to be loaded in registers at all time. In fact, most of the states may be stored in memory and only loaded in vector register when vector operations are needed. Note that vector 342 comprises part of the states, but in the parts shown in <figref idref="f0003">Figs. 3c</figref> and <figref idref="f0004">3d</figref> no computations are being performed on it. Those words of the multiple states that are not in a computation may be stored elsewhere too. For example, words 307-309 may be stored in memory instead of in a register.</p>
<p id="p0071" num="0071">For example, the number of parallel supported processes may be the bit-size or word size of the vector divided by the bit-size of word size of the state words. For example, this may be 256 bit/64 bit=4 processes or 4 words /1 word = 4 processes. The states themselves can be arbitrarily large. For example, by using 25 words, a 200 bit state is supported.</p>
<p id="p0072" num="0072">Returning to <figref idref="f0001">Fig. 2</figref> showing matrix 200. Matrix 200 may be a square matrix, e.g., of dimension <i>d</i> by <i>d</i>, e.g., having <i>d</i><sup>2</sup> elements. The elements are depicted as small squares, one of which has reference number 261. The matrix has rows, e.g., <i>d</i> rows. Shown are 211, 212, 221, 222, 231 and 232. Typically, there are many more rows than shown. Likewise, the matrix can be thought as organized in columns, shown are columns 251 and 252.</p>
<p id="p0073" num="0073">In an embodiment, the matrix is portioned into parts. In an embodiment, the matrix is divided into as many parts as the number of supported parallel random number generating processes. This means that each part may be filled with random numbers in parallel by the random number generating processes executing in parallel. For example, for each part the initiation function may be called once and the generation function as often as is<!-- EPO <DP n="17"> --> needed to fill the part. For example, the multiple supported processes may be associated with the multiple parts of the matrix.</p>
<p id="p0074" num="0074">In an embodiment, the parts may be selected at random. For example, if the processor system supports <i>t</i> parallel processes, one may select <i>t</i> parts of each <i>d</i><sup>2</sup>/<i>t</i> matrix elements; note it may happen that <i>d</i><sup>2</sup> is not exactly divisible by <i>t</i>, in which case, e.g., some parts may be 1 larger than other parts. The parts may be made up of rows and/or columns. For example, to obtain <i>t</i> parts one may divide the number of rows by <i>t.</i> For example, in <figref idref="f0001">Fig. 2</figref>, part 210 comprises multiple rows, shown are rows 211 and 212. Likewise, part 220 comprises at least rows 221 and 222 and part 230 comprises at least rows 231 and 232. If the parts are equal in size or approximately equal in size, then the generation of their random number gains more from the parallelism.</p>
<p id="p0075" num="0075">In an embodiment, a part comprises consecutive rows of the random matrix and/or alternate rows.</p>
<p id="p0076" num="0076">In a first exemplary embodiment, a data vector has bit-size <i>b</i> = 256 and the state for a random generation stream is modified in words of bit-size 64, so that the number of supported processes may be <i>t</i> = 256/64 = 4. For example, one may call the initiation function, e.g., the absorb function, <i>t</i> = 4 times, but in parallel so that 4 states are initialized at the same time. The generation function, e.g., the expand function, may be called as often as necessary, running with <i>t</i> = 4 functions in parallel.</p>
<p id="p0077" num="0077">In a second exemplary embodiment, a data vector has bit-size <i>b</i> = 256 and the state for a random generation stream is modified in words of bit-size 64, and <i>c</i> &gt; 1 cores are available, so that the number of supported processes may be <i>t</i> = <i>c·</i>256/64 = 4<i>c</i>. For example, one may call the initiation function, e.g., the absorb function, <i>t</i> = 4c times, but in parallel. The generation function, e.g., the expand function, may be called as often as necessary, running with <i>t</i> = 4<i>c</i> functions in parallel.</p>
<p id="p0078" num="0078">In both examples, the random number generation function may be called only once for each process; for example, if the random number generation function is configured to produce as many random numbers as needed, e.g., as needed fill a part, e.g., the part associated with the process.</p>
<p id="p0079" num="0079">For example, assume that a matrix A is stored in memory as an array of length d^2. Then matrix A may be filled with the following two function calls:
<ul id="ul0002" list-style="none" compact="compact">
<li>context_4 = absorb_4(seed, personalization_tag=0, personalization_tag=1, personalization _tag=2, personalization_tag=3);<!-- EPO <DP n="18"> --></li>
<li>expand_4(context_4, &amp;A[0], &amp;A[d<sup>∗</sup>ceil(d/4)], &amp;A[d<sup>∗</sup>2<sup>∗</sup>ceil(d/4)], &amp;A[d<sup>∗</sup>3<sup>∗</sup>ceil(d/4)], d<sup>∗</sup>ceil(d/4));</li>
</ul></p>
<p id="p0080" num="0080">The function absorb_4() takes seed and personalization_tags for each of the four parallel random number generation instances, e.g., (c)SHAKE instances, to obtain context 4. The personalization_tag may be unique numbers so that the random streams will be different. They can be salts, nonces, or indices, etc. Context_4 is a data structure that keeps 4 (c)SHAKE contexts in parallel. Each context might be bigger than 64 bits, but it is modified with 64-bit instructions. Thus, it is possible to modify 4 states simultaneously by means of 256-bit instructions. Expand_4() is a function that takes context_4 and generates 4 times d<sup>∗</sup>ceil(d/4) elements in parallel, placing them in four parts of A. The above does not assume that <i>d</i> <sup>∗</sup> <i>d</i> is divisible by 4, which is not necessary. Note that, if <i>d</i> is not a multiple of 4, then some additional rows may be filled with random numbers, that might not be used in a matrix multiplication. This may be resolved by making the parts of different sizes, e.g., some parts having an additional element. It may also be resolved by having all parts the same size, but having the part slightly overlapping, e.g., by 1 element. The latter may have the result that some matrix elements are written to twice.</p>
<p id="p0081" num="0081">Compared with some alternative ways to generate a random matrix these embodiments show an advantage.</p>
<p id="p0082" num="0082">For example, in a first comparative example, the initiation function is called only once and the expand function is called as often as needed. The first comparative example has the advantage that the initiation function is called less often but has the considerable disadvantage that nothing is gained from parallelism. Accordingly, this option is considerably slower.</p>
<p id="p0083" num="0083">For example, in second comparative example, a separate process to generate random number is started for each row of the matrix. For each process, an initiation and (at least one) expand function should be called. However, the number of rows in the matrix is considerably larger that the number of supported parallel processes. For example, if <i>t</i> = 4 parallel processes are supported, but the number of rows is larger than t, then the rows can be generated in sets <i>of t</i> rows at a time. If the number of rows is <i>t ·</i> s, then the initiation function would be called <i>t · s</i> times, in s sets of <i>t</i> parallel calls, taking s times the time of a single initiation call. Accordingly, overhead would be incurred on the initiation calls. This example divides the matrix in more blocks than can be filled in parallel, which causes too many calls to initiation.<!-- EPO <DP n="19"> --></p>
<p id="p0084" num="0084">Performance is analyzed for Round5 parameter set R5N1_5CPA_0d, taken from the Round5 specification in "<nplcit id="ncit0004" npl-type="s"><text>Round5: KEM and PKE based on (Ring) Learning with Rounding Tuesday 18th February 2020", page 56</text></nplcit>. In this parameter set, d = 1186, <i>n</i> = 1, <i>q</i> = 2<sup>15</sup>; thus, a square matrix with <i>d</i> ∗ <i>d</i> random elements is generated. Each element of the matrix is represented as two random bytes.</p>
<p id="p0085" num="0085">For this parameter set, an improvement is obtained from 37906 KCPU cycles (no parallelization, first comparative example above) to 12348 KCPU cycles (using AVX2 instructions on a single core). The second comparative example takes 13272 cycles, so the embodiment is still 7% faster. Note that the 7% improvement is obtained with little additional complexity.</p>
<p id="p0086" num="0086">There are numerous cryptographic protocols in which a random matrix is used. For example, in an embodiment the generation device is configured for a cryptographic public-private key protocol. The processor system may be configured to generate a private-key and to compute a public-key therefrom by applying a noisy multiplication between the generated random matrix and the private-key. The public key may be distributed to another device, e.g., together with a seed from which the random matrix was generated.</p>
<p id="p0087" num="0087">For example, a raw shared key may be derived by multiplying a received public-key received from another generation device and a private-key generated by this device. The other side can do the same with its private key and a public key obtained from this device. Because of the noise multiplication, the two raw shared keys will be approximately equal. There are various ways to exploit this mechanism, one of which is shown with respect to <figref idref="f0005">Fig. 4</figref>.</p>
<p id="p0088" num="0088"><figref idref="f0005">Fig. 4</figref> schematically shows an example of public-key encryption and of private-key decryption. The public-key encryption side is performed by second cryptographic device 20. The private-key decryption side is performed by first cryptographic device 10. The protocol of <figref idref="f0005">Fig. 4</figref> may be executed by two generation devices as described herein. The notation in <figref idref="f0005">Fig. 4</figref> is as follows:
<ul id="ul0003" list-style="bullet" compact="compact">
<li>A represents a random matrix, e.g., a matrix with elements in the integers or a ring, field, etc. The elements may be integers modulo a modulus, e.g., a power of 2.</li>
<li>The elements of the public matrix may be integers modulo a modulus, e.g., a power of 2. The elements of the public matrix may be polynomials modulo a modulus, e.g., a power of 2 and a polynomial. A public matrix A is typically a square d × d matrix. Matrices modulo a<!-- EPO <DP n="20"> --> modulus are referred to as a non-ring configuration. Matrices with polynomial entries modulo a polynomial and a modulus are referred to as a module configuration. The public matrix A is a random matrix. It is called a public matrix since the security of the system does not require the matrix to be private.</li>
<li><b><i>σ</i></b> represents a seed for generation the random matrix A.</li>
<li><b>S</b> and <b>R</b> represent the private keys of the first cryptographic device and the second cryptographic device, respectively. Like the public matrix, a private key may be a matrix.</li>
<li><b>B</b> and <b>U</b> represent the public key matrices of the first cryptographic device and the second cryptographic device illustrated as the product of <b>A*R</b> or <b>A*S</b>. Like the public matrix, the public keys may be a matrix.</li>
</ul></p>
<p id="p0089" num="0089">The operation * represents the one-way function of the underlying problem. The star (*) operation derives a new mathematical object, e.g., a new matrix, from two underlying matrices, while introducing some noise, e.g., a new polynomial, from two underlying polynomials, while introducing some noise. For example, noise may be introduced explicitly by adding noise to the elements, or implicitly, e.g., by rounding.</p>
<p id="p0090" num="0090">Examples of star operations can be found in (R)LWE or (R)LWR or a module version of them. For instance, A<sup>∗</sup>R may mean Round((AR (mod q)), p, q), e.g., as in LWR. This means the product of R times the square matrix A modulo q. Then the result is rounded with integers p and q where p&lt;q by performing p/q (A<sup>∗</sup>R (mod q). A rounding operating may be an operator <maths id="math0001" num=""><math display="inline"><mrow><msub><mi>R</mi><mrow><mi>a</mi><mo>→</mo><mi>b</mi><mo>,</mo><mi>h</mi></mrow></msub><mfenced><mi>x</mi></mfenced><mrow><mo>=</mo></mrow><mrow><mrow><msub><mrow><mo>〈</mo><mrow><mo>⌊</mo><mfrac><mi>b</mi><mi>a</mi></mfrac><mfenced separators=""><mi>x</mi><mo>+</mo><mi>h</mi></mfenced><mo>⌋</mo></mrow><mo>〉</mo></mrow><mi>b</mi></msub></mrow></mrow><mn>.</mn></mrow></math><img id="ib0001" file="imgb0001.tif" wi="49" he="10" img-content="math" img-format="tif" inline="yes"/></maths> In the latter formula, the angle brackets denote a modulo operation, in this case modulo b. The floor operation, in this case is downward flooring, but this could be replaced to a ceiling or true rounding operation. The value <i>h</i> may be used, e.g., to reduce bias. For example, one may use <i>h</i> = <i>a</i>/<i>2b.</i> Typically, we have that <i>b &lt; a.</i> In an embodiment, both <i>a</i> and <i>b</i> are powers of 2.
<ul id="ul0004" list-style="bullet" compact="compact">
<li><b><i>m</i></b> is called the message; in this example protocol it is used to as a key seed.</li>
<li><b><i>k</i></b> is the raw key, or noisy key. It is approximately equal for the two devices.</li>
<li><b>v</b> represents the encapsulated message <i>m</i><!-- EPO <DP n="21"> --></li>
<li><b>encapsulate(k, m)</b> means that the message <i>m</i> is encapsulated with k. For example, if k lives in Z_q, then m may be represented in Z_q too. If k lives in Z_2, then this may be an XOR. Encapsulation may be done elementwise, e.g., interpreting the k and m as a matrix as: <maths id="math0002" num=""><math display="block"><mrow><mi mathvariant="normal">v</mi><mo>=</mo><mi mathvariant="normal">k</mi><mo>+</mo><mi mathvariant="normal">m</mi><mo>*</mo><mfenced separators=""><mi mathvariant="normal">q</mi><mo>/</mo><mn mathvariant="normal">2</mn></mfenced><mfenced><mi mathvariant="normal">mod q</mi></mfenced><mn mathvariant="normal">.</mn></mrow></math><img id="ib0002" file="imgb0002.tif" wi="43" he="6" img-content="math" img-format="tif"/></maths></li>
</ul></p>
<p id="p0091" num="0091">For example, an encapsulation function may mask message m using a key k such that an error in k has a limited effect on m, e.g., a linear effect.
<ul id="ul0005" list-style="bullet" compact="compact">
<li><b><i>H</i></b>() is a key derivation function, e.g., a hash function</li>
<li><b>decapsulate(k'</b>, <b>v)</b> means that the ciphertext c is decapsulated using key k' returning a bit string <i>m</i>.</li>
</ul></p>
<p id="p0092" num="0092">Reference is made to:
<ul id="ul0006" list-style="none" compact="compact">
<li>RLWE: "On Ideal Lattices and Learning with Errors Over Rings", by Vadim Lyubashevsky, Chris Peikert, and Oded Regev,</li>
<li>RLWR: "Pseudorandom Functions and Lattices", by Abhishek Banerjee, Chris Peikert, and Alon Rosen,</li>
<li>LWE: "On Lattices, Learning with Errors, Random Linear Codes, and Cryptography", by Oded Regev.</li>
<li>LWR: "Pseudorandom Functions and Lattices", by Abhishek Banerjee, Chris Peikert, and Alon Rosen,</li>
<li>Hila5: "HILA5: On Reliability, Reconciliation, and Error Correction for Ring-LWE Encryption", by Markku-Juhani O. Saarinen</li>
</ul></p>
<p id="p0093" num="0093">The star operation may be a noisy matrix multiplication, e.g., a regular matrix multiplication followed by adding noise, e.g., a regular polynomial multiplication followed by adding noise. Adding noise may also be integrated with the multiplication. Adding noise in the star operation may be done in multiple ways. One example of adding noise, is by adding explicit noise, e.g., by generating and adding a noise matrix or polynomial. An advantage of adding explicit noise is that the noise is under complete control of the cryptographer, and can be fine-tuned, e.g., to obtain precise control over the failure rate of the system versus its security. Furthermore, adding explicit noise has the advantage that all matrices or polynomials may be over the same ring, or field, etc., thus simplifying analysis.<!-- EPO <DP n="22"> --></p>
<p id="p0094" num="0094">Another example of adding noise is scaling down. For example, the matrices A, R, and S may have elements modulo a modulus q, e.g., integers or polynomials modulo q; the star operation may round the result of a matrix operation down from modulo q to modulo p, e.g., by multiplying with p/q and rounding, e.g., rounding up, or rounding down, or rounding to the nearest integer, etc.</p>
<p id="p0095" num="0095">In this application small letters will be used for matrices, with the understanding that matrices may need to be transposed whenever needed, e.g., as required by the dimensions of the matrices, and by the requirement that the raw key at both sides should be approximately equal. Typically, there is more than one way to do this; for example, by transposing all matrices in an embodiment, an alternative working embodiment may be obtained.</p>
<p id="p0096" num="0096">Returning to <figref idref="f0005">Fig. 4</figref>. Shown are an enrollment phase 31 in which the first cryptographic device 10 generates its private and public key matrices, and makes the public key and seed available to the public key encryption device 20. For example, the public key may be sent to device 20. For example, the public key may be deposited in a public-key database, from which device 20 may retrieve it. For example, devices 10 and 20 may be different devices, or may be the same device.</p>
<p id="p0097" num="0097">Generating the seed σ may be done randomly. Device 20 is configured to compute a second raw shared key (k) from the second private-key matrix (S) and the first public-key matrix (B), computing the second raw shared key comprising a matrix multiplication between the second private-key matrix (S) and the first public-key matrix (B), encapsulate the message m with at least part of the second raw shared key by applying an encapsulation function, obtaining encapsulated data (v), and transfer the second public-key matrix (U), and the encapsulated data (v) to the first cryptographic device. For example, the second public-key matrix (U), and the encapsulated data (v) to the first cryptographic device may be sent in a message 12.</p>
<p id="p0098" num="0098">After the first cryptographic device receives from the second cryptographic device the second public-key matrix (U) and the encapsulated data (v), the first cryptographic device can proceed in a decryption phase 33 to compute a first raw shared key (k') from the second public-key matrix (U) and the first private-key matrix (S), compute the first raw shared key comprising a matrix multiplication between the second public-key matrix (U) and the first private-key matrix (S), and decapsulate the encapsulated data (v) using at least part of the first raw shared key (<i>k'</i>) to obtain message <i>m</i>. First cryptographic device 10 may<!-- EPO <DP n="23"> --> compute the key <i>K</i> from the message <i>K</i> = <i>H</i>(<i>m</i>) using the same key derivation function as the second device 20.</p>
<p id="p0099" num="0099">In an embodiment, the public matrix A is a square matrix of dimensions d × d. The first private-key matrix R and first public-key matrix B have dimensions <i>d</i> × <i><o ostyle="single">n</o>.</i> The second private-key matrix S and second public-key matrix u have dimensions d × <i><o ostyle="single">m</o></i>. For example, one may use <i><o ostyle="single">m</o></i> = <i><o ostyle="single">n</o>,</i> but this is not needed. Interestingly, the security of the system is believed to depend more on the system dimension d and on the product <i>B<o ostyle="single">nm</o></i> than on the individual sizes of <i><o ostyle="single">n</o></i> and <i><o ostyle="single">m</o></i> (in this equation the letter <i>B</i> denotes the number of bits taken from the elements of the raw key, not the public key B). The product <i>B<o ostyle="single">nm</o></i> indicates the length in bits that can be used to derive the raw key. The former influences the size of the underlying lattice and thus the hardness of the underlying cryptographic problem. The probability of decryption failure of the scheme depends in part on the value of <i>B</i>. Higher values of <i>B</i> worsen the failure rate and adversely affect the security of the PKE scheme against adaptive active attacks. Typically, <i>B</i> is fixed, e.g., in the form of standardized parameter sets.</p>
<p id="p0100" num="0100">Interestingly, the second dimension (<i><o ostyle="single">m</o></i>) of the second public-key matrix (u) need not be pre-determined. It can be chosen independent of the choices made for the first private and public-key. In particular, it may be chosen independent on the dimension (<i><o ostyle="single">n</o></i>). In an embodiment, the second dimension (<i><o ostyle="single">m</o></i>) is configurable at the second device 20. In Round5 many examples of matrix or polynomial dimensions are given. For example, one may use the following for a smaller configuration that given elsewhere herein:
<tables id="tabl0001" num="0001">
<table frame="all">
<tgroup cols="2">
<colspec colnum="1" colname="col1" colwidth="83mm"/>
<colspec colnum="2" colname="col2" colwidth="83mm"/>
<thead>
<row>
<entry namest="col1" nameend="col2" align="left" valign="top">Small ciphertext configuration</entry></row></thead>
<tbody>
<row>
<entry>d, n</entry>
<entry>757, 1</entry></row>
<row>
<entry>q, p, t</entry>
<entry>2<sup>14</sup>, 2<sup>9</sup>, 2<sup>4</sup></entry></row>
<row>
<entry>B, <i><o ostyle="single">n</o></i>, <i><o ostyle="single">m</o></i></entry>
<entry>1, 192, 1</entry></row>
<row>
<entry><i>µ</i></entry>
<entry>192</entry></row></tbody></tgroup>
<tgroup cols="2" rowsep="0">
<colspec colnum="1" colname="col1" colwidth="83mm"/>
<colspec colnum="2" colname="col2" colwidth="83mm"/>
<tbody>
<row>
<entry namest="col1" nameend="col2" align="justify">In the above table:<br/>
<i>n</i>: indicates the degree of polynomials in the private and/or public matrices. A value of <i>n</i> = 1 indicates that integers modulo a modulus are used. The value <i>n</i> may be referred to as the "ring dimension", e.g., the degree of the chosen polynomial ring.<br/>
<!-- EPO <DP n="24"> -->d indicates the system dimension, e.g., number of columns and rows the public matrix a,<br/>
<i>µ</i> indicates the number of elements of the raw key matrix that are used to encapsulate the key seed. These elements may be pre-determined, e.g., standardized, or may be randomly selected, or may be purposely, e.g., as reliable elements, etc. The shared-secret key length is thus <i>µB</i> ; in the above example this is 192 × 1 = 192 .</entry></row></tbody></tgroup>
</table>
</tables></p>
<p id="p0101" num="0101">In an embodiment, active security may be further enhanced using a more elaborate encapsulate function, e.g., as in algorithm 9, in "<nplcit id="ncit0005" npl-type="s"><text>Round2: KEM and PKE based on GLWR", by Hayo Baan</text></nplcit>, et al.</p>
<p id="p0102" num="0102">Key K is typically used temporarily, e.g., it may be ephemeral, e.g., used only to encrypt a single message, or a single session, protocol, handshake or the like. Key K may be a symmetric key, e.g., used as a key in a block cipher.</p>
<p id="p0103" num="0103">In the various embodiments of generation devices, including cryptographic device such as in <figref idref="f0005">Fig. 4</figref>, a communication interface may be selected from various alternatives. For example, the interface may be a network interface to a local or wide area network, e.g., the Internet, a storage interface to an internal or external data storage, an application interface (API), etc. The device may have a user interface, which may include well-known elements such as one or more buttons, a keyboard, display, touch screen, etc. The user interface may be arranged for accommodating user interaction for performing matrix generation, public or private key generation, execution of a cryptographic protocol and so on. The device may comprise a storage 110 which may be as an electronic memory, say a flash memory, or magnetic memory, say hard disk or the like, or optical memory, e.g., a DVD. Storage may comprise multiple discrete memories together making up storage. Storage may comprise a temporary memory, say a RAM.</p>
<p id="p0104" num="0104">Typically, the devices comprise a microprocessor which executes appropriate software stored at the device; for example, that software may have been downloaded and/or stored in a corresponding memory, e.g., a volatile memory such as RAM or a non-volatile memory such as Flash. Alternatively, the devices may, in whole or in part, be implemented in programmable logic, e.g., as field-programmable gate array (FPGA). The devices may be implemented, in whole or in part, as a so-called application-specific integrated circuit (ASIC), e.g., an integrated circuit (IC) customized for their particular use. For example, the circuits may be implemented in CMOS, e.g., using a hardware description language such as Verilog, VHDL, etc.<!-- EPO <DP n="25"> --></p>
<p id="p0105" num="0105">In an embodiment, a generation device comprises a random number initiation circuit, and a random number generation circuit; other functions may also be implemented as a circuit. The circuits may be a processor circuit and storage circuit, the processor circuit executing instructions represented electronically in the storage circuits.</p>
<p id="p0106" num="0106">A processor circuit may be implemented in a distributed fashion, e.g., as multiple sub-processor circuits. A storage may be distributed over multiple distributed sub-storages. Part or all of the memory may be an electronic memory, magnetic memory, etc. For example, the storage may have volatile and a non-volatile part. Part of the storage may be read-only. The circuits may also be, FPGA, ASIC or the like.</p>
<p id="p0107" num="0107"><figref idref="f0006">Fig. 5</figref> schematically shows an example of generation method 500 for generating a random matrix. The method may computer implemented. Method may comprise
<ul id="ul0007" list-style="dash" compact="compact">
<li>receiving (510) a request for the random matrix,</li>
<li>initiating (520) a number of supported parallel random number generating processes in a processor system arranged to support a number of parallel random number generating processes for generating the elements of the random matrix,</li>
<li>for each random number generating process executing (530) in parallel a random number initiation function obtaining for each random number generating process a random number state, the random number initiation function being configured to receive a seed and to generate a random number state,</li>
<li>for each random number generating process executing (540) in parallel a random number generation function, wherein the parallel random number generating processes together produce at least as many random numbers as elements in the random matrix, the random number generation function configured to generate random numbers in conjunction with updating a random number state,</li>
<li>assembling (550) the random matrix.</li>
</ul></p>
<p id="p0108" num="0108">Many different ways of executing the method are possible, as will be apparent to a person skilled in the art. For example, the steps can be performed in the shown order, but the order of the steps may also be varied, or some steps may be executed in parallel. Moreover, in between steps other method steps may be inserted. The inserted steps may represent refinements of the method such as described herein, or may be unrelated to the method.</p>
<p id="p0109" num="0109">Embodiments of the method may be executed using software, which comprises instructions for causing a processor system to perform method 500. Software may<!-- EPO <DP n="26"> --> only include those steps taken by a particular sub-entity of the system. The software may be stored in a suitable storage medium, such as a hard disk, a floppy, a memory, an optical disc, etc. The software may be sent as a signal along a wire, or wireless, or using a data network, e.g., the Internet. The software may be made available for download and/or for remote usage on a server. Embodiments of the method may be executed using a bitstream arranged to configure programmable logic, e.g., a field-programmable gate array (FPGA), to perform the method.</p>
<p id="p0110" num="0110">It will be appreciated that the presently disclosed subject matter also extends to computer programs, particularly computer programs on or in a carrier, adapted for putting the presently disclosed subject matter into practice. The program may be in the form of source code, object code, a code intermediate source, and object code such as partially compiled form, or in any other form suitable for use in the implementation of an embodiment of the method. An embodiment relating to a computer program product comprises computer executable instructions corresponding to each of the processing steps of at least one of the methods set forth. These instructions may be subdivided into subroutines and/or be stored in one or more files that may be linked statically or dynamically. Another embodiment relating to a computer program product comprises computer executable instructions corresponding to each of the devices, units and/or parts of at least one of the systems and/or products set forth.</p>
<p id="p0111" num="0111"><figref idref="f0006">Fig. 6a</figref> shows a computer readable medium 1000 having a writable part 1010 comprising a computer program 1020, the computer program 1020 comprising instructions for causing a processor system to perform a matrix generation method, according to an embodiment. The computer program 1020 may be embodied on the computer readable medium 1000 as physical marks or by magnetization of the computer readable medium 1000. However, any other suitable embodiment is conceivable as well. Furthermore, it will be appreciated that, although the computer readable medium 1000 is shown here as an optical disc, the computer readable medium 1000 may be any suitable computer readable medium, such as a hard disk, solid state memory, flash memory, etc., and may be non-recordable or recordable. The computer program 1020 comprises instructions for causing a processor system to perform said matrix generation method.</p>
<p id="p0112" num="0112"><figref idref="f0006">Fig. 6b</figref> shows in a schematic representation of a processor system 1140 according to an embodiment of a generation device, cryptographic device, etc. as in an embodiment. The processor system comprises one or more integrated circuits 1110. The architecture of the one or more integrated circuits 1110 is schematically shown in Fig. 7b. Circuit 1110 comprises a processing unit 1120, e.g., a CPU, for running computer program<!-- EPO <DP n="27"> --> components to execute a method according to an embodiment and/or implement its modules or units. Circuit 1110 comprises a memory 1122 for storing programming code, data, etc. Part of memory 1122 may be read-only. Circuit 1110 may comprise a communication element 1126, e.g., an antenna, connectors or both, and the like. Circuit 1110 may comprise a dedicated integrated circuit 1124 for performing part or all of the processing defined in the method. Processor 1120, memory 1122, dedicated IC 1124 and communication element 1126 may be connected to each other via an interconnect 1130, say a bus. The processor system 1110 may be arranged for contact and/or contact-less communication, using an antenna and/or connectors, respectively.</p>
<p id="p0113" num="0113">For example, in an embodiment, processor system 1140, e.g., the generation device may comprise a processor circuit and a memory circuit, the processor being arranged to execute software stored in the memory circuit. For example, the processor circuit may be an Intel Core i7 processor, ARM Cortex-R8, etc. In an embodiment, the processor circuit may be ARM Cortex M0. The memory circuit may be an ROM circuit, or a non-volatile memory, e.g., a flash memory. The memory circuit may be a volatile memory, e.g., an SRAM memory. In the latter case, the device may comprise a non-volatile software interface, e.g., a hard drive, a network interface, etc., arranged for providing the software.</p>
<p id="p0114" num="0114">As used herein, the term "non-transitory" will be understood to exclude transitory signals but to include all forms of storage, including both volatile and non-volatile memories.</p>
<p id="p0115" num="0115">While device 1100 is shown as including one of each described component, the various components may be duplicated in various embodiments. For example, the processor 1120 may include multiple microprocessors that are configured to independently execute the methods described herein or are configured to perform steps or subroutines of the methods described herein such that the multiple processors cooperate to achieve the functionality described herein. Further, where the device 1100 is implemented in a cloud computing system, the various hardware components may belong to separate physical systems. For example, the processor 1120 may include a first processor in a first server and a second processor in a second server.</p>
<p id="p0116" num="0116">It should be noted that the above-mentioned embodiments illustrate rather than limit the presently disclosed subject matter, and that those skilled in the art will be able to design many alternative embodiments.</p>
<p id="p0117" num="0117">In the claims, any reference signs placed between parentheses shall not be construed as limiting the claim. Use of the verb 'comprise' and its conjugations does not<!-- EPO <DP n="28"> --> exclude the presence of elements or steps other than those stated in a claim. The article 'a' or 'an' preceding an element does not exclude the presence of a plurality of such elements. Expressions such as "at least one of' when preceding a list of elements represent a selection of all or of any subset of elements from the list. For example, the expression, "at least one of A, B, and C" should be understood as including only A, only B, only C, both A and B, both A and C, both B and C, or all of A, B, and C. The presently disclosed subject matter may be implemented by hardware comprising several distinct elements, and by a suitably programmed computer. In the device claim enumerating several parts, several of these parts may be embodied by one and the same item of hardware. The mere fact that certain measures are recited in mutually different dependent claims does not indicate that a combination of these measures cannot be used to advantage.</p>
<p id="p0118" num="0118">In the claims references in parentheses refer to reference signs in drawings of exemplifying embodiments or to formulas of embodiments, thus increasing the intelligibility of the claim. These references shall not be construed as limiting the claim.</p>
</description>
<claims id="claims01" lang="en"><!-- EPO <DP n="29"> -->
<claim id="c-en-0001" num="0001">
<claim-text>A cryptographic generation device for generating a random matrix, the device comprising
<claim-text>- an input interface configured for receiving a request for the random matrix,</claim-text>
<claim-text>- a processor system arranged to support a number of parallel random number generating processes for generating the elements of the random matrix,</claim-text>
<claim-text>- a processor system being configured for
<claim-text>- a random number initiation function configured to receive a seed and to generate a random number state,</claim-text>
<claim-text>- a random number generation function configured to generate random numbers in conjunction with updating a random number state,</claim-text></claim-text>
<claim-text>- a processor system being configured to
<claim-text>- initiate the number of supported parallel random number generating processes,</claim-text>
<claim-text>- for each random number generating process executing in parallel the random number initiation function obtaining for each random number generating process a random number state,</claim-text>
<claim-text>- for each random number generating process executing in parallel the random number generation function, wherein the parallel random number generating processes together produce at least as many random numbers as elements in the random matrix,</claim-text>
<claim-text>- assembling the random matrix.</claim-text></claim-text></claim-text></claim>
<claim id="c-en-0002" num="0002">
<claim-text>A generation device as in Claim 1, wherein the number of supported parallel random number generating processes equals,
<claim-text>- a register size divided by a word size of the random number state, or</claim-text>
<claim-text>- a number of cores of the processor system, or</claim-text>
<claim-text>- the product of a register size divided by a random number state size multiplied by a number of cores of the processor system.</claim-text><!-- EPO <DP n="30"> --></claim-text></claim>
<claim id="c-en-0003" num="0003">
<claim-text>A generation device as in any one of the preceding claims, the processor system being arranged with Single Instruction Multiple Data (SIMD) instructions operating on data vectors, a vector being arranged to store a word of the multiple random number states for multiple of the supported parallel random number generating processes, wherein
<claim-text>- the random number initiation function is configured to generate multiple random number states in parallel, and</claim-text>
<claim-text>- the random number generation function is configured to generate multiple random numbers in conjunction with updating the multiple random number states in parallel.</claim-text></claim-text></claim>
<claim id="c-en-0004" num="0004">
<claim-text>A generation device as in any one of the preceding claims, wherein the parallel random number generating processes receive the same seed and a unique number for each random number generating process.</claim-text></claim>
<claim id="c-en-0005" num="0005">
<claim-text>A generation device as in any one of the preceding claims, wherein the random matrix is divided into as many parts as the number of supported parallel random number generating processes, each part being filled with random numbers in parallel by the random number generating processes executing in parallel.</claim-text></claim>
<claim id="c-en-0006" num="0006">
<claim-text>A generation device as in Claim 5, wherein a part comprises multiple rows and/or columns of the random matrix.</claim-text></claim>
<claim id="c-en-0007" num="0007">
<claim-text>A generation device as in any one of the preceding claims, wherein the input interface is configured for receiving the seed.</claim-text></claim>
<claim id="c-en-0008" num="0008">
<claim-text>A generation device as in any one of the preceding claims configured for a cryptographic public-private key protocol, the processor system being configured to generate a private-key (S; U) and compute a public-key (B; U) from the private-key, comprising a noisy multiplication between the generated random matrix (A) and the private-key (S; U).</claim-text></claim>
<claim id="c-en-0009" num="0009">
<claim-text>A generation device as in Claim 8 configured for a cryptographic public-private key protocol with a further generation device, the processor system being configured to
<claim-text>- compute a raw shared key (k; k') from a public-key of the further generation device and the private-key (s), computing the raw shared key comprising a multiplication,<!-- EPO <DP n="31"> --> wherein the generation device and the further generation device are configured to generate the random matrix from the same seed.</claim-text></claim-text></claim>
<claim id="c-en-0010" num="0010">
<claim-text>A cryptographic generation method (500) for generating a random matrix, the method comprising
<claim-text>- receiving (510) a request for the random matrix,</claim-text>
<claim-text>- initiating (520) a number of supported parallel random number generating processes in a processor system arranged to support a number of parallel random number generating processes for generating the elements of the random matrix,</claim-text>
<claim-text>- for each random number generating process executing (530) in parallel a random number initiation function obtaining for each random number generating process a random number state, the random number initiation function being configured to receive a seed and to generate a random number state,</claim-text>
<claim-text>- for each random number generating process executing (540) in parallel a random number generation function, wherein the parallel random number generating processes together produce at least as many random numbers as elements in the random matrix, the random number generation function configured to generate random numbers in conjunction with updating a random number state,</claim-text>
<claim-text>- assembling (550) the random matrix.</claim-text></claim-text></claim>
<claim id="c-en-0011" num="0011">
<claim-text>A transitory or non-transitory computer readable medium (1000) comprising data (1020) representing instructions, which when executed by a processor system, cause the processor system to perform the method according to claim 10.</claim-text></claim>
</claims>
<drawings id="draw" lang="en"><!-- EPO <DP n="32"> -->
<figure id="f0001" num="1,2"><img id="if0001" file="imgf0001.tif" wi="141" he="226" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="33"> -->
<figure id="f0002" num="3a,3b"><img id="if0002" file="imgf0002.tif" wi="152" he="199" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="34"> -->
<figure id="f0003" num="3c"><img id="if0003" file="imgf0003.tif" wi="152" he="179" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="35"> -->
<figure id="f0004" num="3d"><img id="if0004" file="imgf0004.tif" wi="152" he="179" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="36"> -->
<figure id="f0005" num="4"><img id="if0005" file="imgf0005.tif" wi="136" he="187" img-content="drawing" img-format="tif"/></figure><!-- EPO <DP n="37"> -->
<figure id="f0006" num="5,6a,6b"><img id="if0006" file="imgf0006.tif" wi="130" he="227" img-content="drawing" img-format="tif"/></figure>
</drawings>
<search-report-data id="srep" lang="en" srep-office="EP" date-produced=""><doc-page id="srep0001" file="srep0001.tif" wi="151" he="233" type="tif"/><doc-page id="srep0002" file="srep0002.tif" wi="151" he="233" type="tif"/><doc-page id="srep0003" file="srep0003.tif" wi="155" he="233" type="tif"/></search-report-data><search-report-data date-produced="20200731" id="srepxml" lang="en" srep-office="EP" srep-type="ep-sr" status="n"><!--
 The search report data in XML is provided for the users' convenience only. It might differ from the search report of the PDF document, which contains the officially published data. The EPO disclaims any liability for incorrect or incomplete data in the XML for search reports.
 -->

<srep-info><file-reference-id>2020P00161EP</file-reference-id><application-reference><document-id><country>EP</country><doc-number>20167059.3</doc-number></document-id></application-reference><applicant-name><name>Koninklijke Philips N.V.</name></applicant-name><srep-established srep-established="yes"/><srep-invention-title title-approval="yes"/><srep-abstract abs-approval="yes"/><srep-figure-to-publish figinfo="by-applicant"><figure-to-publish><fig-number>1</fig-number></figure-to-publish></srep-figure-to-publish><srep-info-admin><srep-office><addressbook><text>MN</text></addressbook></srep-office><date-search-report-mailed><date>20200810</date></date-search-report-mailed></srep-info-admin></srep-info><srep-for-pub><srep-fields-searched><minimum-documentation><classifications-ipcr><classification-ipcr><text>G06F</text></classification-ipcr></classifications-ipcr></minimum-documentation></srep-fields-searched><srep-citations><citation id="sr-cit0001"><nplcit id="sr-ncit0001" medium="online" npl-type="w"><online><author><name>Erdem Alkim ET AL</name></author><online-title>FrodoKEM Learning With Errors Key Encapsulation Algorithm Specifications And Supporting Documentation Contents</online-title><pubdate>20200325</pubdate><avail>https://frodokem.org/files/FrodoKEM-specification-20200325.pdf</avail><srchdate><date>20200731</date></srchdate><refno>XP055719350</refno></online></nplcit><category>X</category><rel-claims>1-7,10,11</rel-claims><category>Y</category><rel-claims>8,9</rel-claims><rel-passage><passage>* sections 2.2.5 and 3 *</passage></rel-passage></citation><citation id="sr-cit0002"><nplcit id="sr-ncit0002" medium="online" npl-type="w"><online><author><name>Anonymous</name></author><online-title>PQCrypto-LWEKE/fips202x4.c at master . microsoft/PQCrypto-LWEKE . GitHub</online-title><pubdate>20190306</pubdate><location><pp><ppf>1</ppf><ppl>6</ppl></pp></location><avail>https://github.com/microsoft/PQCrypto-LWEKE/blob/master/src/sha3/fips202x4.c</avail><srchdate><date>20200731</date></srchdate><refno>XP055719374</refno></online></nplcit><category>X</category><rel-claims>1-7,10,11</rel-claims><category>Y</category><rel-claims>8,9</rel-claims><rel-passage><passage>* the whole document *</passage></rel-passage></citation><citation id="sr-cit0003"><nplcit id="sr-ncit0003" medium="online" npl-type="w"><online><author><name>Anonymous</name></author><online-title>PQCrypto-LWEKE_frodo_macrify.c at master . microsoft_PQCrypto-LWEKE . GitHub</online-title><pubdate>20190425</pubdate><location><pp><ppf>1</ppf><ppl>13</ppl></pp></location><avail>https://github.com/microsoft/PQCrypto-LWEKE/blob/master/src/frodo_macrify.c</avail><srchdate><date>20200731</date></srchdate><refno>XP055719423</refno></online></nplcit><category>X</category><rel-claims>1-7,10,11</rel-claims><category>Y</category><rel-claims>8,9</rel-claims><rel-passage><passage>* the whole document *</passage></rel-passage></citation><citation id="sr-cit0004"><nplcit id="sr-ncit0004" npl-type="s"><article><author><name>BOS JOPPE ET AL</name></author><atl>CRYSTALS - Kyber: A CCA-Secure Module-Lattice-Based KEM</atl><serial><sertitle>2018 IEEE EUROPEAN SYMPOSIUM ON SECURITY AND PRIVACY (EUROS&amp;P), IEEE</sertitle><pubdate>20180424</pubdate><doi>10.1109/EUROSP.2018.00032</doi></serial><location><pp><ppf>353</ppf><ppl>367</ppl></pp></location><refno>XP033373216</refno></article></nplcit><category>X</category><rel-claims>1-7,10,11</rel-claims><category>Y</category><rel-claims>8,9</rel-claims><rel-passage><passage>* section 7 *</passage></rel-passage></citation><citation id="sr-cit0005"><patcit dnum="EP3624391A1" id="sr-pcit0001" url="http://v3.espacenet.com/textdoc?DB=EPODOC&amp;IDX=EP3624391&amp;CY=ep"><document-id><country>EP</country><doc-number>3624391</doc-number><kind>A1</kind><name>KONINKLIJKE PHILIPS NV [NL]</name><date>20200318</date></document-id></patcit><category>Y</category><rel-claims>8,9</rel-claims><rel-passage><passage>* paragraph [0050] - paragraph [0054] *</passage></rel-passage></citation></srep-citations><srep-admin><examiners><primary-examiner><name>Tenbieg, Christoph</name></primary-examiner></examiners><srep-office><addressbook><text>Munich</text></addressbook></srep-office><date-search-completed><date>20200731</date></date-search-completed></srep-admin><!--							The annex lists the patent family members relating to the patent documents cited in the above mentioned European search report.							The members are as contained in the European Patent Office EDP file on							The European Patent Office is in no way liable for these particulars which are merely given for the purpose of information.							For more details about this annex : see Official Journal of the European Patent Office, No 12/82						--><srep-patent-family><patent-family><priority-application><document-id><country>EP</country><doc-number>3624391</doc-number><kind>A1</kind><date>20200318</date></document-id></priority-application><family-member><document-id><country>BR</country><doc-number>112021004855</doc-number><kind>A2</kind><date>20210608</date></document-id></family-member><family-member><document-id><country>CN</country><doc-number>112997448</doc-number><kind>A</kind><date>20210618</date></document-id></family-member><family-member><document-id><country>EP</country><doc-number>3624391</doc-number><kind>A1</kind><date>20200318</date></document-id></family-member><family-member><document-id><country>EP</country><doc-number>3850784</doc-number><kind>A1</kind><date>20210721</date></document-id></family-member><family-member><document-id><country>WO</country><doc-number>2020053013</doc-number><kind>A1</kind><date>20200319</date></document-id></family-member></patent-family></srep-patent-family></srep-for-pub></search-report-data>
<ep-reference-list id="ref-list">
<heading id="ref-h0001"><b>REFERENCES CITED IN THE DESCRIPTION</b></heading>
<p id="ref-p0001" num=""><i>This list of references cited by the applicant is for the reader's convenience only. It does not form part of the European patent document. Even though great care has been taken in compiling the references, errors or omissions cannot be excluded and the EPO disclaims all liability in this regard.</i></p>
<heading id="ref-h0002"><b>Non-patent literature cited in the description</b></heading>
<p id="ref-p0002" num="">
<ul id="ref-ul0001" list-style="bullet">
<li><nplcit id="ref-ncit0001" npl-type="s"><article><atl/><serial><sertitle>Round5: KEM and PKE based on (Ring) Learning with Rounding</sertitle><pubdate><sdate>20190328</sdate><edate/></pubdate></serial></article></nplcit><crossref idref="ncit0001">[0006]</crossref></li>
<li><nplcit id="ref-ncit0002" npl-type="s" url="https://round5.org/doc/Round5_Submission022020.pdf."><article><atl/><serial><sertitle>Round5: KEM and PKE based on (Ring) Learning with Rounding Tuesday 18th February, 2020</sertitle><pubdate><sdate>20200818</sdate><edate/></pubdate></serial></article></nplcit><crossref idref="ncit0002">[0006]</crossref></li>
<li><nplcit id="ref-ncit0003" npl-type="s"><article><author><name>FRODOKEM</name></author><atl/><serial><sertitle>Frodo-KEM: Learning With Errors Key Encapsulation</sertitle><pubdate><sdate>20190330</sdate><edate/></pubdate></serial></article></nplcit><crossref idref="ncit0003">[0007]</crossref></li>
<li><nplcit id="ref-ncit0004" npl-type="s"><article><atl/><serial><sertitle>Round5: KEM and PKE based on (Ring) Learning with Rounding Tuesday 18th February 2020</sertitle><pubdate><sdate>20200218</sdate><edate/></pubdate></serial><location><pp><ppf>56</ppf><ppl/></pp></location></article></nplcit><crossref idref="ncit0004">[0084]</crossref></li>
<li><nplcit id="ref-ncit0005" npl-type="s"><article><author><name>HAYO BAAN</name></author><atl/><serial><sertitle>Round2: KEM and PKE based on GLWR</sertitle></serial></article></nplcit><crossref idref="ncit0005">[0101]</crossref></li>
</ul></p>
</ep-reference-list>
</ep-patent-document>
